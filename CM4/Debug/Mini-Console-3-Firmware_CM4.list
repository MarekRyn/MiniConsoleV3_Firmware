
Mini-Console-3-Firmware_CM4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08100000  08100000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000038f4  08100298  08100298  00010298  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001268  08103b8c  08103b8c  00013b8c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08104df4  08104df4  00014df4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08104df8  08104df8  00014df8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000004c  10000000  08104dfc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00003458  1000004c  08104e48  0002004c  2**2
                  ALLOC
  7 ._user_heap_stack 00000604  100034a4  08104e48  000234a4  2**0
                  ALLOC
  8 .sh0_ram      00000000  10040000  10040000  0002004c  2**0
                  CONTENTS
  9 .ARM.attributes 00000030  00000000  00000000  0002004c  2**0
                  CONTENTS, READONLY
 10 .comment      00000043  00000000  00000000  0002007c  2**0
                  CONTENTS, READONLY
 11 .debug_info   00007ab9  00000000  00000000  000200bf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 000019dd  00000000  00000000  00027b78  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 000005f0  00000000  00000000  00029558  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_rnglists 00000447  00000000  00000000  00029b48  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  00003482  00000000  00000000  00029f8f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   0000aaf6  00000000  00000000  0002d411  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0011e506  00000000  00000000  00037f07  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  000013f4  00000000  00000000  00156410  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line_str 00000057  00000000  00000000  00157804  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08100298 <__do_global_dtors_aux>:
 8100298:	b510      	push	{r4, lr}
 810029a:	4c05      	ldr	r4, [pc, #20]	; (81002b0 <__do_global_dtors_aux+0x18>)
 810029c:	7823      	ldrb	r3, [r4, #0]
 810029e:	b933      	cbnz	r3, 81002ae <__do_global_dtors_aux+0x16>
 81002a0:	4b04      	ldr	r3, [pc, #16]	; (81002b4 <__do_global_dtors_aux+0x1c>)
 81002a2:	b113      	cbz	r3, 81002aa <__do_global_dtors_aux+0x12>
 81002a4:	4804      	ldr	r0, [pc, #16]	; (81002b8 <__do_global_dtors_aux+0x20>)
 81002a6:	f3af 8000 	nop.w
 81002aa:	2301      	movs	r3, #1
 81002ac:	7023      	strb	r3, [r4, #0]
 81002ae:	bd10      	pop	{r4, pc}
 81002b0:	1000004c 	.word	0x1000004c
 81002b4:	00000000 	.word	0x00000000
 81002b8:	08103b74 	.word	0x08103b74

081002bc <frame_dummy>:
 81002bc:	b508      	push	{r3, lr}
 81002be:	4b03      	ldr	r3, [pc, #12]	; (81002cc <frame_dummy+0x10>)
 81002c0:	b11b      	cbz	r3, 81002ca <frame_dummy+0xe>
 81002c2:	4903      	ldr	r1, [pc, #12]	; (81002d0 <frame_dummy+0x14>)
 81002c4:	4803      	ldr	r0, [pc, #12]	; (81002d4 <frame_dummy+0x18>)
 81002c6:	f3af 8000 	nop.w
 81002ca:	bd08      	pop	{r3, pc}
 81002cc:	00000000 	.word	0x00000000
 81002d0:	10000050 	.word	0x10000050
 81002d4:	08103b74 	.word	0x08103b74

081002d8 <BSP_DRV_Audio_Enable>:
 * - 0.1b	- Development version
 *******************************************************************/

#include "MAX98357A.h"

uint8_t BSP_DRV_Audio_Enable() {
 81002d8:	b580      	push	{r7, lr}
 81002da:	af00      	add	r7, sp, #0

	BSP_STM32_GPIO_WritePin(AUDIO_EN_PORT, AUDIO_EN_PIN, SET);
 81002dc:	2201      	movs	r2, #1
 81002de:	2104      	movs	r1, #4
 81002e0:	4802      	ldr	r0, [pc, #8]	; (81002ec <BSP_DRV_Audio_Enable+0x14>)
 81002e2:	f002 ff2b 	bl	810313c <BSP_STM32_GPIO_WritePin>

	return BSP_OK;
 81002e6:	2300      	movs	r3, #0
}
 81002e8:	4618      	mov	r0, r3
 81002ea:	bd80      	pop	{r7, pc}
 81002ec:	58021000 	.word	0x58021000

081002f0 <BSP_BOARD_Init_CM4>:

// Includes

#include "BSP.h"

uint8_t BSP_BOARD_Init_CM4() {
 81002f0:	b580      	push	{r7, lr}
 81002f2:	af00      	add	r7, sp, #0

	// Config MPU
	BSP_STM32_MPU_Init();
 81002f4:	f000 f952 	bl	810059c <BSP_STM32_MPU_Init>

	// STM32 Initialization - RCC
	if (BSP_STM32_Init_PeriphClocks()) return BSP_ERROR;
 81002f8:	f000 fa20 	bl	810073c <BSP_STM32_Init_PeriphClocks>
 81002fc:	4603      	mov	r3, r0
 81002fe:	2b00      	cmp	r3, #0
 8100300:	d001      	beq.n	8100306 <BSP_BOARD_Init_CM4+0x16>
 8100302:	2301      	movs	r3, #1
 8100304:	e015      	b.n	8100332 <BSP_BOARD_Init_CM4+0x42>

	// STM32 Initialization - GPIO Pins
	if (BSP_STM32_Init_GPIO()) return BSP_ERROR;
 8100306:	f000 fa8b 	bl	8100820 <BSP_STM32_Init_GPIO>
 810030a:	4603      	mov	r3, r0
 810030c:	2b00      	cmp	r3, #0
 810030e:	d001      	beq.n	8100314 <BSP_BOARD_Init_CM4+0x24>
 8100310:	2301      	movs	r3, #1
 8100312:	e00e      	b.n	8100332 <BSP_BOARD_Init_CM4+0x42>

	// STM32 Initialization - NVIC - Interrupts
	if (BSP_STM32_Init_NVIC()) return BSP_ERROR;
 8100314:	f000 fa50 	bl	81007b8 <BSP_STM32_Init_NVIC>
 8100318:	4603      	mov	r3, r0
 810031a:	2b00      	cmp	r3, #0
 810031c:	d001      	beq.n	8100322 <BSP_BOARD_Init_CM4+0x32>
 810031e:	2301      	movs	r3, #1
 8100320:	e007      	b.n	8100332 <BSP_BOARD_Init_CM4+0x42>

	// Audio Initialization
	if (BSP_Audio_Init()) return BSP_ERROR;
 8100322:	f000 f8af 	bl	8100484 <BSP_Audio_Init>
 8100326:	4603      	mov	r3, r0
 8100328:	2b00      	cmp	r3, #0
 810032a:	d001      	beq.n	8100330 <BSP_BOARD_Init_CM4+0x40>
 810032c:	2301      	movs	r3, #1
 810032e:	e000      	b.n	8100332 <BSP_BOARD_Init_CM4+0x42>

	return BSP_OK;
 8100330:	2300      	movs	r3, #0
}
 8100332:	4618      	mov	r0, r3
 8100334:	bd80      	pop	{r7, pc}

08100336 <NMI_Handler>:

// Configuring Basic Interrupts

void NMI_Handler(void) {
 8100336:	b480      	push	{r7}
 8100338:	af00      	add	r7, sp, #0

  while (1) {}
 810033a:	e7fe      	b.n	810033a <NMI_Handler+0x4>

0810033c <HardFault_Handler>:

}

void HardFault_Handler(void) {
 810033c:	b480      	push	{r7}
 810033e:	af00      	add	r7, sp, #0

  while (1) {}
 8100340:	e7fe      	b.n	8100340 <HardFault_Handler+0x4>

08100342 <MemManage_Handler>:

}

void MemManage_Handler(void) {
 8100342:	b480      	push	{r7}
 8100344:	af00      	add	r7, sp, #0

  while (1) {}
 8100346:	e7fe      	b.n	8100346 <MemManage_Handler+0x4>

08100348 <BusFault_Handler>:

}

void BusFault_Handler(void) {
 8100348:	b480      	push	{r7}
 810034a:	af00      	add	r7, sp, #0

  while (1) {}
 810034c:	e7fe      	b.n	810034c <BusFault_Handler+0x4>

0810034e <UsageFault_Handler>:

}

void UsageFault_Handler(void) {
 810034e:	b480      	push	{r7}
 8100350:	af00      	add	r7, sp, #0

  while (1) {}
 8100352:	e7fe      	b.n	8100352 <UsageFault_Handler+0x4>

08100354 <SVC_Handler>:

}

void SVC_Handler(void) {
 8100354:	b480      	push	{r7}
 8100356:	af00      	add	r7, sp, #0

}
 8100358:	bf00      	nop
 810035a:	46bd      	mov	sp, r7
 810035c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100360:	4770      	bx	lr

08100362 <DebugMon_Handler>:

void DebugMon_Handler(void) {
 8100362:	b480      	push	{r7}
 8100364:	af00      	add	r7, sp, #0

}
 8100366:	bf00      	nop
 8100368:	46bd      	mov	sp, r7
 810036a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810036e:	4770      	bx	lr

08100370 <PendSV_Handler>:

void PendSV_Handler(void) {
 8100370:	b480      	push	{r7}
 8100372:	af00      	add	r7, sp, #0

}
 8100374:	bf00      	nop
 8100376:	46bd      	mov	sp, r7
 8100378:	f85d 7b04 	ldr.w	r7, [sp], #4
 810037c:	4770      	bx	lr

0810037e <SysTick_Handler>:

void SysTick_Handler(void) {
 810037e:	b580      	push	{r7, lr}
 8100380:	af00      	add	r7, sp, #0

  BSP_IncTick();
 8100382:	f000 fab7 	bl	81008f4 <BSP_IncTick>

}
 8100386:	bf00      	nop
 8100388:	bd80      	pop	{r7, pc}
	...

0810038c <SPI3_IRQHandler>:


// ********** IRQ Handlers and Callbacks ****************

// I2S3 IRQ Handler
void SPI3_IRQHandler(void) {
 810038c:	b580      	push	{r7, lr}
 810038e:	af00      	add	r7, sp, #0
	BSP_STM32_I2S_IRQHandler(AUDIO_I2S, &BSP_haudio_ctx);
 8100390:	4902      	ldr	r1, [pc, #8]	; (810039c <SPI3_IRQHandler+0x10>)
 8100392:	4803      	ldr	r0, [pc, #12]	; (81003a0 <SPI3_IRQHandler+0x14>)
 8100394:	f002 fff8 	bl	8103388 <BSP_STM32_I2S_IRQHandler>
}
 8100398:	bf00      	nop
 810039a:	bd80      	pop	{r7, pc}
 810039c:	10000068 	.word	0x10000068
 81003a0:	40003c00 	.word	0x40003c00

081003a4 <CM7_SEV_IRQHandler>:

// IRQ from Core CM7 - activated when new command is available to process
void CM7_SEV_IRQHandler(void) {
 81003a4:	b480      	push	{r7}
 81003a6:	af00      	add	r7, sp, #0
	return;
 81003a8:	bf00      	nop
}
 81003aa:	46bd      	mov	sp, r7
 81003ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 81003b0:	4770      	bx	lr
	...

081003b4 <_AudioCallbackTC>:

// Callback when DMA reach end of buffer
void _AudioCallbackTC(TxRxContext_TypeDef * ctx) {
 81003b4:	b580      	push	{r7, lr}
 81003b6:	b084      	sub	sp, #16
 81003b8:	af00      	add	r7, sp, #0
 81003ba:	6078      	str	r0, [r7, #4]
	hxcmod_fillbuffer(&modctx, (msample *)&AudioBuf[AUDIO_BUF_SIZE], AUDIO_BUF_SIZE / 2, NULL);
 81003bc:	2300      	movs	r3, #0
 81003be:	f44f 6280 	mov.w	r2, #1024	; 0x400
 81003c2:	4912      	ldr	r1, [pc, #72]	; (810040c <_AudioCallbackTC+0x58>)
 81003c4:	4812      	ldr	r0, [pc, #72]	; (8100410 <_AudioCallbackTC+0x5c>)
 81003c6:	f001 fb7f 	bl	8101ac8 <hxcmod_fillbuffer>
	for (uint32_t i = 0; i < AUDIO_BUF_SIZE; i++) AudioBuf[i + AUDIO_BUF_SIZE] /= 4;
 81003ca:	2300      	movs	r3, #0
 81003cc:	60fb      	str	r3, [r7, #12]
 81003ce:	e014      	b.n	81003fa <_AudioCallbackTC+0x46>
 81003d0:	68fb      	ldr	r3, [r7, #12]
 81003d2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 81003d6:	4a0f      	ldr	r2, [pc, #60]	; (8100414 <_AudioCallbackTC+0x60>)
 81003d8:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 81003dc:	68fb      	ldr	r3, [r7, #12]
 81003de:	f503 6200 	add.w	r2, r3, #2048	; 0x800
 81003e2:	460b      	mov	r3, r1
 81003e4:	2b00      	cmp	r3, #0
 81003e6:	da00      	bge.n	81003ea <_AudioCallbackTC+0x36>
 81003e8:	3303      	adds	r3, #3
 81003ea:	109b      	asrs	r3, r3, #2
 81003ec:	b219      	sxth	r1, r3
 81003ee:	4b09      	ldr	r3, [pc, #36]	; (8100414 <_AudioCallbackTC+0x60>)
 81003f0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
 81003f4:	68fb      	ldr	r3, [r7, #12]
 81003f6:	3301      	adds	r3, #1
 81003f8:	60fb      	str	r3, [r7, #12]
 81003fa:	68fb      	ldr	r3, [r7, #12]
 81003fc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8100400:	d3e6      	bcc.n	81003d0 <_AudioCallbackTC+0x1c>
	UNUSED(ctx);
}
 8100402:	bf00      	nop
 8100404:	bf00      	nop
 8100406:	3710      	adds	r7, #16
 8100408:	46bd      	mov	sp, r7
 810040a:	bd80      	pop	{r7, pc}
 810040c:	100010d0 	.word	0x100010d0
 8100410:	100020d0 	.word	0x100020d0
 8100414:	100000d0 	.word	0x100000d0

08100418 <_AudioCallbackHT>:

// Callback when DMA reach half of buffer
void _AudioCallbackHT(TxRxContext_TypeDef * ctx) {
 8100418:	b580      	push	{r7, lr}
 810041a:	b084      	sub	sp, #16
 810041c:	af00      	add	r7, sp, #0
 810041e:	6078      	str	r0, [r7, #4]
	hxcmod_fillbuffer(&modctx, (msample *)&AudioBuf[0], AUDIO_BUF_SIZE / 2, NULL);
 8100420:	2300      	movs	r3, #0
 8100422:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8100426:	4910      	ldr	r1, [pc, #64]	; (8100468 <_AudioCallbackHT+0x50>)
 8100428:	4810      	ldr	r0, [pc, #64]	; (810046c <_AudioCallbackHT+0x54>)
 810042a:	f001 fb4d 	bl	8101ac8 <hxcmod_fillbuffer>
	for (uint32_t i = 0; i < AUDIO_BUF_SIZE; i++) AudioBuf[i] /= 4;
 810042e:	2300      	movs	r3, #0
 8100430:	60fb      	str	r3, [r7, #12]
 8100432:	e00f      	b.n	8100454 <_AudioCallbackHT+0x3c>
 8100434:	4a0c      	ldr	r2, [pc, #48]	; (8100468 <_AudioCallbackHT+0x50>)
 8100436:	68fb      	ldr	r3, [r7, #12]
 8100438:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 810043c:	2b00      	cmp	r3, #0
 810043e:	da00      	bge.n	8100442 <_AudioCallbackHT+0x2a>
 8100440:	3303      	adds	r3, #3
 8100442:	109b      	asrs	r3, r3, #2
 8100444:	b219      	sxth	r1, r3
 8100446:	4a08      	ldr	r2, [pc, #32]	; (8100468 <_AudioCallbackHT+0x50>)
 8100448:	68fb      	ldr	r3, [r7, #12]
 810044a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 810044e:	68fb      	ldr	r3, [r7, #12]
 8100450:	3301      	adds	r3, #1
 8100452:	60fb      	str	r3, [r7, #12]
 8100454:	68fb      	ldr	r3, [r7, #12]
 8100456:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 810045a:	d3eb      	bcc.n	8100434 <_AudioCallbackHT+0x1c>
	UNUSED(ctx);
}
 810045c:	bf00      	nop
 810045e:	bf00      	nop
 8100460:	3710      	adds	r7, #16
 8100462:	46bd      	mov	sp, r7
 8100464:	bd80      	pop	{r7, pc}
 8100466:	bf00      	nop
 8100468:	100000d0 	.word	0x100000d0
 810046c:	100020d0 	.word	0x100020d0

08100470 <_AudioCallbackTE>:

// Callback on DMA error
void _AudioCallbackTE(TxRxContext_TypeDef * ctx) {
 8100470:	b480      	push	{r7}
 8100472:	b083      	sub	sp, #12
 8100474:	af00      	add	r7, sp, #0
 8100476:	6078      	str	r0, [r7, #4]
	UNUSED(ctx);
}
 8100478:	bf00      	nop
 810047a:	370c      	adds	r7, #12
 810047c:	46bd      	mov	sp, r7
 810047e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100482:	4770      	bx	lr

08100484 <BSP_Audio_Init>:


// ********** Public functions ****************


uint8_t BSP_Audio_Init() {
 8100484:	b580      	push	{r7, lr}
 8100486:	b084      	sub	sp, #16
 8100488:	af04      	add	r7, sp, #16
	// Configuring I2S Interface
	BSP_STM32_I2S_Init(AUDIO_I2S, &BSP_haudio_ctx, I2S_AUDIOFREQ_44K);
 810048a:	f64a 4244 	movw	r2, #44100	; 0xac44
 810048e:	4917      	ldr	r1, [pc, #92]	; (81004ec <BSP_Audio_Init+0x68>)
 8100490:	4817      	ldr	r0, [pc, #92]	; (81004f0 <BSP_Audio_Init+0x6c>)
 8100492:	f002 fea1 	bl	81031d8 <BSP_STM32_I2S_Init>

	// Linking DMA stream to I2C context
	BSP_STM32_DMA_Init(AUDIO_DMA, DMA_MEMORY_TO_PERIPH, DMA_PINC_DISABLE, DMA_MINC_ENABLE, DMA_PDATAALIGN_HALFWORD, DMA_MDATAALIGN_HALFWORD, DMA_CIRCULAR, DMA_PRIORITY_LOW);
 8100496:	2300      	movs	r3, #0
 8100498:	9303      	str	r3, [sp, #12]
 810049a:	f44f 7380 	mov.w	r3, #256	; 0x100
 810049e:	9302      	str	r3, [sp, #8]
 81004a0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 81004a4:	9301      	str	r3, [sp, #4]
 81004a6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 81004aa:	9300      	str	r3, [sp, #0]
 81004ac:	f44f 6380 	mov.w	r3, #1024	; 0x400
 81004b0:	2200      	movs	r2, #0
 81004b2:	2140      	movs	r1, #64	; 0x40
 81004b4:	480f      	ldr	r0, [pc, #60]	; (81004f4 <BSP_Audio_Init+0x70>)
 81004b6:	f002 f9f7 	bl	81028a8 <BSP_STM32_DMA_Init>

	BSP_haudio_ctx.callback_HT = (uint32_t)_AudioCallbackHT;
 81004ba:	4a0f      	ldr	r2, [pc, #60]	; (81004f8 <BSP_Audio_Init+0x74>)
 81004bc:	4b0b      	ldr	r3, [pc, #44]	; (81004ec <BSP_Audio_Init+0x68>)
 81004be:	61da      	str	r2, [r3, #28]
	BSP_haudio_ctx.callback_TC = (uint32_t)_AudioCallbackTC;
 81004c0:	4a0e      	ldr	r2, [pc, #56]	; (81004fc <BSP_Audio_Init+0x78>)
 81004c2:	4b0a      	ldr	r3, [pc, #40]	; (81004ec <BSP_Audio_Init+0x68>)
 81004c4:	621a      	str	r2, [r3, #32]
	BSP_haudio_ctx.callback_TE = (uint32_t)_AudioCallbackTE;
 81004c6:	4a0e      	ldr	r2, [pc, #56]	; (8100500 <BSP_Audio_Init+0x7c>)
 81004c8:	4b08      	ldr	r3, [pc, #32]	; (81004ec <BSP_Audio_Init+0x68>)
 81004ca:	625a      	str	r2, [r3, #36]	; 0x24

	if (BSP_STM32_DMA_CtxLink(AUDIO_DMA, &BSP_haudio_ctx, DMA_REQUEST_SPI3_TX)) return BSP_ERROR;
 81004cc:	223e      	movs	r2, #62	; 0x3e
 81004ce:	4907      	ldr	r1, [pc, #28]	; (81004ec <BSP_Audio_Init+0x68>)
 81004d0:	4808      	ldr	r0, [pc, #32]	; (81004f4 <BSP_Audio_Init+0x70>)
 81004d2:	f002 fa35 	bl	8102940 <BSP_STM32_DMA_CtxLink>
 81004d6:	4603      	mov	r3, r0
 81004d8:	2b00      	cmp	r3, #0
 81004da:	d001      	beq.n	81004e0 <BSP_Audio_Init+0x5c>
 81004dc:	2301      	movs	r3, #1
 81004de:	e002      	b.n	81004e6 <BSP_Audio_Init+0x62>

	// Enable Audio Amplifiers
	BSP_DRV_Audio_Enable();
 81004e0:	f7ff fefa 	bl	81002d8 <BSP_DRV_Audio_Enable>

	// Initialization of Audio Engine


	return BSP_OK;
 81004e4:	2300      	movs	r3, #0
}
 81004e6:	4618      	mov	r0, r3
 81004e8:	46bd      	mov	sp, r7
 81004ea:	bd80      	pop	{r7, pc}
 81004ec:	10000068 	.word	0x10000068
 81004f0:	40003c00 	.word	0x40003c00
 81004f4:	40020010 	.word	0x40020010
 81004f8:	08100419 	.word	0x08100419
 81004fc:	081003b5 	.word	0x081003b5
 8100500:	08100471 	.word	0x08100471

08100504 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8100504:	b480      	push	{r7}
 8100506:	b083      	sub	sp, #12
 8100508:	af00      	add	r7, sp, #0
 810050a:	4603      	mov	r3, r0
 810050c:	6039      	str	r1, [r7, #0]
 810050e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8100510:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8100514:	2b00      	cmp	r3, #0
 8100516:	db0a      	blt.n	810052e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8100518:	683b      	ldr	r3, [r7, #0]
 810051a:	b2da      	uxtb	r2, r3
 810051c:	490c      	ldr	r1, [pc, #48]	; (8100550 <__NVIC_SetPriority+0x4c>)
 810051e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8100522:	0112      	lsls	r2, r2, #4
 8100524:	b2d2      	uxtb	r2, r2
 8100526:	440b      	add	r3, r1
 8100528:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 810052c:	e00a      	b.n	8100544 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 810052e:	683b      	ldr	r3, [r7, #0]
 8100530:	b2da      	uxtb	r2, r3
 8100532:	4908      	ldr	r1, [pc, #32]	; (8100554 <__NVIC_SetPriority+0x50>)
 8100534:	88fb      	ldrh	r3, [r7, #6]
 8100536:	f003 030f 	and.w	r3, r3, #15
 810053a:	3b04      	subs	r3, #4
 810053c:	0112      	lsls	r2, r2, #4
 810053e:	b2d2      	uxtb	r2, r2
 8100540:	440b      	add	r3, r1
 8100542:	761a      	strb	r2, [r3, #24]
}
 8100544:	bf00      	nop
 8100546:	370c      	adds	r7, #12
 8100548:	46bd      	mov	sp, r7
 810054a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810054e:	4770      	bx	lr
 8100550:	e000e100 	.word	0xe000e100
 8100554:	e000ed00 	.word	0xe000ed00

08100558 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8100558:	b580      	push	{r7, lr}
 810055a:	b082      	sub	sp, #8
 810055c:	af00      	add	r7, sp, #0
 810055e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8100560:	687b      	ldr	r3, [r7, #4]
 8100562:	3b01      	subs	r3, #1
 8100564:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8100568:	d301      	bcc.n	810056e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 810056a:	2301      	movs	r3, #1
 810056c:	e00f      	b.n	810058e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 810056e:	4a0a      	ldr	r2, [pc, #40]	; (8100598 <SysTick_Config+0x40>)
 8100570:	687b      	ldr	r3, [r7, #4]
 8100572:	3b01      	subs	r3, #1
 8100574:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8100576:	210f      	movs	r1, #15
 8100578:	f04f 30ff 	mov.w	r0, #4294967295
 810057c:	f7ff ffc2 	bl	8100504 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8100580:	4b05      	ldr	r3, [pc, #20]	; (8100598 <SysTick_Config+0x40>)
 8100582:	2200      	movs	r2, #0
 8100584:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8100586:	4b04      	ldr	r3, [pc, #16]	; (8100598 <SysTick_Config+0x40>)
 8100588:	2207      	movs	r2, #7
 810058a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 810058c:	2300      	movs	r3, #0
}
 810058e:	4618      	mov	r0, r3
 8100590:	3708      	adds	r7, #8
 8100592:	46bd      	mov	sp, r7
 8100594:	bd80      	pop	{r7, pc}
 8100596:	bf00      	nop
 8100598:	e000e010 	.word	0xe000e010

0810059c <BSP_STM32_MPU_Init>:

__IO static uint32_t tickvalue = 0;
__IO static uint32_t tickfrequency = 1;


uint8_t BSP_STM32_MPU_Init() {
 810059c:	b580      	push	{r7, lr}
 810059e:	b084      	sub	sp, #16
 81005a0:	af00      	add	r7, sp, #0
	MPU_Region_TypeDef MPU_InitStruct = {0};
 81005a2:	463b      	mov	r3, r7
 81005a4:	2200      	movs	r2, #0
 81005a6:	601a      	str	r2, [r3, #0]
 81005a8:	605a      	str	r2, [r3, #4]
 81005aa:	609a      	str	r2, [r3, #8]
 81005ac:	60da      	str	r2, [r3, #12]

	// Disables the MPU
	BSP_STM32_MPU_Disable();
 81005ae:	f002 f91d 	bl	81027ec <BSP_STM32_MPU_Disable>

	// 0x00: CONFIGURING MPU FOR ALL ADDRESS SPACE (4GB)
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 81005b2:	2301      	movs	r3, #1
 81005b4:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 81005b6:	2300      	movs	r3, #0
 81005b8:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.BaseAddress = 0x00000000;
 81005ba:	2300      	movs	r3, #0
 81005bc:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 81005be:	231f      	movs	r3, #31
 81005c0:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 81005c2:	2300      	movs	r3, #0
 81005c4:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 81005c6:	2301      	movs	r3, #1
 81005c8:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 81005ca:	2300      	movs	r3, #0
 81005cc:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 81005ce:	2300      	movs	r3, #0
 81005d0:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 81005d2:	2301      	movs	r3, #1
 81005d4:	733b      	strb	r3, [r7, #12]
	MPU_InitStruct.SubRegionDisable = 0x04; // <- Peripherals registers (0x40000000, 512MB) to be left in default configuration
 81005d6:	2304      	movs	r3, #4
 81005d8:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
 81005da:	2300      	movs	r3, #0
 81005dc:	72fb      	strb	r3, [r7, #11]
	BSP_STM32_MPU_ConfigRegion(&MPU_InitStruct);
 81005de:	463b      	mov	r3, r7
 81005e0:	4618      	mov	r0, r3
 81005e2:	f002 f91b 	bl	810281c <BSP_STM32_MPU_ConfigRegion>

	// 0x01: SND_FLASH MEMORY (512kB)
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 81005e6:	2301      	movs	r3, #1
 81005e8:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.Number = MPU_REGION_NUMBER1;
 81005ea:	2301      	movs	r3, #1
 81005ec:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.BaseAddress = 0x08100000;
 81005ee:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
 81005f2:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_512KB;
 81005f4:	2312      	movs	r3, #18
 81005f6:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 81005f8:	2300      	movs	r3, #0
 81005fa:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 81005fc:	2301      	movs	r3, #1
 81005fe:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 8100600:	2301      	movs	r3, #1
 8100602:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 8100604:	2300      	movs	r3, #0
 8100606:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8100608:	2300      	movs	r3, #0
 810060a:	733b      	strb	r3, [r7, #12]
	MPU_InitStruct.SubRegionDisable = 0x00;
 810060c:	2300      	movs	r3, #0
 810060e:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RW;
 8100610:	2301      	movs	r3, #1
 8100612:	72fb      	strb	r3, [r7, #11]
	BSP_STM32_MPU_ConfigRegion(&MPU_InitStruct);
 8100614:	463b      	mov	r3, r7
 8100616:	4618      	mov	r0, r3
 8100618:	f002 f900 	bl	810281c <BSP_STM32_MPU_ConfigRegion>

	// 0x02: SND_RAM MEMORY (256kB)
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 810061c:	2301      	movs	r3, #1
 810061e:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.Number = MPU_REGION_NUMBER2;
 8100620:	2302      	movs	r3, #2
 8100622:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.BaseAddress = 0x10000000;
 8100624:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8100628:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 810062a:	2311      	movs	r3, #17
 810062c:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
 810062e:	2301      	movs	r3, #1
 8100630:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 8100632:	2301      	movs	r3, #1
 8100634:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 8100636:	2301      	movs	r3, #1
 8100638:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 810063a:	2301      	movs	r3, #1
 810063c:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 810063e:	2301      	movs	r3, #1
 8100640:	733b      	strb	r3, [r7, #12]
	MPU_InitStruct.SubRegionDisable = 0x00;
 8100642:	2300      	movs	r3, #0
 8100644:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RW;
 8100646:	2301      	movs	r3, #1
 8100648:	72fb      	strb	r3, [r7, #11]
	BSP_STM32_MPU_ConfigRegion(&MPU_InitStruct);
 810064a:	463b      	mov	r3, r7
 810064c:	4618      	mov	r0, r3
 810064e:	f002 f8e5 	bl	810281c <BSP_STM32_MPU_ConfigRegion>

	// 0x03: SH0_RAM MEMORY (32kB)
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8100652:	2301      	movs	r3, #1
 8100654:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.Number = MPU_REGION_NUMBER3;
 8100656:	2303      	movs	r3, #3
 8100658:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.BaseAddress = 0x10040000;
 810065a:	4b37      	ldr	r3, [pc, #220]	; (8100738 <BSP_STM32_MPU_Init+0x19c>)
 810065c:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_32KB;
 810065e:	230e      	movs	r3, #14
 8100660:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
 8100662:	2301      	movs	r3, #1
 8100664:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 8100666:	2301      	movs	r3, #1
 8100668:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 810066a:	2301      	movs	r3, #1
 810066c:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 810066e:	2301      	movs	r3, #1
 8100670:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 8100672:	2301      	movs	r3, #1
 8100674:	733b      	strb	r3, [r7, #12]
	MPU_InitStruct.SubRegionDisable = 0x00;
 8100676:	2300      	movs	r3, #0
 8100678:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RW;
 810067a:	2301      	movs	r3, #1
 810067c:	72fb      	strb	r3, [r7, #11]
	BSP_STM32_MPU_ConfigRegion(&MPU_InitStruct);
 810067e:	463b      	mov	r3, r7
 8100680:	4618      	mov	r0, r3
 8100682:	f002 f8cb 	bl	810281c <BSP_STM32_MPU_ConfigRegion>

	// 0x04: SH0_RAM MEMORY (512MB)
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8100686:	2301      	movs	r3, #1
 8100688:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.Number = MPU_REGION_NUMBER4;
 810068a:	2304      	movs	r3, #4
 810068c:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.BaseAddress = 0x40000000;
 810068e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8100692:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_512KB;
 8100694:	2312      	movs	r3, #18
 8100696:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8100698:	2300      	movs	r3, #0
 810069a:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 810069c:	2301      	movs	r3, #1
 810069e:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 81006a0:	2300      	movs	r3, #0
 81006a2:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 81006a4:	2301      	movs	r3, #1
 81006a6:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 81006a8:	2301      	movs	r3, #1
 81006aa:	733b      	strb	r3, [r7, #12]
	MPU_InitStruct.SubRegionDisable = 0x00;
 81006ac:	2300      	movs	r3, #0
 81006ae:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RW;
 81006b0:	2301      	movs	r3, #1
 81006b2:	72fb      	strb	r3, [r7, #11]
	BSP_STM32_MPU_ConfigRegion(&MPU_InitStruct);
 81006b4:	463b      	mov	r3, r7
 81006b6:	4618      	mov	r0, r3
 81006b8:	f002 f8b0 	bl	810281c <BSP_STM32_MPU_ConfigRegion>

	// 0x05: CONFIGURING MPU FOR APP_SDRAM + VIDEO_SDRAM (0xC0000000, 64MB) - General use memory
	// 0x06: CONFIGURING MPU FOR VIDEO_SDRAM (0xC3000000, 16MB) - restricting access to last 16MB for Video Memory
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 81006bc:	2301      	movs	r3, #1
 81006be:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.Number = MPU_REGION_NUMBER5;
 81006c0:	2305      	movs	r3, #5
 81006c2:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.BaseAddress = 0xC0000000;
 81006c4:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 81006c8:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_64MB;
 81006ca:	2319      	movs	r3, #25
 81006cc:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 81006ce:	2300      	movs	r3, #0
 81006d0:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 81006d2:	2301      	movs	r3, #1
 81006d4:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 81006d6:	2300      	movs	r3, #0
 81006d8:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 81006da:	2301      	movs	r3, #1
 81006dc:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 81006de:	2301      	movs	r3, #1
 81006e0:	733b      	strb	r3, [r7, #12]
	MPU_InitStruct.SubRegionDisable = 0x00;
 81006e2:	2300      	movs	r3, #0
 81006e4:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RW;
 81006e6:	2301      	movs	r3, #1
 81006e8:	72fb      	strb	r3, [r7, #11]
	BSP_STM32_MPU_ConfigRegion(&MPU_InitStruct);
 81006ea:	463b      	mov	r3, r7
 81006ec:	4618      	mov	r0, r3
 81006ee:	f002 f895 	bl	810281c <BSP_STM32_MPU_ConfigRegion>

	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 81006f2:	2301      	movs	r3, #1
 81006f4:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.Number = MPU_REGION_NUMBER6;
 81006f6:	2306      	movs	r3, #6
 81006f8:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.BaseAddress = 0xC3000000;
 81006fa:	f04f 4343 	mov.w	r3, #3271557120	; 0xc3000000
 81006fe:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_16MB;
 8100700:	2317      	movs	r3, #23
 8100702:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8100704:	2300      	movs	r3, #0
 8100706:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 8100708:	2301      	movs	r3, #1
 810070a:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 810070c:	2300      	movs	r3, #0
 810070e:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 8100710:	2301      	movs	r3, #1
 8100712:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 8100714:	2301      	movs	r3, #1
 8100716:	733b      	strb	r3, [r7, #12]
	MPU_InitStruct.SubRegionDisable = 0x00;
 8100718:	2300      	movs	r3, #0
 810071a:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
 810071c:	2300      	movs	r3, #0
 810071e:	72fb      	strb	r3, [r7, #11]
	BSP_STM32_MPU_ConfigRegion(&MPU_InitStruct);
 8100720:	463b      	mov	r3, r7
 8100722:	4618      	mov	r0, r3
 8100724:	f002 f87a 	bl	810281c <BSP_STM32_MPU_ConfigRegion>

	// Enables the MPU
	BSP_STM32_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8100728:	2004      	movs	r0, #4
 810072a:	f002 f83f 	bl	81027ac <BSP_STM32_MPU_Enable>

	return BSP_OK;
 810072e:	2300      	movs	r3, #0

}
 8100730:	4618      	mov	r0, r3
 8100732:	3710      	adds	r7, #16
 8100734:	46bd      	mov	sp, r7
 8100736:	bd80      	pop	{r7, pc}
 8100738:	10040000 	.word	0x10040000

0810073c <BSP_STM32_Init_PeriphClocks>:


uint8_t BSP_STM32_Init_PeriphClocks() {
 810073c:	b580      	push	{r7, lr}
 810073e:	b084      	sub	sp, #16
 8100740:	af00      	add	r7, sp, #0

	// Starting GPIOs clocks
	__BSP_RCC_GPIOE_CLK_ENABLE();
 8100742:	4b1c      	ldr	r3, [pc, #112]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 8100744:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100748:	4a1a      	ldr	r2, [pc, #104]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 810074a:	f043 0310 	orr.w	r3, r3, #16
 810074e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8100752:	4b18      	ldr	r3, [pc, #96]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 8100754:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8100758:	f003 0310 	and.w	r3, r3, #16
 810075c:	60fb      	str	r3, [r7, #12]
 810075e:	68fb      	ldr	r3, [r7, #12]

    // Starting peripherals clocks - DMA1
    __BSP_RCC_DMA1_CLK_ENABLE();
 8100760:	4b14      	ldr	r3, [pc, #80]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 8100762:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8100766:	4a13      	ldr	r2, [pc, #76]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 8100768:	f043 0301 	orr.w	r3, r3, #1
 810076c:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 8100770:	4b10      	ldr	r3, [pc, #64]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 8100772:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8100776:	f003 0301 	and.w	r3, r3, #1
 810077a:	60bb      	str	r3, [r7, #8]
 810077c:	68bb      	ldr	r3, [r7, #8]

    // Starting peripherials clocks - I2S3
    if (BSP_STM32_RCC_CLKConfig_I2S3()) return BSP_ERROR;
 810077e:	f002 fee7 	bl	8103550 <BSP_STM32_RCC_CLKConfig_I2S3>
 8100782:	4603      	mov	r3, r0
 8100784:	2b00      	cmp	r3, #0
 8100786:	d001      	beq.n	810078c <BSP_STM32_Init_PeriphClocks+0x50>
 8100788:	2301      	movs	r3, #1
 810078a:	e00f      	b.n	81007ac <BSP_STM32_Init_PeriphClocks+0x70>
    __BSP_RCC_I2S3_CLK_ENABLE();
 810078c:	4b09      	ldr	r3, [pc, #36]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 810078e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8100792:	4a08      	ldr	r2, [pc, #32]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 8100794:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8100798:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 810079c:	4b05      	ldr	r3, [pc, #20]	; (81007b4 <BSP_STM32_Init_PeriphClocks+0x78>)
 810079e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 81007a2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 81007a6:	607b      	str	r3, [r7, #4]
 81007a8:	687b      	ldr	r3, [r7, #4]

	return BSP_OK;
 81007aa:	2300      	movs	r3, #0
}
 81007ac:	4618      	mov	r0, r3
 81007ae:	3710      	adds	r7, #16
 81007b0:	46bd      	mov	sp, r7
 81007b2:	bd80      	pop	{r7, pc}
 81007b4:	58024400 	.word	0x58024400

081007b8 <BSP_STM32_Init_NVIC>:


uint8_t BSP_STM32_Init_NVIC() {
 81007b8:	b580      	push	{r7, lr}
 81007ba:	b082      	sub	sp, #8
 81007bc:	af00      	add	r7, sp, #0

	uint32_t pp;
	uint32_t sp;

	/************** PRIORITY 0 *************/
	pp = 0;		sp = 0;
 81007be:	2300      	movs	r3, #0
 81007c0:	607b      	str	r3, [r7, #4]
 81007c2:	2300      	movs	r3, #0
 81007c4:	603b      	str	r3, [r7, #0]

    // Configuring NVIC for DMA1 - Stream 0 - for I2S3 TX
    BSP_STM32_NVIC_SetPriority(DMA1_Stream0_IRQn, pp, sp);
 81007c6:	683a      	ldr	r2, [r7, #0]
 81007c8:	6879      	ldr	r1, [r7, #4]
 81007ca:	200b      	movs	r0, #11
 81007cc:	f001 ffc6 	bl	810275c <BSP_STM32_NVIC_SetPriority>
    BSP_STM32_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
 81007d0:	200b      	movs	r0, #11
 81007d2:	f001 ffb4 	bl	810273e <BSP_STM32_NVIC_EnableIRQ>

    /************** PRIORITY 1 *************/
	pp = 1;		sp = 1;
 81007d6:	2301      	movs	r3, #1
 81007d8:	607b      	str	r3, [r7, #4]
 81007da:	2301      	movs	r3, #1
 81007dc:	603b      	str	r3, [r7, #0]

	// Configuring NVIC from Core CM7
	BSP_STM32_NVIC_SetPriority(CM7_SEV_IRQn, pp, sp);
 81007de:	683a      	ldr	r2, [r7, #0]
 81007e0:	6879      	ldr	r1, [r7, #4]
 81007e2:	2040      	movs	r0, #64	; 0x40
 81007e4:	f001 ffba 	bl	810275c <BSP_STM32_NVIC_SetPriority>
	BSP_STM32_NVIC_EnableIRQ(CM7_SEV_IRQn);
 81007e8:	2040      	movs	r0, #64	; 0x40
 81007ea:	f001 ffa8 	bl	810273e <BSP_STM32_NVIC_EnableIRQ>

    // Configuring NVIC for I2S3
    BSP_STM32_NVIC_SetPriority(SPI3_IRQn, pp, sp);
 81007ee:	683a      	ldr	r2, [r7, #0]
 81007f0:	6879      	ldr	r1, [r7, #4]
 81007f2:	2033      	movs	r0, #51	; 0x33
 81007f4:	f001 ffb2 	bl	810275c <BSP_STM32_NVIC_SetPriority>
    BSP_STM32_NVIC_EnableIRQ(SPI3_IRQn);
 81007f8:	2033      	movs	r0, #51	; 0x33
 81007fa:	f001 ffa0 	bl	810273e <BSP_STM32_NVIC_EnableIRQ>

    /************** PRIORITY 2 *************/
    pp = 2;		sp = 2;
 81007fe:	2302      	movs	r3, #2
 8100800:	607b      	str	r3, [r7, #4]
 8100802:	2302      	movs	r3, #2
 8100804:	603b      	str	r3, [r7, #0]


    /************** PRIORITY 3 *************/
    pp = 3;		sp = 3;
 8100806:	2303      	movs	r3, #3
 8100808:	607b      	str	r3, [r7, #4]
 810080a:	2303      	movs	r3, #3
 810080c:	603b      	str	r3, [r7, #0]


    /************** PRIORITY 4 *************/
    pp = 4;		sp = 4;
 810080e:	2304      	movs	r3, #4
 8100810:	607b      	str	r3, [r7, #4]
 8100812:	2304      	movs	r3, #4
 8100814:	603b      	str	r3, [r7, #0]


    return BSP_OK;
 8100816:	2300      	movs	r3, #0
}
 8100818:	4618      	mov	r0, r3
 810081a:	3708      	adds	r7, #8
 810081c:	46bd      	mov	sp, r7
 810081e:	bd80      	pop	{r7, pc}

08100820 <BSP_STM32_Init_GPIO>:

uint8_t BSP_STM32_Init_GPIO() {
 8100820:	b580      	push	{r7, lr}
 8100822:	b084      	sub	sp, #16
 8100824:	af02      	add	r7, sp, #8
	uint32_t Pin;

    // Configuring GPIO pins - I2S3
    // PA15 (JTDI)     ------> I2S3_WS		PC10     ------> I2S3_CK		PC12     ------> I2S3_SDO

    Pin = GPIO_PIN_15;
 8100826:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 810082a:	607b      	str	r3, [r7, #4]
    BSP_STM32_GPIO_Init(GPIOA, Pin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, GPIO_AF6_SPI3);
 810082c:	2306      	movs	r3, #6
 810082e:	9301      	str	r3, [sp, #4]
 8100830:	2300      	movs	r3, #0
 8100832:	9300      	str	r3, [sp, #0]
 8100834:	2300      	movs	r3, #0
 8100836:	2202      	movs	r2, #2
 8100838:	6879      	ldr	r1, [r7, #4]
 810083a:	4813      	ldr	r0, [pc, #76]	; (8100888 <BSP_STM32_Init_GPIO+0x68>)
 810083c:	f002 faec 	bl	8102e18 <BSP_STM32_GPIO_Init>

    Pin = GPIO_PIN_10|GPIO_PIN_12;
 8100840:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8100844:	607b      	str	r3, [r7, #4]
    BSP_STM32_GPIO_Init(GPIOC, Pin, GPIO_MODE_AF_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, GPIO_AF6_SPI3);
 8100846:	2306      	movs	r3, #6
 8100848:	9301      	str	r3, [sp, #4]
 810084a:	2300      	movs	r3, #0
 810084c:	9300      	str	r3, [sp, #0]
 810084e:	2300      	movs	r3, #0
 8100850:	2202      	movs	r2, #2
 8100852:	6879      	ldr	r1, [r7, #4]
 8100854:	480d      	ldr	r0, [pc, #52]	; (810088c <BSP_STM32_Init_GPIO+0x6c>)
 8100856:	f002 fadf 	bl	8102e18 <BSP_STM32_GPIO_Init>

    // Configuring GPIO pins - inputs and outputs
    // PE2	------> OUTPUT - AUDIO ENABLE		- DEFAULT: LOW

    BSP_STM32_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_RESET);
 810085a:	2200      	movs	r2, #0
 810085c:	2104      	movs	r1, #4
 810085e:	480c      	ldr	r0, [pc, #48]	; (8100890 <BSP_STM32_Init_GPIO+0x70>)
 8100860:	f002 fc6c 	bl	810313c <BSP_STM32_GPIO_WritePin>
    Pin = GPIO_PIN_2;
 8100864:	2304      	movs	r3, #4
 8100866:	607b      	str	r3, [r7, #4]
    BSP_STM32_GPIO_Init(GPIOE, Pin, GPIO_MODE_OUTPUT_PP, GPIO_NOPULL, GPIO_SPEED_FREQ_LOW, 0);
 8100868:	2300      	movs	r3, #0
 810086a:	9301      	str	r3, [sp, #4]
 810086c:	2300      	movs	r3, #0
 810086e:	9300      	str	r3, [sp, #0]
 8100870:	2300      	movs	r3, #0
 8100872:	2201      	movs	r2, #1
 8100874:	6879      	ldr	r1, [r7, #4]
 8100876:	4806      	ldr	r0, [pc, #24]	; (8100890 <BSP_STM32_Init_GPIO+0x70>)
 8100878:	f002 face 	bl	8102e18 <BSP_STM32_GPIO_Init>

	return BSP_OK;
 810087c:	2300      	movs	r3, #0
}
 810087e:	4618      	mov	r0, r3
 8100880:	3708      	adds	r7, #8
 8100882:	46bd      	mov	sp, r7
 8100884:	bd80      	pop	{r7, pc}
 8100886:	bf00      	nop
 8100888:	58020000 	.word	0x58020000
 810088c:	58020800 	.word	0x58020800
 8100890:	58021000 	.word	0x58021000

08100894 <BSP_TickInit>:


uint8_t BSP_TickInit(uint32_t CoreClock, uint32_t TickFreq, uint32_t TickPriority) {
 8100894:	b580      	push	{r7, lr}
 8100896:	b084      	sub	sp, #16
 8100898:	af00      	add	r7, sp, #0
 810089a:	60f8      	str	r0, [r7, #12]
 810089c:	60b9      	str	r1, [r7, #8]
 810089e:	607a      	str	r2, [r7, #4]

	if (TickFreq == 0) return BSP_ERROR;
 81008a0:	68bb      	ldr	r3, [r7, #8]
 81008a2:	2b00      	cmp	r3, #0
 81008a4:	d101      	bne.n	81008aa <BSP_TickInit+0x16>
 81008a6:	2301      	movs	r3, #1
 81008a8:	e01e      	b.n	81008e8 <BSP_TickInit+0x54>

	// Set SysTick frequency
	if (SysTick_Config(CoreClock / (1000UL / TickFreq))) return BSP_ERROR;
 81008aa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 81008ae:	68bb      	ldr	r3, [r7, #8]
 81008b0:	fbb2 f3f3 	udiv	r3, r2, r3
 81008b4:	68fa      	ldr	r2, [r7, #12]
 81008b6:	fbb2 f3f3 	udiv	r3, r2, r3
 81008ba:	4618      	mov	r0, r3
 81008bc:	f7ff fe4c 	bl	8100558 <SysTick_Config>
 81008c0:	4603      	mov	r3, r0
 81008c2:	2b00      	cmp	r3, #0
 81008c4:	d001      	beq.n	81008ca <BSP_TickInit+0x36>
 81008c6:	2301      	movs	r3, #1
 81008c8:	e00e      	b.n	81008e8 <BSP_TickInit+0x54>
	tickfrequency = TickFreq;
 81008ca:	4a09      	ldr	r2, [pc, #36]	; (81008f0 <BSP_TickInit+0x5c>)
 81008cc:	68bb      	ldr	r3, [r7, #8]
 81008ce:	6013      	str	r3, [r2, #0]

	// Set SysTick priority
	if (TickPriority > (1UL << __NVIC_PRIO_BITS)) return BSP_ERROR;
 81008d0:	687b      	ldr	r3, [r7, #4]
 81008d2:	2b10      	cmp	r3, #16
 81008d4:	d901      	bls.n	81008da <BSP_TickInit+0x46>
 81008d6:	2301      	movs	r3, #1
 81008d8:	e006      	b.n	81008e8 <BSP_TickInit+0x54>
	BSP_STM32_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 81008da:	2200      	movs	r2, #0
 81008dc:	6879      	ldr	r1, [r7, #4]
 81008de:	f04f 30ff 	mov.w	r0, #4294967295
 81008e2:	f001 ff3b 	bl	810275c <BSP_STM32_NVIC_SetPriority>

	return BSP_OK;
 81008e6:	2300      	movs	r3, #0
}
 81008e8:	4618      	mov	r0, r3
 81008ea:	3710      	adds	r7, #16
 81008ec:	46bd      	mov	sp, r7
 81008ee:	bd80      	pop	{r7, pc}
 81008f0:	10000000 	.word	0x10000000

081008f4 <BSP_IncTick>:


void BSP_IncTick(void) {
 81008f4:	b480      	push	{r7}
 81008f6:	af00      	add	r7, sp, #0

	tickvalue += tickfrequency;
 81008f8:	4b05      	ldr	r3, [pc, #20]	; (8100910 <BSP_IncTick+0x1c>)
 81008fa:	681a      	ldr	r2, [r3, #0]
 81008fc:	4b05      	ldr	r3, [pc, #20]	; (8100914 <BSP_IncTick+0x20>)
 81008fe:	681b      	ldr	r3, [r3, #0]
 8100900:	4413      	add	r3, r2
 8100902:	4a04      	ldr	r2, [pc, #16]	; (8100914 <BSP_IncTick+0x20>)
 8100904:	6013      	str	r3, [r2, #0]

}
 8100906:	bf00      	nop
 8100908:	46bd      	mov	sp, r7
 810090a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810090e:	4770      	bx	lr
 8100910:	10000000 	.word	0x10000000
 8100914:	10003440 	.word	0x10003440

08100918 <BSP_GetTick>:

uint32_t BSP_GetTick(void) {
 8100918:	b480      	push	{r7}
 810091a:	af00      	add	r7, sp, #0

	return tickvalue;
 810091c:	4b03      	ldr	r3, [pc, #12]	; (810092c <BSP_GetTick+0x14>)
 810091e:	681b      	ldr	r3, [r3, #0]
}
 8100920:	4618      	mov	r0, r3
 8100922:	46bd      	mov	sp, r7
 8100924:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100928:	4770      	bx	lr
 810092a:	bf00      	nop
 810092c:	10003440 	.word	0x10003440

08100930 <BSP_Delay>:

void BSP_Delay(uint32_t delay) {
 8100930:	b580      	push	{r7, lr}
 8100932:	b084      	sub	sp, #16
 8100934:	af00      	add	r7, sp, #0
 8100936:	6078      	str	r0, [r7, #4]

	uint32_t wait = delay + tickfrequency;
 8100938:	4b0a      	ldr	r3, [pc, #40]	; (8100964 <BSP_Delay+0x34>)
 810093a:	681b      	ldr	r3, [r3, #0]
 810093c:	687a      	ldr	r2, [r7, #4]
 810093e:	4413      	add	r3, r2
 8100940:	60fb      	str	r3, [r7, #12]
	uint32_t tickstart = BSP_GetTick();
 8100942:	f7ff ffe9 	bl	8100918 <BSP_GetTick>
 8100946:	60b8      	str	r0, [r7, #8]

	while ((BSP_GetTick() - tickstart) < wait) {}
 8100948:	bf00      	nop
 810094a:	f7ff ffe5 	bl	8100918 <BSP_GetTick>
 810094e:	4602      	mov	r2, r0
 8100950:	68bb      	ldr	r3, [r7, #8]
 8100952:	1ad3      	subs	r3, r2, r3
 8100954:	68fa      	ldr	r2, [r7, #12]
 8100956:	429a      	cmp	r2, r3
 8100958:	d8f7      	bhi.n	810094a <BSP_Delay+0x1a>

}
 810095a:	bf00      	nop
 810095c:	bf00      	nop
 810095e:	3710      	adds	r7, #16
 8100960:	46bd      	mov	sp, r7
 8100962:	bd80      	pop	{r7, pc}
 8100964:	10000000 	.word	0x10000000

08100968 <memcopy>:


///////////////////////////////////////////////////////////////////////////////////

static void memcopy( void * dest, void *source, unsigned long size )
{
 8100968:	b480      	push	{r7}
 810096a:	b089      	sub	sp, #36	; 0x24
 810096c:	af00      	add	r7, sp, #0
 810096e:	60f8      	str	r0, [r7, #12]
 8100970:	60b9      	str	r1, [r7, #8]
 8100972:	607a      	str	r2, [r7, #4]
	unsigned long i;
	unsigned char * d,*s;

	d=(unsigned char*)dest;
 8100974:	68fb      	ldr	r3, [r7, #12]
 8100976:	61bb      	str	r3, [r7, #24]
	s=(unsigned char*)source;
 8100978:	68bb      	ldr	r3, [r7, #8]
 810097a:	617b      	str	r3, [r7, #20]
	for(i=0;i<size;i++)
 810097c:	2300      	movs	r3, #0
 810097e:	61fb      	str	r3, [r7, #28]
 8100980:	e00a      	b.n	8100998 <memcopy+0x30>
	{
		d[i]=s[i];
 8100982:	697a      	ldr	r2, [r7, #20]
 8100984:	69fb      	ldr	r3, [r7, #28]
 8100986:	441a      	add	r2, r3
 8100988:	69b9      	ldr	r1, [r7, #24]
 810098a:	69fb      	ldr	r3, [r7, #28]
 810098c:	440b      	add	r3, r1
 810098e:	7812      	ldrb	r2, [r2, #0]
 8100990:	701a      	strb	r2, [r3, #0]
	for(i=0;i<size;i++)
 8100992:	69fb      	ldr	r3, [r7, #28]
 8100994:	3301      	adds	r3, #1
 8100996:	61fb      	str	r3, [r7, #28]
 8100998:	69fa      	ldr	r2, [r7, #28]
 810099a:	687b      	ldr	r3, [r7, #4]
 810099c:	429a      	cmp	r2, r3
 810099e:	d3f0      	bcc.n	8100982 <memcopy+0x1a>
	}
}
 81009a0:	bf00      	nop
 81009a2:	bf00      	nop
 81009a4:	3724      	adds	r7, #36	; 0x24
 81009a6:	46bd      	mov	sp, r7
 81009a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 81009ac:	4770      	bx	lr

081009ae <memclear>:

static void memclear( void * dest, unsigned char value, unsigned long size )
{
 81009ae:	b480      	push	{r7}
 81009b0:	b087      	sub	sp, #28
 81009b2:	af00      	add	r7, sp, #0
 81009b4:	60f8      	str	r0, [r7, #12]
 81009b6:	460b      	mov	r3, r1
 81009b8:	607a      	str	r2, [r7, #4]
 81009ba:	72fb      	strb	r3, [r7, #11]
	unsigned long i;
	unsigned char * d;

	d = (unsigned char*)dest;
 81009bc:	68fb      	ldr	r3, [r7, #12]
 81009be:	613b      	str	r3, [r7, #16]
	for(i=0;i<size;i++)
 81009c0:	2300      	movs	r3, #0
 81009c2:	617b      	str	r3, [r7, #20]
 81009c4:	e007      	b.n	81009d6 <memclear+0x28>
	{
		d[i]=value;
 81009c6:	693a      	ldr	r2, [r7, #16]
 81009c8:	697b      	ldr	r3, [r7, #20]
 81009ca:	4413      	add	r3, r2
 81009cc:	7afa      	ldrb	r2, [r7, #11]
 81009ce:	701a      	strb	r2, [r3, #0]
	for(i=0;i<size;i++)
 81009d0:	697b      	ldr	r3, [r7, #20]
 81009d2:	3301      	adds	r3, #1
 81009d4:	617b      	str	r3, [r7, #20]
 81009d6:	697a      	ldr	r2, [r7, #20]
 81009d8:	687b      	ldr	r3, [r7, #4]
 81009da:	429a      	cmp	r2, r3
 81009dc:	d3f3      	bcc.n	81009c6 <memclear+0x18>
	}
}
 81009de:	bf00      	nop
 81009e0:	bf00      	nop
 81009e2:	371c      	adds	r7, #28
 81009e4:	46bd      	mov	sp, r7
 81009e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81009ea:	4770      	bx	lr

081009ec <getnote>:

static int getnote( modcontext * mod, unsigned short period )
{
 81009ec:	b480      	push	{r7}
 81009ee:	b085      	sub	sp, #20
 81009f0:	af00      	add	r7, sp, #0
 81009f2:	6078      	str	r0, [r7, #4]
 81009f4:	460b      	mov	r3, r1
 81009f6:	807b      	strh	r3, [r7, #2]
	int i;
	const short * ptr;

	ptr = periodtable_finetune_ptr[0];
 81009f8:	4b0e      	ldr	r3, [pc, #56]	; (8100a34 <getnote+0x48>)
 81009fa:	681b      	ldr	r3, [r3, #0]
 81009fc:	60bb      	str	r3, [r7, #8]

	for(i = 0; i < MAXNOTES; i++)
 81009fe:	2300      	movs	r3, #0
 8100a00:	60fb      	str	r3, [r7, #12]
 8100a02:	e00d      	b.n	8100a20 <getnote+0x34>
	{
		if(period >= ptr[i])
 8100a04:	887b      	ldrh	r3, [r7, #2]
 8100a06:	68fa      	ldr	r2, [r7, #12]
 8100a08:	0052      	lsls	r2, r2, #1
 8100a0a:	68b9      	ldr	r1, [r7, #8]
 8100a0c:	440a      	add	r2, r1
 8100a0e:	f9b2 2000 	ldrsh.w	r2, [r2]
 8100a12:	4293      	cmp	r3, r2
 8100a14:	db01      	blt.n	8100a1a <getnote+0x2e>
		{
			return i;
 8100a16:	68fb      	ldr	r3, [r7, #12]
 8100a18:	e006      	b.n	8100a28 <getnote+0x3c>
	for(i = 0; i < MAXNOTES; i++)
 8100a1a:	68fb      	ldr	r3, [r7, #12]
 8100a1c:	3301      	adds	r3, #1
 8100a1e:	60fb      	str	r3, [r7, #12]
 8100a20:	68fb      	ldr	r3, [r7, #12]
 8100a22:	2b8f      	cmp	r3, #143	; 0x8f
 8100a24:	ddee      	ble.n	8100a04 <getnote+0x18>
		}
	}

	return MAXNOTES;
 8100a26:	2390      	movs	r3, #144	; 0x90
}
 8100a28:	4618      	mov	r0, r3
 8100a2a:	3714      	adds	r7, #20
 8100a2c:	46bd      	mov	sp, r7
 8100a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100a32:	4770      	bx	lr
 8100a34:	10000004 	.word	0x10000004

08100a38 <doFunk>:

static void doFunk(channel * cptr)
{
 8100a38:	b480      	push	{r7}
 8100a3a:	b083      	sub	sp, #12
 8100a3c:	af00      	add	r7, sp, #0
 8100a3e:	6078      	str	r0, [r7, #4]
	if(cptr->funkspeed)
 8100a40:	687b      	ldr	r3, [r7, #4]
 8100a42:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 8100a46:	2b00      	cmp	r3, #0
 8100a48:	d050      	beq.n	8100aec <doFunk+0xb4>
	{
		cptr->funkoffset += InvertLoopTable[cptr->funkspeed];
 8100a4a:	687b      	ldr	r3, [r7, #4]
 8100a4c:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
 8100a4e:	687b      	ldr	r3, [r7, #4]
 8100a50:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 8100a54:	4619      	mov	r1, r3
 8100a56:	4b28      	ldr	r3, [pc, #160]	; (8100af8 <doFunk+0xc0>)
 8100a58:	5c5b      	ldrb	r3, [r3, r1]
 8100a5a:	b29b      	uxth	r3, r3
 8100a5c:	4413      	add	r3, r2
 8100a5e:	b29a      	uxth	r2, r3
 8100a60:	687b      	ldr	r3, [r7, #4]
 8100a62:	861a      	strh	r2, [r3, #48]	; 0x30
		if( cptr->funkoffset > 128 )
 8100a64:	687b      	ldr	r3, [r7, #4]
 8100a66:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8100a68:	2b80      	cmp	r3, #128	; 0x80
 8100a6a:	d93f      	bls.n	8100aec <doFunk+0xb4>
		{
			cptr->funkoffset = 0;
 8100a6c:	687b      	ldr	r3, [r7, #4]
 8100a6e:	2200      	movs	r2, #0
 8100a70:	861a      	strh	r2, [r3, #48]	; 0x30
			if( cptr->sampdata && cptr->length && (cptr->replen > 1) )
 8100a72:	687b      	ldr	r3, [r7, #4]
 8100a74:	681b      	ldr	r3, [r3, #0]
 8100a76:	2b00      	cmp	r3, #0
 8100a78:	d038      	beq.n	8100aec <doFunk+0xb4>
 8100a7a:	687b      	ldr	r3, [r7, #4]
 8100a7c:	889b      	ldrh	r3, [r3, #4]
 8100a7e:	2b00      	cmp	r3, #0
 8100a80:	d034      	beq.n	8100aec <doFunk+0xb4>
 8100a82:	687b      	ldr	r3, [r7, #4]
 8100a84:	891b      	ldrh	r3, [r3, #8]
 8100a86:	2b01      	cmp	r3, #1
 8100a88:	d930      	bls.n	8100aec <doFunk+0xb4>
			{
				if( ( (cptr->samppos) >> 11 ) >= (unsigned long)(cptr->replen+cptr->reppnt) )
 8100a8a:	687b      	ldr	r3, [r7, #4]
 8100a8c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8100a8e:	0adb      	lsrs	r3, r3, #11
 8100a90:	687a      	ldr	r2, [r7, #4]
 8100a92:	8912      	ldrh	r2, [r2, #8]
 8100a94:	4611      	mov	r1, r2
 8100a96:	687a      	ldr	r2, [r7, #4]
 8100a98:	88d2      	ldrh	r2, [r2, #6]
 8100a9a:	440a      	add	r2, r1
 8100a9c:	4293      	cmp	r3, r2
 8100a9e:	d313      	bcc.n	8100ac8 <doFunk+0x90>
				{
					cptr->samppos = ((unsigned long)(cptr->reppnt)<<11) + (cptr->samppos % ((unsigned long)(cptr->replen+cptr->reppnt)<<11));
 8100aa0:	687b      	ldr	r3, [r7, #4]
 8100aa2:	88db      	ldrh	r3, [r3, #6]
 8100aa4:	02d9      	lsls	r1, r3, #11
 8100aa6:	687b      	ldr	r3, [r7, #4]
 8100aa8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8100aaa:	687a      	ldr	r2, [r7, #4]
 8100aac:	8912      	ldrh	r2, [r2, #8]
 8100aae:	4610      	mov	r0, r2
 8100ab0:	687a      	ldr	r2, [r7, #4]
 8100ab2:	88d2      	ldrh	r2, [r2, #6]
 8100ab4:	4402      	add	r2, r0
 8100ab6:	02d2      	lsls	r2, r2, #11
 8100ab8:	fbb3 f0f2 	udiv	r0, r3, r2
 8100abc:	fb00 f202 	mul.w	r2, r0, r2
 8100ac0:	1a9b      	subs	r3, r3, r2
 8100ac2:	18ca      	adds	r2, r1, r3
 8100ac4:	687b      	ldr	r3, [r7, #4]
 8100ac6:	639a      	str	r2, [r3, #56]	; 0x38
				}

#ifndef HXCMOD_MOD_FILE_IN_ROM
				// Note : Directly modify the sample in the mod buffer...
				// The current Invert Loop effect implementation can't be played from ROM.
				cptr->sampdata[cptr->samppos >> 10] = -1 - cptr->sampdata[cptr->samppos >> 10];
 8100ac8:	687b      	ldr	r3, [r7, #4]
 8100aca:	681a      	ldr	r2, [r3, #0]
 8100acc:	687b      	ldr	r3, [r7, #4]
 8100ace:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8100ad0:	0a9b      	lsrs	r3, r3, #10
 8100ad2:	4413      	add	r3, r2
 8100ad4:	f993 1000 	ldrsb.w	r1, [r3]
 8100ad8:	687b      	ldr	r3, [r7, #4]
 8100ada:	681a      	ldr	r2, [r3, #0]
 8100adc:	687b      	ldr	r3, [r7, #4]
 8100ade:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8100ae0:	0a9b      	lsrs	r3, r3, #10
 8100ae2:	4413      	add	r3, r2
 8100ae4:	460a      	mov	r2, r1
 8100ae6:	43d2      	mvns	r2, r2
 8100ae8:	b252      	sxtb	r2, r2
 8100aea:	701a      	strb	r2, [r3, #0]
#endif
			}
		}
	}
}
 8100aec:	bf00      	nop
 8100aee:	370c      	adds	r7, #12
 8100af0:	46bd      	mov	sp, r7
 8100af2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100af6:	4770      	bx	lr
 8100af8:	08104dcc 	.word	0x08104dcc

08100afc <worknote>:

static void worknote( note * nptr, channel * cptr,char t,modcontext * mod )
{
 8100afc:	b580      	push	{r7, lr}
 8100afe:	b08a      	sub	sp, #40	; 0x28
 8100b00:	af00      	add	r7, sp, #0
 8100b02:	60f8      	str	r0, [r7, #12]
 8100b04:	60b9      	str	r1, [r7, #8]
 8100b06:	603b      	str	r3, [r7, #0]
 8100b08:	4613      	mov	r3, r2
 8100b0a:	71fb      	strb	r3, [r7, #7]
	muchar effect_op;
	muchar effect_param,effect_param_l,effect_param_h;
	muint enable_nxt_smp;
	const short * period_table_ptr;

	sample = (nptr->sampperiod & 0xF0) | (nptr->sampeffect >> 4);
 8100b0c:	68fb      	ldr	r3, [r7, #12]
 8100b0e:	781b      	ldrb	r3, [r3, #0]
 8100b10:	b21b      	sxth	r3, r3
 8100b12:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8100b16:	b21a      	sxth	r2, r3
 8100b18:	68fb      	ldr	r3, [r7, #12]
 8100b1a:	789b      	ldrb	r3, [r3, #2]
 8100b1c:	091b      	lsrs	r3, r3, #4
 8100b1e:	b2db      	uxtb	r3, r3
 8100b20:	b21b      	sxth	r3, r3
 8100b22:	4313      	orrs	r3, r2
 8100b24:	b21b      	sxth	r3, r3
 8100b26:	843b      	strh	r3, [r7, #32]
	period = ((nptr->sampperiod & 0xF) << 8) | nptr->period;
 8100b28:	68fb      	ldr	r3, [r7, #12]
 8100b2a:	781b      	ldrb	r3, [r3, #0]
 8100b2c:	021b      	lsls	r3, r3, #8
 8100b2e:	b21b      	sxth	r3, r3
 8100b30:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8100b34:	b21a      	sxth	r2, r3
 8100b36:	68fb      	ldr	r3, [r7, #12]
 8100b38:	785b      	ldrb	r3, [r3, #1]
 8100b3a:	b21b      	sxth	r3, r3
 8100b3c:	4313      	orrs	r3, r2
 8100b3e:	b21b      	sxth	r3, r3
 8100b40:	84fb      	strh	r3, [r7, #38]	; 0x26
	effect = ((nptr->sampeffect & 0xF) << 8) | nptr->effect;
 8100b42:	68fb      	ldr	r3, [r7, #12]
 8100b44:	789b      	ldrb	r3, [r3, #2]
 8100b46:	021b      	lsls	r3, r3, #8
 8100b48:	b21b      	sxth	r3, r3
 8100b4a:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8100b4e:	b21a      	sxth	r2, r3
 8100b50:	68fb      	ldr	r3, [r7, #12]
 8100b52:	78db      	ldrb	r3, [r3, #3]
 8100b54:	b21b      	sxth	r3, r3
 8100b56:	4313      	orrs	r3, r2
 8100b58:	b21b      	sxth	r3, r3
 8100b5a:	83fb      	strh	r3, [r7, #30]
	effect_op = nptr->sampeffect & 0xF;
 8100b5c:	68fb      	ldr	r3, [r7, #12]
 8100b5e:	789b      	ldrb	r3, [r3, #2]
 8100b60:	f003 030f 	and.w	r3, r3, #15
 8100b64:	777b      	strb	r3, [r7, #29]
	effect_param = nptr->effect;
 8100b66:	68fb      	ldr	r3, [r7, #12]
 8100b68:	78db      	ldrb	r3, [r3, #3]
 8100b6a:	773b      	strb	r3, [r7, #28]
	effect_param_l = effect_param & 0x0F;
 8100b6c:	7f3b      	ldrb	r3, [r7, #28]
 8100b6e:	f003 030f 	and.w	r3, r3, #15
 8100b72:	76fb      	strb	r3, [r7, #27]
	effect_param_h = effect_param >> 4;
 8100b74:	7f3b      	ldrb	r3, [r7, #28]
 8100b76:	091b      	lsrs	r3, r3, #4
 8100b78:	76bb      	strb	r3, [r7, #26]

	enable_nxt_smp = 0;
 8100b7a:	2300      	movs	r3, #0
 8100b7c:	847b      	strh	r3, [r7, #34]	; 0x22

	operiod = cptr->period;
 8100b7e:	68bb      	ldr	r3, [r7, #8]
 8100b80:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8100b84:	833b      	strh	r3, [r7, #24]

	if ( period || sample )
 8100b86:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8100b88:	2b00      	cmp	r3, #0
 8100b8a:	d103      	bne.n	8100b94 <worknote+0x98>
 8100b8c:	8c3b      	ldrh	r3, [r7, #32]
 8100b8e:	2b00      	cmp	r3, #0
 8100b90:	f000 8207 	beq.w	8100fa2 <worknote+0x4a6>
	{
		if( sample && ( sample < 32 ) )
 8100b94:	8c3b      	ldrh	r3, [r7, #32]
 8100b96:	2b00      	cmp	r3, #0
 8100b98:	d008      	beq.n	8100bac <worknote+0xb0>
 8100b9a:	8c3b      	ldrh	r3, [r7, #32]
 8100b9c:	2b1f      	cmp	r3, #31
 8100b9e:	d805      	bhi.n	8100bac <worknote+0xb0>
		{
			cptr->sampnum = sample - 1;
 8100ba0:	8c3b      	ldrh	r3, [r7, #32]
 8100ba2:	b2db      	uxtb	r3, r3
 8100ba4:	3b01      	subs	r3, #1
 8100ba6:	b2da      	uxtb	r2, r3
 8100ba8:	68bb      	ldr	r3, [r7, #8]
 8100baa:	729a      	strb	r2, [r3, #10]
		}

		if( period || sample )
 8100bac:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8100bae:	2b00      	cmp	r3, #0
 8100bb0:	d103      	bne.n	8100bba <worknote+0xbe>
 8100bb2:	8c3b      	ldrh	r3, [r7, #32]
 8100bb4:	2b00      	cmp	r3, #0
 8100bb6:	f000 81ab 	beq.w	8100f10 <worknote+0x414>
		{
			if( period )
 8100bba:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8100bbc:	2b00      	cmp	r3, #0
 8100bbe:	f000 810f 	beq.w	8100de0 <worknote+0x2e4>
			{
				if( ( effect_op != EFFECT_TONE_PORTAMENTO ) || ( ( effect_op == EFFECT_TONE_PORTAMENTO ) && !cptr->sampdata ) )
 8100bc2:	7f7b      	ldrb	r3, [r7, #29]
 8100bc4:	2b03      	cmp	r3, #3
 8100bc6:	d108      	bne.n	8100bda <worknote+0xde>
 8100bc8:	7f7b      	ldrb	r3, [r7, #29]
 8100bca:	2b03      	cmp	r3, #3
 8100bcc:	f040 8102 	bne.w	8100dd4 <worknote+0x2d8>
 8100bd0:	68bb      	ldr	r3, [r7, #8]
 8100bd2:	681b      	ldr	r3, [r3, #0]
 8100bd4:	2b00      	cmp	r3, #0
 8100bd6:	f040 80fd 	bne.w	8100dd4 <worknote+0x2d8>
				{
					// Not a Tone Partamento effect or no sound currently played :
					if ( ( effect_op != EFFECT_EXTENDED || effect_param_h != EFFECT_E_NOTE_DELAY ) || ( ( effect_op == EFFECT_EXTENDED && effect_param_h == EFFECT_E_NOTE_DELAY ) && !effect_param_l ) )
 8100bda:	7f7b      	ldrb	r3, [r7, #29]
 8100bdc:	2b0e      	cmp	r3, #14
 8100bde:	d10c      	bne.n	8100bfa <worknote+0xfe>
 8100be0:	7ebb      	ldrb	r3, [r7, #26]
 8100be2:	2b0d      	cmp	r3, #13
 8100be4:	d109      	bne.n	8100bfa <worknote+0xfe>
 8100be6:	7f7b      	ldrb	r3, [r7, #29]
 8100be8:	2b0e      	cmp	r3, #14
 8100bea:	f040 8081 	bne.w	8100cf0 <worknote+0x1f4>
 8100bee:	7ebb      	ldrb	r3, [r7, #26]
 8100bf0:	2b0d      	cmp	r3, #13
 8100bf2:	d17d      	bne.n	8100cf0 <worknote+0x1f4>
 8100bf4:	7efb      	ldrb	r3, [r7, #27]
 8100bf6:	2b00      	cmp	r3, #0
 8100bf8:	d17a      	bne.n	8100cf0 <worknote+0x1f4>
					{
						// Immediately (re)trigger the new note
						cptr->sampdata = mod->sampledata[cptr->sampnum];
 8100bfa:	68bb      	ldr	r3, [r7, #8]
 8100bfc:	7a9b      	ldrb	r3, [r3, #10]
 8100bfe:	461a      	mov	r2, r3
 8100c00:	683b      	ldr	r3, [r7, #0]
 8100c02:	f502 7288 	add.w	r2, r2, #272	; 0x110
 8100c06:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8100c0a:	68bb      	ldr	r3, [r7, #8]
 8100c0c:	601a      	str	r2, [r3, #0]
						cptr->length = GET_BGI_W( mod->song.samples[cptr->sampnum].length );
 8100c0e:	68bb      	ldr	r3, [r7, #8]
 8100c10:	7a9b      	ldrb	r3, [r3, #10]
 8100c12:	4619      	mov	r1, r3
 8100c14:	683a      	ldr	r2, [r7, #0]
 8100c16:	460b      	mov	r3, r1
 8100c18:	011b      	lsls	r3, r3, #4
 8100c1a:	1a5b      	subs	r3, r3, r1
 8100c1c:	005b      	lsls	r3, r3, #1
 8100c1e:	4413      	add	r3, r2
 8100c20:	332a      	adds	r3, #42	; 0x2a
 8100c22:	881b      	ldrh	r3, [r3, #0]
 8100c24:	0a1b      	lsrs	r3, r3, #8
 8100c26:	b29b      	uxth	r3, r3
 8100c28:	b21a      	sxth	r2, r3
 8100c2a:	68bb      	ldr	r3, [r7, #8]
 8100c2c:	7a9b      	ldrb	r3, [r3, #10]
 8100c2e:	4618      	mov	r0, r3
 8100c30:	6839      	ldr	r1, [r7, #0]
 8100c32:	4603      	mov	r3, r0
 8100c34:	011b      	lsls	r3, r3, #4
 8100c36:	1a1b      	subs	r3, r3, r0
 8100c38:	005b      	lsls	r3, r3, #1
 8100c3a:	440b      	add	r3, r1
 8100c3c:	332a      	adds	r3, #42	; 0x2a
 8100c3e:	881b      	ldrh	r3, [r3, #0]
 8100c40:	021b      	lsls	r3, r3, #8
 8100c42:	b21b      	sxth	r3, r3
 8100c44:	4313      	orrs	r3, r2
 8100c46:	b21b      	sxth	r3, r3
 8100c48:	b29a      	uxth	r2, r3
 8100c4a:	68bb      	ldr	r3, [r7, #8]
 8100c4c:	809a      	strh	r2, [r3, #4]
						cptr->reppnt = GET_BGI_W( mod->song.samples[cptr->sampnum].reppnt );
 8100c4e:	68bb      	ldr	r3, [r7, #8]
 8100c50:	7a9b      	ldrb	r3, [r3, #10]
 8100c52:	4619      	mov	r1, r3
 8100c54:	683a      	ldr	r2, [r7, #0]
 8100c56:	460b      	mov	r3, r1
 8100c58:	011b      	lsls	r3, r3, #4
 8100c5a:	1a5b      	subs	r3, r3, r1
 8100c5c:	005b      	lsls	r3, r3, #1
 8100c5e:	4413      	add	r3, r2
 8100c60:	332e      	adds	r3, #46	; 0x2e
 8100c62:	881b      	ldrh	r3, [r3, #0]
 8100c64:	0a1b      	lsrs	r3, r3, #8
 8100c66:	b29b      	uxth	r3, r3
 8100c68:	b21a      	sxth	r2, r3
 8100c6a:	68bb      	ldr	r3, [r7, #8]
 8100c6c:	7a9b      	ldrb	r3, [r3, #10]
 8100c6e:	4618      	mov	r0, r3
 8100c70:	6839      	ldr	r1, [r7, #0]
 8100c72:	4603      	mov	r3, r0
 8100c74:	011b      	lsls	r3, r3, #4
 8100c76:	1a1b      	subs	r3, r3, r0
 8100c78:	005b      	lsls	r3, r3, #1
 8100c7a:	440b      	add	r3, r1
 8100c7c:	332e      	adds	r3, #46	; 0x2e
 8100c7e:	881b      	ldrh	r3, [r3, #0]
 8100c80:	021b      	lsls	r3, r3, #8
 8100c82:	b21b      	sxth	r3, r3
 8100c84:	4313      	orrs	r3, r2
 8100c86:	b21b      	sxth	r3, r3
 8100c88:	b29a      	uxth	r2, r3
 8100c8a:	68bb      	ldr	r3, [r7, #8]
 8100c8c:	80da      	strh	r2, [r3, #6]
						cptr->replen = GET_BGI_W( mod->song.samples[cptr->sampnum].replen );
 8100c8e:	68bb      	ldr	r3, [r7, #8]
 8100c90:	7a9b      	ldrb	r3, [r3, #10]
 8100c92:	4619      	mov	r1, r3
 8100c94:	683a      	ldr	r2, [r7, #0]
 8100c96:	460b      	mov	r3, r1
 8100c98:	011b      	lsls	r3, r3, #4
 8100c9a:	1a5b      	subs	r3, r3, r1
 8100c9c:	005b      	lsls	r3, r3, #1
 8100c9e:	4413      	add	r3, r2
 8100ca0:	3330      	adds	r3, #48	; 0x30
 8100ca2:	881b      	ldrh	r3, [r3, #0]
 8100ca4:	0a1b      	lsrs	r3, r3, #8
 8100ca6:	b29b      	uxth	r3, r3
 8100ca8:	b21a      	sxth	r2, r3
 8100caa:	68bb      	ldr	r3, [r7, #8]
 8100cac:	7a9b      	ldrb	r3, [r3, #10]
 8100cae:	4618      	mov	r0, r3
 8100cb0:	6839      	ldr	r1, [r7, #0]
 8100cb2:	4603      	mov	r3, r0
 8100cb4:	011b      	lsls	r3, r3, #4
 8100cb6:	1a1b      	subs	r3, r3, r0
 8100cb8:	005b      	lsls	r3, r3, #1
 8100cba:	440b      	add	r3, r1
 8100cbc:	3330      	adds	r3, #48	; 0x30
 8100cbe:	881b      	ldrh	r3, [r3, #0]
 8100cc0:	021b      	lsls	r3, r3, #8
 8100cc2:	b21b      	sxth	r3, r3
 8100cc4:	4313      	orrs	r3, r2
 8100cc6:	b21b      	sxth	r3, r3
 8100cc8:	b29a      	uxth	r2, r3
 8100cca:	68bb      	ldr	r3, [r7, #8]
 8100ccc:	811a      	strh	r2, [r3, #8]

						cptr->lst_sampdata = cptr->sampdata;
 8100cce:	68bb      	ldr	r3, [r7, #8]
 8100cd0:	681a      	ldr	r2, [r3, #0]
 8100cd2:	68bb      	ldr	r3, [r7, #8]
 8100cd4:	625a      	str	r2, [r3, #36]	; 0x24
						cptr->lst_length = cptr->length;
 8100cd6:	68bb      	ldr	r3, [r7, #8]
 8100cd8:	889a      	ldrh	r2, [r3, #4]
 8100cda:	68bb      	ldr	r3, [r7, #8]
 8100cdc:	851a      	strh	r2, [r3, #40]	; 0x28
						cptr->lst_reppnt = cptr->reppnt;
 8100cde:	68bb      	ldr	r3, [r7, #8]
 8100ce0:	88da      	ldrh	r2, [r3, #6]
 8100ce2:	68bb      	ldr	r3, [r7, #8]
 8100ce4:	855a      	strh	r2, [r3, #42]	; 0x2a
						cptr->lst_replen = cptr->replen;
 8100ce6:	68bb      	ldr	r3, [r7, #8]
 8100ce8:	891a      	ldrh	r2, [r3, #8]
 8100cea:	68bb      	ldr	r3, [r7, #8]
 8100cec:	859a      	strh	r2, [r3, #44]	; 0x2c
 8100cee:	e06d      	b.n	8100dcc <worknote+0x2d0>
					}
					else
					{
						cptr->dly_sampdata = mod->sampledata[cptr->sampnum];
 8100cf0:	68bb      	ldr	r3, [r7, #8]
 8100cf2:	7a9b      	ldrb	r3, [r3, #10]
 8100cf4:	461a      	mov	r2, r3
 8100cf6:	683b      	ldr	r3, [r7, #0]
 8100cf8:	f502 7288 	add.w	r2, r2, #272	; 0x110
 8100cfc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8100d00:	68bb      	ldr	r3, [r7, #8]
 8100d02:	619a      	str	r2, [r3, #24]
						cptr->dly_length = GET_BGI_W( mod->song.samples[cptr->sampnum].length );
 8100d04:	68bb      	ldr	r3, [r7, #8]
 8100d06:	7a9b      	ldrb	r3, [r3, #10]
 8100d08:	4619      	mov	r1, r3
 8100d0a:	683a      	ldr	r2, [r7, #0]
 8100d0c:	460b      	mov	r3, r1
 8100d0e:	011b      	lsls	r3, r3, #4
 8100d10:	1a5b      	subs	r3, r3, r1
 8100d12:	005b      	lsls	r3, r3, #1
 8100d14:	4413      	add	r3, r2
 8100d16:	332a      	adds	r3, #42	; 0x2a
 8100d18:	881b      	ldrh	r3, [r3, #0]
 8100d1a:	0a1b      	lsrs	r3, r3, #8
 8100d1c:	b29b      	uxth	r3, r3
 8100d1e:	b21a      	sxth	r2, r3
 8100d20:	68bb      	ldr	r3, [r7, #8]
 8100d22:	7a9b      	ldrb	r3, [r3, #10]
 8100d24:	4618      	mov	r0, r3
 8100d26:	6839      	ldr	r1, [r7, #0]
 8100d28:	4603      	mov	r3, r0
 8100d2a:	011b      	lsls	r3, r3, #4
 8100d2c:	1a1b      	subs	r3, r3, r0
 8100d2e:	005b      	lsls	r3, r3, #1
 8100d30:	440b      	add	r3, r1
 8100d32:	332a      	adds	r3, #42	; 0x2a
 8100d34:	881b      	ldrh	r3, [r3, #0]
 8100d36:	021b      	lsls	r3, r3, #8
 8100d38:	b21b      	sxth	r3, r3
 8100d3a:	4313      	orrs	r3, r2
 8100d3c:	b21b      	sxth	r3, r3
 8100d3e:	b29a      	uxth	r2, r3
 8100d40:	68bb      	ldr	r3, [r7, #8]
 8100d42:	839a      	strh	r2, [r3, #28]
						cptr->dly_reppnt = GET_BGI_W( mod->song.samples[cptr->sampnum].reppnt );
 8100d44:	68bb      	ldr	r3, [r7, #8]
 8100d46:	7a9b      	ldrb	r3, [r3, #10]
 8100d48:	4619      	mov	r1, r3
 8100d4a:	683a      	ldr	r2, [r7, #0]
 8100d4c:	460b      	mov	r3, r1
 8100d4e:	011b      	lsls	r3, r3, #4
 8100d50:	1a5b      	subs	r3, r3, r1
 8100d52:	005b      	lsls	r3, r3, #1
 8100d54:	4413      	add	r3, r2
 8100d56:	332e      	adds	r3, #46	; 0x2e
 8100d58:	881b      	ldrh	r3, [r3, #0]
 8100d5a:	0a1b      	lsrs	r3, r3, #8
 8100d5c:	b29b      	uxth	r3, r3
 8100d5e:	b21a      	sxth	r2, r3
 8100d60:	68bb      	ldr	r3, [r7, #8]
 8100d62:	7a9b      	ldrb	r3, [r3, #10]
 8100d64:	4618      	mov	r0, r3
 8100d66:	6839      	ldr	r1, [r7, #0]
 8100d68:	4603      	mov	r3, r0
 8100d6a:	011b      	lsls	r3, r3, #4
 8100d6c:	1a1b      	subs	r3, r3, r0
 8100d6e:	005b      	lsls	r3, r3, #1
 8100d70:	440b      	add	r3, r1
 8100d72:	332e      	adds	r3, #46	; 0x2e
 8100d74:	881b      	ldrh	r3, [r3, #0]
 8100d76:	021b      	lsls	r3, r3, #8
 8100d78:	b21b      	sxth	r3, r3
 8100d7a:	4313      	orrs	r3, r2
 8100d7c:	b21b      	sxth	r3, r3
 8100d7e:	b29a      	uxth	r2, r3
 8100d80:	68bb      	ldr	r3, [r7, #8]
 8100d82:	83da      	strh	r2, [r3, #30]
						cptr->dly_replen = GET_BGI_W( mod->song.samples[cptr->sampnum].replen );
 8100d84:	68bb      	ldr	r3, [r7, #8]
 8100d86:	7a9b      	ldrb	r3, [r3, #10]
 8100d88:	4619      	mov	r1, r3
 8100d8a:	683a      	ldr	r2, [r7, #0]
 8100d8c:	460b      	mov	r3, r1
 8100d8e:	011b      	lsls	r3, r3, #4
 8100d90:	1a5b      	subs	r3, r3, r1
 8100d92:	005b      	lsls	r3, r3, #1
 8100d94:	4413      	add	r3, r2
 8100d96:	3330      	adds	r3, #48	; 0x30
 8100d98:	881b      	ldrh	r3, [r3, #0]
 8100d9a:	0a1b      	lsrs	r3, r3, #8
 8100d9c:	b29b      	uxth	r3, r3
 8100d9e:	b21a      	sxth	r2, r3
 8100da0:	68bb      	ldr	r3, [r7, #8]
 8100da2:	7a9b      	ldrb	r3, [r3, #10]
 8100da4:	4618      	mov	r0, r3
 8100da6:	6839      	ldr	r1, [r7, #0]
 8100da8:	4603      	mov	r3, r0
 8100daa:	011b      	lsls	r3, r3, #4
 8100dac:	1a1b      	subs	r3, r3, r0
 8100dae:	005b      	lsls	r3, r3, #1
 8100db0:	440b      	add	r3, r1
 8100db2:	3330      	adds	r3, #48	; 0x30
 8100db4:	881b      	ldrh	r3, [r3, #0]
 8100db6:	021b      	lsls	r3, r3, #8
 8100db8:	b21b      	sxth	r3, r3
 8100dba:	4313      	orrs	r3, r2
 8100dbc:	b21b      	sxth	r3, r3
 8100dbe:	b29a      	uxth	r2, r3
 8100dc0:	68bb      	ldr	r3, [r7, #8]
 8100dc2:	841a      	strh	r2, [r3, #32]
						cptr->note_delay = effect_param_l;
 8100dc4:	68bb      	ldr	r3, [r7, #8]
 8100dc6:	7efa      	ldrb	r2, [r7, #27]
 8100dc8:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
					}
					// Cancel any delayed note...
					cptr->update_nxt_repeat = 0;
 8100dcc:	68bb      	ldr	r3, [r7, #8]
 8100dce:	2200      	movs	r2, #0
 8100dd0:	759a      	strb	r2, [r3, #22]
 8100dd2:	e007      	b.n	8100de4 <worknote+0x2e8>
				}
				else
				{
					// Partamento effect - Play the new note after the current sample.
					if( effect_op == EFFECT_TONE_PORTAMENTO )
 8100dd4:	7f7b      	ldrb	r3, [r7, #29]
 8100dd6:	2b03      	cmp	r3, #3
 8100dd8:	d104      	bne.n	8100de4 <worknote+0x2e8>
						enable_nxt_smp = 1;
 8100dda:	2301      	movs	r3, #1
 8100ddc:	847b      	strh	r3, [r7, #34]	; 0x22
 8100dde:	e001      	b.n	8100de4 <worknote+0x2e8>
				}
			}
			else // Note without period : Trigger it after the current sample.
				enable_nxt_smp = 1;
 8100de0:	2301      	movs	r3, #1
 8100de2:	847b      	strh	r3, [r7, #34]	; 0x22

			if ( enable_nxt_smp )
 8100de4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8100de6:	2b00      	cmp	r3, #0
 8100de8:	d073      	beq.n	8100ed2 <worknote+0x3d6>
			{
				// Prepare the next sample retrigger after the current one
				cptr->nxt_sampdata = mod->sampledata[cptr->sampnum];
 8100dea:	68bb      	ldr	r3, [r7, #8]
 8100dec:	7a9b      	ldrb	r3, [r3, #10]
 8100dee:	461a      	mov	r2, r3
 8100df0:	683b      	ldr	r3, [r7, #0]
 8100df2:	f502 7288 	add.w	r2, r2, #272	; 0x110
 8100df6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8100dfa:	68bb      	ldr	r3, [r7, #8]
 8100dfc:	60da      	str	r2, [r3, #12]
				cptr->nxt_length = GET_BGI_W( mod->song.samples[cptr->sampnum].length );
 8100dfe:	68bb      	ldr	r3, [r7, #8]
 8100e00:	7a9b      	ldrb	r3, [r3, #10]
 8100e02:	4619      	mov	r1, r3
 8100e04:	683a      	ldr	r2, [r7, #0]
 8100e06:	460b      	mov	r3, r1
 8100e08:	011b      	lsls	r3, r3, #4
 8100e0a:	1a5b      	subs	r3, r3, r1
 8100e0c:	005b      	lsls	r3, r3, #1
 8100e0e:	4413      	add	r3, r2
 8100e10:	332a      	adds	r3, #42	; 0x2a
 8100e12:	881b      	ldrh	r3, [r3, #0]
 8100e14:	0a1b      	lsrs	r3, r3, #8
 8100e16:	b29b      	uxth	r3, r3
 8100e18:	b21a      	sxth	r2, r3
 8100e1a:	68bb      	ldr	r3, [r7, #8]
 8100e1c:	7a9b      	ldrb	r3, [r3, #10]
 8100e1e:	4618      	mov	r0, r3
 8100e20:	6839      	ldr	r1, [r7, #0]
 8100e22:	4603      	mov	r3, r0
 8100e24:	011b      	lsls	r3, r3, #4
 8100e26:	1a1b      	subs	r3, r3, r0
 8100e28:	005b      	lsls	r3, r3, #1
 8100e2a:	440b      	add	r3, r1
 8100e2c:	332a      	adds	r3, #42	; 0x2a
 8100e2e:	881b      	ldrh	r3, [r3, #0]
 8100e30:	021b      	lsls	r3, r3, #8
 8100e32:	b21b      	sxth	r3, r3
 8100e34:	4313      	orrs	r3, r2
 8100e36:	b21b      	sxth	r3, r3
 8100e38:	b29a      	uxth	r2, r3
 8100e3a:	68bb      	ldr	r3, [r7, #8]
 8100e3c:	821a      	strh	r2, [r3, #16]
				cptr->nxt_reppnt = GET_BGI_W( mod->song.samples[cptr->sampnum].reppnt );
 8100e3e:	68bb      	ldr	r3, [r7, #8]
 8100e40:	7a9b      	ldrb	r3, [r3, #10]
 8100e42:	4619      	mov	r1, r3
 8100e44:	683a      	ldr	r2, [r7, #0]
 8100e46:	460b      	mov	r3, r1
 8100e48:	011b      	lsls	r3, r3, #4
 8100e4a:	1a5b      	subs	r3, r3, r1
 8100e4c:	005b      	lsls	r3, r3, #1
 8100e4e:	4413      	add	r3, r2
 8100e50:	332e      	adds	r3, #46	; 0x2e
 8100e52:	881b      	ldrh	r3, [r3, #0]
 8100e54:	0a1b      	lsrs	r3, r3, #8
 8100e56:	b29b      	uxth	r3, r3
 8100e58:	b21a      	sxth	r2, r3
 8100e5a:	68bb      	ldr	r3, [r7, #8]
 8100e5c:	7a9b      	ldrb	r3, [r3, #10]
 8100e5e:	4618      	mov	r0, r3
 8100e60:	6839      	ldr	r1, [r7, #0]
 8100e62:	4603      	mov	r3, r0
 8100e64:	011b      	lsls	r3, r3, #4
 8100e66:	1a1b      	subs	r3, r3, r0
 8100e68:	005b      	lsls	r3, r3, #1
 8100e6a:	440b      	add	r3, r1
 8100e6c:	332e      	adds	r3, #46	; 0x2e
 8100e6e:	881b      	ldrh	r3, [r3, #0]
 8100e70:	021b      	lsls	r3, r3, #8
 8100e72:	b21b      	sxth	r3, r3
 8100e74:	4313      	orrs	r3, r2
 8100e76:	b21b      	sxth	r3, r3
 8100e78:	b29a      	uxth	r2, r3
 8100e7a:	68bb      	ldr	r3, [r7, #8]
 8100e7c:	825a      	strh	r2, [r3, #18]
				cptr->nxt_replen = GET_BGI_W( mod->song.samples[cptr->sampnum].replen );
 8100e7e:	68bb      	ldr	r3, [r7, #8]
 8100e80:	7a9b      	ldrb	r3, [r3, #10]
 8100e82:	4619      	mov	r1, r3
 8100e84:	683a      	ldr	r2, [r7, #0]
 8100e86:	460b      	mov	r3, r1
 8100e88:	011b      	lsls	r3, r3, #4
 8100e8a:	1a5b      	subs	r3, r3, r1
 8100e8c:	005b      	lsls	r3, r3, #1
 8100e8e:	4413      	add	r3, r2
 8100e90:	3330      	adds	r3, #48	; 0x30
 8100e92:	881b      	ldrh	r3, [r3, #0]
 8100e94:	0a1b      	lsrs	r3, r3, #8
 8100e96:	b29b      	uxth	r3, r3
 8100e98:	b21a      	sxth	r2, r3
 8100e9a:	68bb      	ldr	r3, [r7, #8]
 8100e9c:	7a9b      	ldrb	r3, [r3, #10]
 8100e9e:	4618      	mov	r0, r3
 8100ea0:	6839      	ldr	r1, [r7, #0]
 8100ea2:	4603      	mov	r3, r0
 8100ea4:	011b      	lsls	r3, r3, #4
 8100ea6:	1a1b      	subs	r3, r3, r0
 8100ea8:	005b      	lsls	r3, r3, #1
 8100eaa:	440b      	add	r3, r1
 8100eac:	3330      	adds	r3, #48	; 0x30
 8100eae:	881b      	ldrh	r3, [r3, #0]
 8100eb0:	021b      	lsls	r3, r3, #8
 8100eb2:	b21b      	sxth	r3, r3
 8100eb4:	4313      	orrs	r3, r2
 8100eb6:	b21b      	sxth	r3, r3
 8100eb8:	b29a      	uxth	r2, r3
 8100eba:	68bb      	ldr	r3, [r7, #8]
 8100ebc:	829a      	strh	r2, [r3, #20]

				if(cptr->nxt_replen < 2)   // Protracker : don't play the sample if not looped...
 8100ebe:	68bb      	ldr	r3, [r7, #8]
 8100ec0:	8a9b      	ldrh	r3, [r3, #20]
 8100ec2:	2b01      	cmp	r3, #1
 8100ec4:	d802      	bhi.n	8100ecc <worknote+0x3d0>
					cptr->nxt_sampdata = 0;
 8100ec6:	68bb      	ldr	r3, [r7, #8]
 8100ec8:	2200      	movs	r2, #0
 8100eca:	60da      	str	r2, [r3, #12]

				cptr->update_nxt_repeat = 1;
 8100ecc:	68bb      	ldr	r3, [r7, #8]
 8100ece:	2201      	movs	r2, #1
 8100ed0:	759a      	strb	r2, [r3, #22]
			}

			cptr->finetune = (mod->song.samples[cptr->sampnum].finetune) & 0xF;
 8100ed2:	68bb      	ldr	r3, [r7, #8]
 8100ed4:	7a9b      	ldrb	r3, [r3, #10]
 8100ed6:	4619      	mov	r1, r3
 8100ed8:	683a      	ldr	r2, [r7, #0]
 8100eda:	460b      	mov	r3, r1
 8100edc:	011b      	lsls	r3, r3, #4
 8100ede:	1a5b      	subs	r3, r3, r1
 8100ee0:	005b      	lsls	r3, r3, #1
 8100ee2:	4413      	add	r3, r2
 8100ee4:	332c      	adds	r3, #44	; 0x2c
 8100ee6:	781b      	ldrb	r3, [r3, #0]
 8100ee8:	f003 030f 	and.w	r3, r3, #15
 8100eec:	b2da      	uxtb	r2, r3
 8100eee:	68bb      	ldr	r3, [r7, #8]
 8100ef0:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e

			if( effect_op != EFFECT_VIBRATO && effect_op != EFFECT_VOLSLIDE_VIBRATO )
 8100ef4:	7f7b      	ldrb	r3, [r7, #29]
 8100ef6:	2b04      	cmp	r3, #4
 8100ef8:	d00a      	beq.n	8100f10 <worknote+0x414>
 8100efa:	7f7b      	ldrb	r3, [r7, #29]
 8100efc:	2b06      	cmp	r3, #6
 8100efe:	d007      	beq.n	8100f10 <worknote+0x414>
			{
				cptr->vibraperiod = 0;
 8100f00:	68bb      	ldr	r3, [r7, #8]
 8100f02:	2200      	movs	r2, #0
 8100f04:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
				cptr->vibrapointeur = 0;
 8100f08:	68bb      	ldr	r3, [r7, #8]
 8100f0a:	2200      	movs	r2, #0
 8100f0c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
			}
		}

		if( (sample != 0) && ( effect_op != EFFECT_VOLSLIDE_TONEPORTA ) )
 8100f10:	8c3b      	ldrh	r3, [r7, #32]
 8100f12:	2b00      	cmp	r3, #0
 8100f14:	d014      	beq.n	8100f40 <worknote+0x444>
 8100f16:	7f7b      	ldrb	r3, [r7, #29]
 8100f18:	2b05      	cmp	r3, #5
 8100f1a:	d011      	beq.n	8100f40 <worknote+0x444>
		{
			cptr->volume = mod->song.samples[cptr->sampnum].volume;
 8100f1c:	68bb      	ldr	r3, [r7, #8]
 8100f1e:	7a9b      	ldrb	r3, [r3, #10]
 8100f20:	4619      	mov	r1, r3
 8100f22:	683a      	ldr	r2, [r7, #0]
 8100f24:	460b      	mov	r3, r1
 8100f26:	011b      	lsls	r3, r3, #4
 8100f28:	1a5b      	subs	r3, r3, r1
 8100f2a:	005b      	lsls	r3, r3, #1
 8100f2c:	4413      	add	r3, r2
 8100f2e:	332d      	adds	r3, #45	; 0x2d
 8100f30:	781a      	ldrb	r2, [r3, #0]
 8100f32:	68bb      	ldr	r3, [r7, #8]
 8100f34:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
			cptr->volumeslide = 0;
 8100f38:	68bb      	ldr	r3, [r7, #8]
 8100f3a:	2200      	movs	r2, #0
 8100f3c:	f883 205b 	strb.w	r2, [r3, #91]	; 0x5b
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
			cptr->volume_table = mod->volume_selection_table[cptr->volume];
#endif
		}

		if( ( effect_op != EFFECT_TONE_PORTAMENTO ) && ( effect_op != EFFECT_VOLSLIDE_TONEPORTA ) )
 8100f40:	7f7b      	ldrb	r3, [r7, #29]
 8100f42:	2b03      	cmp	r3, #3
 8100f44:	d008      	beq.n	8100f58 <worknote+0x45c>
 8100f46:	7f7b      	ldrb	r3, [r7, #29]
 8100f48:	2b05      	cmp	r3, #5
 8100f4a:	d005      	beq.n	8100f58 <worknote+0x45c>
		{
			if ( period != 0 )
 8100f4c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8100f4e:	2b00      	cmp	r3, #0
 8100f50:	d002      	beq.n	8100f58 <worknote+0x45c>
				cptr->samppos = 0;
 8100f52:	68bb      	ldr	r3, [r7, #8]
 8100f54:	2200      	movs	r2, #0
 8100f56:	639a      	str	r2, [r3, #56]	; 0x38
		}

		cptr->decalperiod = 0;
 8100f58:	68bb      	ldr	r3, [r7, #8]
 8100f5a:	2200      	movs	r2, #0
 8100f5c:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
		if( period )
 8100f60:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8100f62:	2b00      	cmp	r3, #0
 8100f64:	d01d      	beq.n	8100fa2 <worknote+0x4a6>
		{
			if( cptr->finetune )
 8100f66:	68bb      	ldr	r3, [r7, #8]
 8100f68:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8100f6c:	2b00      	cmp	r3, #0
 8100f6e:	d014      	beq.n	8100f9a <worknote+0x49e>
			{
				period_table_ptr = periodtable_finetune_ptr[cptr->finetune&0xF];
 8100f70:	68bb      	ldr	r3, [r7, #8]
 8100f72:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8100f76:	f003 030f 	and.w	r3, r3, #15
 8100f7a:	4aad      	ldr	r2, [pc, #692]	; (8101230 <worknote+0x734>)
 8100f7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8100f80:	617b      	str	r3, [r7, #20]
				period = period_table_ptr[getnote(mod,period)];
 8100f82:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8100f84:	4619      	mov	r1, r3
 8100f86:	6838      	ldr	r0, [r7, #0]
 8100f88:	f7ff fd30 	bl	81009ec <getnote>
 8100f8c:	4603      	mov	r3, r0
 8100f8e:	005b      	lsls	r3, r3, #1
 8100f90:	697a      	ldr	r2, [r7, #20]
 8100f92:	4413      	add	r3, r2
 8100f94:	f9b3 3000 	ldrsh.w	r3, [r3]
 8100f98:	84fb      	strh	r3, [r7, #38]	; 0x26
			}

			cptr->period = period;
 8100f9a:	68bb      	ldr	r3, [r7, #8]
 8100f9c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8100f9e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
		}
	}

	cptr->effect = 0;
 8100fa2:	68bb      	ldr	r3, [r7, #8]
 8100fa4:	2200      	movs	r2, #0
 8100fa6:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
	cptr->parameffect = 0;
 8100faa:	68bb      	ldr	r3, [r7, #8]
 8100fac:	2200      	movs	r2, #0
 8100fae:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	cptr->effect_code = effect;
 8100fb2:	68bb      	ldr	r3, [r7, #8]
 8100fb4:	8bfa      	ldrh	r2, [r7, #30]
 8100fb6:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46

	if(effect_op == 0xE)
		mod->effects_event_counts[ 0x10 + effect_param_h ]++;
#endif

	switch ( effect_op )
 8100fba:	7f7b      	ldrb	r3, [r7, #29]
 8100fbc:	2b0f      	cmp	r3, #15
 8100fbe:	f200 82e4 	bhi.w	810158a <worknote+0xa8e>
 8100fc2:	a201      	add	r2, pc, #4	; (adr r2, 8100fc8 <worknote+0x4cc>)
 8100fc4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8100fc8:	08101009 	.word	0x08101009
 8100fcc:	081010c1 	.word	0x081010c1
 8100fd0:	081010d3 	.word	0x081010d3
 8100fd4:	081010e5 	.word	0x081010e5
 8100fd8:	08101119 	.word	0x08101119
 8100fdc:	0810116f 	.word	0x0810116f
 8100fe0:	081011a1 	.word	0x081011a1
 8100fe4:	0810158b 	.word	0x0810158b
 8100fe8:	0810158b 	.word	0x0810158b
 8100fec:	081011bb 	.word	0x081011bb
 8100ff0:	081011e7 	.word	0x081011e7
 8100ff4:	081011f9 	.word	0x081011f9
 8100ff8:	08101235 	.word	0x08101235
 8100ffc:	08101253 	.word	0x08101253
 8101000:	081012db 	.word	0x081012db
 8101004:	08101535 	.word	0x08101535
			used to simulate chords, but this doesn't work too well. They are
			also used to produce heavy vibrato. A major chord is when x=4, y=7.
			A minor chord is when x=3, y=7.
			*/

			if( effect_param )
 8101008:	7f3b      	ldrb	r3, [r7, #28]
 810100a:	2b00      	cmp	r3, #0
 810100c:	f000 82bf 	beq.w	810158e <worknote+0xa92>
			{
				cptr->effect = EFFECT_ARPEGGIO;
 8101010:	68bb      	ldr	r3, [r7, #8]
 8101012:	2200      	movs	r2, #0
 8101014:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
				cptr->parameffect = effect_param;
 8101018:	68bb      	ldr	r3, [r7, #8]
 810101a:	7f3a      	ldrb	r2, [r7, #28]
 810101c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

				cptr->ArpIndex = 0;
 8101020:	68bb      	ldr	r3, [r7, #8]
 8101022:	2200      	movs	r2, #0
 8101024:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a

				curnote = getnote(mod,cptr->period);
 8101028:	68bb      	ldr	r3, [r7, #8]
 810102a:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 810102e:	4619      	mov	r1, r3
 8101030:	6838      	ldr	r0, [r7, #0]
 8101032:	f7ff fcdb 	bl	81009ec <getnote>
 8101036:	4603      	mov	r3, r0
 8101038:	827b      	strh	r3, [r7, #18]

				cptr->Arpperiods[0] = cptr->period;
 810103a:	68bb      	ldr	r3, [r7, #8]
 810103c:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101040:	b21a      	sxth	r2, r3
 8101042:	68bb      	ldr	r3, [r7, #8]
 8101044:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

				period_table_ptr = periodtable_finetune_ptr[cptr->finetune&0xF];
 8101048:	68bb      	ldr	r3, [r7, #8]
 810104a:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 810104e:	f003 030f 	and.w	r3, r3, #15
 8101052:	4a77      	ldr	r2, [pc, #476]	; (8101230 <worknote+0x734>)
 8101054:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8101058:	617b      	str	r3, [r7, #20]

				arpnote = curnote + (((cptr->parameffect>>4)&0xF));
 810105a:	68bb      	ldr	r3, [r7, #8]
 810105c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8101060:	091b      	lsrs	r3, r3, #4
 8101062:	b2db      	uxtb	r3, r3
 8101064:	b29b      	uxth	r3, r3
 8101066:	f003 030f 	and.w	r3, r3, #15
 810106a:	b29a      	uxth	r2, r3
 810106c:	8a7b      	ldrh	r3, [r7, #18]
 810106e:	4413      	add	r3, r2
 8101070:	84bb      	strh	r3, [r7, #36]	; 0x24
				if( arpnote >= MAXNOTES )
 8101072:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8101074:	2b8f      	cmp	r3, #143	; 0x8f
 8101076:	d901      	bls.n	810107c <worknote+0x580>
					arpnote = (MAXNOTES) - 1;
 8101078:	238f      	movs	r3, #143	; 0x8f
 810107a:	84bb      	strh	r3, [r7, #36]	; 0x24

				cptr->Arpperiods[1] = period_table_ptr[arpnote];
 810107c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 810107e:	005b      	lsls	r3, r3, #1
 8101080:	697a      	ldr	r2, [r7, #20]
 8101082:	4413      	add	r3, r2
 8101084:	f9b3 2000 	ldrsh.w	r2, [r3]
 8101088:	68bb      	ldr	r3, [r7, #8]
 810108a:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

				arpnote = curnote + (((cptr->parameffect)&0xF));
 810108e:	68bb      	ldr	r3, [r7, #8]
 8101090:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8101094:	b29b      	uxth	r3, r3
 8101096:	f003 030f 	and.w	r3, r3, #15
 810109a:	b29a      	uxth	r2, r3
 810109c:	8a7b      	ldrh	r3, [r7, #18]
 810109e:	4413      	add	r3, r2
 81010a0:	84bb      	strh	r3, [r7, #36]	; 0x24
				if( arpnote >= MAXNOTES )
 81010a2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 81010a4:	2b8f      	cmp	r3, #143	; 0x8f
 81010a6:	d901      	bls.n	81010ac <worknote+0x5b0>
					arpnote = (MAXNOTES) - 1;
 81010a8:	238f      	movs	r3, #143	; 0x8f
 81010aa:	84bb      	strh	r3, [r7, #36]	; 0x24

				cptr->Arpperiods[2] = period_table_ptr[arpnote];
 81010ac:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 81010ae:	005b      	lsls	r3, r3, #1
 81010b0:	697a      	ldr	r2, [r7, #20]
 81010b2:	4413      	add	r3, r2
 81010b4:	f9b3 2000 	ldrsh.w	r2, [r3]
 81010b8:	68bb      	ldr	r3, [r7, #8]
 81010ba:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
			}
		break;
 81010be:	e266      	b.n	810158e <worknote+0xa92>
			will be z - (x*16 + y)*(ticks - 1). As the slide rate depends on
			the speed, changing the speed will change the slide. You cannot
			slide beyond the note B3 (period 113).
			*/

			cptr->effect = EFFECT_PORTAMENTO_UP;
 81010c0:	68bb      	ldr	r3, [r7, #8]
 81010c2:	2201      	movs	r2, #1
 81010c4:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
			cptr->parameffect = effect_param;
 81010c8:	68bb      	ldr	r3, [r7, #8]
 81010ca:	7f3a      	ldrb	r2, [r7, #28]
 81010cc:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		break;
 81010d0:	e26a      	b.n	81015a8 <worknote+0xaac>
			sample by x*16+y after each tick in the division". Similar to [1],
			but lowers the pitch. You cannot slide beyond the note C1 (period
			856).
			*/

			cptr->effect = EFFECT_PORTAMENTO_DOWN;
 81010d2:	68bb      	ldr	r3, [r7, #8]
 81010d4:	2202      	movs	r2, #2
 81010d6:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
			cptr->parameffect = effect_param;
 81010da:	68bb      	ldr	r3, [r7, #8]
 81010dc:	7f3a      	ldrb	r2, [r7, #28]
 81010de:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		break;
 81010e2:	e261      	b.n	81015a8 <worknote+0xaac>
			note is similar to effects [1] and [2], but the slide will not go
			beyond the given period, and the direction is implied by that
			period. If x and y are both 0, then the old slide will continue.
			*/

			cptr->effect = EFFECT_TONE_PORTAMENTO;
 81010e4:	68bb      	ldr	r3, [r7, #8]
 81010e6:	2203      	movs	r2, #3
 81010e8:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
			if( effect_param != 0 )
 81010ec:	7f3b      	ldrb	r3, [r7, #28]
 81010ee:	2b00      	cmp	r3, #0
 81010f0:	d004      	beq.n	81010fc <worknote+0x600>
			{
				cptr->portaspeed = (short)( effect_param );
 81010f2:	7f3b      	ldrb	r3, [r7, #28]
 81010f4:	b21a      	sxth	r2, r3
 81010f6:	68bb      	ldr	r3, [r7, #8]
 81010f8:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
			}

			if(period!=0)
 81010fc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 81010fe:	2b00      	cmp	r3, #0
 8101100:	f000 8247 	beq.w	8101592 <worknote+0xa96>
			{
				cptr->portaperiod = period;
 8101104:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8101108:	68bb      	ldr	r3, [r7, #8]
 810110a:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
				cptr->period = operiod;
 810110e:	68bb      	ldr	r3, [r7, #8]
 8101110:	8b3a      	ldrh	r2, [r7, #24]
 8101112:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
			}
		break;
 8101116:	e23c      	b.n	8101592 <worknote+0xa96>
			effect [14][4]. By placing vibrato effects on consecutive
			divisions, the vibrato effect can be maintained. If either x or y
			are 0, then the old vibrato values will be used.
			*/

			cptr->effect = EFFECT_VIBRATO;
 8101118:	68bb      	ldr	r3, [r7, #8]
 810111a:	2204      	movs	r2, #4
 810111c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
			if( effect_param_l != 0 ) // Depth continue or change ?
 8101120:	7efb      	ldrb	r3, [r7, #27]
 8101122:	2b00      	cmp	r3, #0
 8101124:	d00e      	beq.n	8101144 <worknote+0x648>
				cptr->vibraparam = ( cptr->vibraparam & 0xF0 ) | effect_param_l;
 8101126:	68bb      	ldr	r3, [r7, #8]
 8101128:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 810112c:	b25b      	sxtb	r3, r3
 810112e:	f023 030f 	bic.w	r3, r3, #15
 8101132:	b25a      	sxtb	r2, r3
 8101134:	f997 301b 	ldrsb.w	r3, [r7, #27]
 8101138:	4313      	orrs	r3, r2
 810113a:	b25b      	sxtb	r3, r3
 810113c:	b2da      	uxtb	r2, r3
 810113e:	68bb      	ldr	r3, [r7, #8]
 8101140:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
			if( effect_param_h != 0 ) // Speed continue or change ?
 8101144:	7ebb      	ldrb	r3, [r7, #26]
 8101146:	2b00      	cmp	r3, #0
 8101148:	f000 8225 	beq.w	8101596 <worknote+0xa9a>
				cptr->vibraparam = ( cptr->vibraparam & 0x0F ) | ( effect_param_h << 4 );
 810114c:	68bb      	ldr	r3, [r7, #8]
 810114e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8101152:	b25b      	sxtb	r3, r3
 8101154:	f003 030f 	and.w	r3, r3, #15
 8101158:	b25a      	sxtb	r2, r3
 810115a:	7ebb      	ldrb	r3, [r7, #26]
 810115c:	011b      	lsls	r3, r3, #4
 810115e:	b25b      	sxtb	r3, r3
 8101160:	4313      	orrs	r3, r2
 8101162:	b25b      	sxtb	r3, r3
 8101164:	b2da      	uxtb	r2, r3
 8101166:	68bb      	ldr	r3, [r7, #8]
 8101168:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

		break;
 810116c:	e213      	b.n	8101596 <worknote+0xa9a>
			non-zero. You cannot slide outside the volume range 0..64. The
			period-length in this channel's division is a parameter to this
			effect, and hence is not played.
			*/

			if( period != 0 )
 810116e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8101170:	2b00      	cmp	r3, #0
 8101172:	d008      	beq.n	8101186 <worknote+0x68a>
			{
				cptr->portaperiod = period;
 8101174:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8101178:	68bb      	ldr	r3, [r7, #8]
 810117a:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
				cptr->period = operiod;
 810117e:	68bb      	ldr	r3, [r7, #8]
 8101180:	8b3a      	ldrh	r2, [r7, #24]
 8101182:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
			}

			cptr->effect = EFFECT_VOLSLIDE_TONEPORTA;
 8101186:	68bb      	ldr	r3, [r7, #8]
 8101188:	2205      	movs	r2, #5
 810118a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
			if( effect_param != 0 )
 810118e:	7f3b      	ldrb	r3, [r7, #28]
 8101190:	2b00      	cmp	r3, #0
 8101192:	f000 8202 	beq.w	810159a <worknote+0xa9e>
				cptr->volumeslide = effect_param;
 8101196:	68bb      	ldr	r3, [r7, #8]
 8101198:	7f3a      	ldrb	r2, [r7, #28]
 810119a:	f883 205b 	strb.w	r2, [r3, #91]	; 0x5b

		break;
 810119e:	e1fc      	b.n	810159a <worknote+0xa9e>
			slide the volume down y*(ticks - 1), at the same time as continuing
			the last 'Vibrato'". It is illegal for both x and y to be non-zero.
			You cannot slide outside the volume range 0..64.
			*/

			cptr->effect = EFFECT_VOLSLIDE_VIBRATO;
 81011a0:	68bb      	ldr	r3, [r7, #8]
 81011a2:	2206      	movs	r2, #6
 81011a4:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
			if( effect_param != 0 )
 81011a8:	7f3b      	ldrb	r3, [r7, #28]
 81011aa:	2b00      	cmp	r3, #0
 81011ac:	f000 81f7 	beq.w	810159e <worknote+0xaa2>
				cptr->volumeslide = effect_param;
 81011b0:	68bb      	ldr	r3, [r7, #8]
 81011b2:	7f3a      	ldrb	r2, [r7, #28]
 81011b4:	f883 205b 	strb.w	r2, [r3, #91]	; 0x5b
		break;
 81011b8:	e1f1      	b.n	810159e <worknote+0xaa2>
			still playing on this channel, it should be retriggered to the new
			offset using the current volume.
			If xy is 00, the previous value is used.
			*/

			cptr->samppos = ( ( ((muint)effect_param_h) << 12) + ( (((muint)effect_param_l) << 8) ) ) << 10;
 81011ba:	7ebb      	ldrb	r3, [r7, #26]
 81011bc:	031a      	lsls	r2, r3, #12
 81011be:	7efb      	ldrb	r3, [r7, #27]
 81011c0:	021b      	lsls	r3, r3, #8
 81011c2:	4413      	add	r3, r2
 81011c4:	029b      	lsls	r3, r3, #10
 81011c6:	461a      	mov	r2, r3
 81011c8:	68bb      	ldr	r3, [r7, #8]
 81011ca:	639a      	str	r2, [r3, #56]	; 0x38

			if(!cptr->samppos)
 81011cc:	68bb      	ldr	r3, [r7, #8]
 81011ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 81011d0:	2b00      	cmp	r3, #0
 81011d2:	d103      	bne.n	81011dc <worknote+0x6e0>
				cptr->samppos = cptr->last_set_offset;
 81011d4:	68bb      	ldr	r3, [r7, #8]
 81011d6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 81011d8:	68bb      	ldr	r3, [r7, #8]
 81011da:	639a      	str	r2, [r3, #56]	; 0x38

			cptr->last_set_offset = cptr->samppos;
 81011dc:	68bb      	ldr	r3, [r7, #8]
 81011de:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 81011e0:	68bb      	ldr	r3, [r7, #8]
 81011e2:	649a      	str	r2, [r3, #72]	; 0x48
		break;
 81011e4:	e1e0      	b.n	81015a8 <worknote+0xaac>
			slide the volume down y*(ticks - 1)". If both x and y are non-zero,
			then the y value is ignored (assumed to be 0). You cannot slide
			outside the volume range 0..64.
			*/

			cptr->effect = EFFECT_VOLUME_SLIDE;
 81011e6:	68bb      	ldr	r3, [r7, #8]
 81011e8:	220a      	movs	r2, #10
 81011ea:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
			cptr->volumeslide = effect_param;
 81011ee:	68bb      	ldr	r3, [r7, #8]
 81011f0:	7f3a      	ldrb	r2, [r7, #28]
 81011f2:	f883 205b 	strb.w	r2, [r3, #91]	; 0x5b
		break;
 81011f6:	e1d7      	b.n	81015a8 <worknote+0xaac>
			continue the song at song-position x*16+y". This shifts the
			'pattern-cursor' in the pattern table (see above). Legal values for
			x*16+y are from 0 to 127.
			*/

			mod->tablepos = effect_param;
 81011f8:	7f3b      	ldrb	r3, [r7, #28]
 81011fa:	b29a      	uxth	r2, r3
 81011fc:	683b      	ldr	r3, [r7, #0]
 81011fe:	f8a3 26c0 	strh.w	r2, [r3, #1728]	; 0x6c0
			if(mod->tablepos >= mod->song.length)
 8101202:	683b      	ldr	r3, [r7, #0]
 8101204:	f8b3 26c0 	ldrh.w	r2, [r3, #1728]	; 0x6c0
 8101208:	683b      	ldr	r3, [r7, #0]
 810120a:	f893 33b6 	ldrb.w	r3, [r3, #950]	; 0x3b6
 810120e:	b29b      	uxth	r3, r3
 8101210:	429a      	cmp	r2, r3
 8101212:	d303      	bcc.n	810121c <worknote+0x720>
				mod->tablepos = 0;
 8101214:	683b      	ldr	r3, [r7, #0]
 8101216:	2200      	movs	r2, #0
 8101218:	f8a3 26c0 	strh.w	r2, [r3, #1728]	; 0x6c0
			mod->patternpos = 0;
 810121c:	683b      	ldr	r3, [r7, #0]
 810121e:	2200      	movs	r2, #0
 8101220:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2
			mod->jump_loop_effect = 1;
 8101224:	683b      	ldr	r3, [r7, #0]
 8101226:	2201      	movs	r2, #1
 8101228:	f883 26c6 	strb.w	r2, [r3, #1734]	; 0x6c6

		break;
 810122c:	e1bc      	b.n	81015a8 <worknote+0xaac>
 810122e:	bf00      	nop
 8101230:	10000004 	.word	0x10000004
			[12]: Set volume
			Where [12][x][y] means "set current sample's volume to x*16+y".
			Legal volumes are 0..64.
			*/

			cptr->volume = effect_param;
 8101234:	68bb      	ldr	r3, [r7, #8]
 8101236:	7f3a      	ldrb	r2, [r7, #28]
 8101238:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

			if(cptr->volume > 64)
 810123c:	68bb      	ldr	r3, [r7, #8]
 810123e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8101242:	2b40      	cmp	r3, #64	; 0x40
 8101244:	f240 81ad 	bls.w	81015a2 <worknote+0xaa6>
				cptr->volume = 64;
 8101248:	68bb      	ldr	r3, [r7, #8]
 810124a:	2240      	movs	r2, #64	; 0x40
 810124c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
			cptr->volume_table = mod->volume_selection_table[cptr->volume];
#endif
		break;
 8101250:	e1a7      	b.n	81015a2 <worknote+0xaa6>
			continue the song at the next pattern at division x*10+y" (the 10
			is not a typo). Legal divisions are from 0 to 63 (note Protracker
			exception above).
			*/

			mod->patternpos = ( ((muint)(effect_param_h) * 10) + effect_param_l );
 8101252:	7ebb      	ldrb	r3, [r7, #26]
 8101254:	b29b      	uxth	r3, r3
 8101256:	461a      	mov	r2, r3
 8101258:	0092      	lsls	r2, r2, #2
 810125a:	4413      	add	r3, r2
 810125c:	005b      	lsls	r3, r3, #1
 810125e:	b29a      	uxth	r2, r3
 8101260:	7efb      	ldrb	r3, [r7, #27]
 8101262:	b29b      	uxth	r3, r3
 8101264:	4413      	add	r3, r2
 8101266:	b29a      	uxth	r2, r3
 8101268:	683b      	ldr	r3, [r7, #0]
 810126a:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2

			if(mod->patternpos >= 64)
 810126e:	683b      	ldr	r3, [r7, #0]
 8101270:	f8b3 36c2 	ldrh.w	r3, [r3, #1730]	; 0x6c2
 8101274:	2b3f      	cmp	r3, #63	; 0x3f
 8101276:	d903      	bls.n	8101280 <worknote+0x784>
				mod->patternpos = 63;
 8101278:	683b      	ldr	r3, [r7, #0]
 810127a:	223f      	movs	r2, #63	; 0x3f
 810127c:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2

			mod->patternpos *= mod->number_of_channels;
 8101280:	683b      	ldr	r3, [r7, #0]
 8101282:	f8b3 26c2 	ldrh.w	r2, [r3, #1730]	; 0x6c2
 8101286:	683b      	ldr	r3, [r7, #0]
 8101288:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810128c:	f8b3 3360 	ldrh.w	r3, [r3, #864]	; 0x360
 8101290:	fb12 f303 	smulbb	r3, r2, r3
 8101294:	b29a      	uxth	r2, r3
 8101296:	683b      	ldr	r3, [r7, #0]
 8101298:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2

			if(!mod->jump_loop_effect)
 810129c:	683b      	ldr	r3, [r7, #0]
 810129e:	f893 36c6 	ldrb.w	r3, [r3, #1734]	; 0x6c6
 81012a2:	2b00      	cmp	r3, #0
 81012a4:	d114      	bne.n	81012d0 <worknote+0x7d4>
			{
				mod->tablepos++;
 81012a6:	683b      	ldr	r3, [r7, #0]
 81012a8:	f8b3 36c0 	ldrh.w	r3, [r3, #1728]	; 0x6c0
 81012ac:	3301      	adds	r3, #1
 81012ae:	b29a      	uxth	r2, r3
 81012b0:	683b      	ldr	r3, [r7, #0]
 81012b2:	f8a3 26c0 	strh.w	r2, [r3, #1728]	; 0x6c0
				if(mod->tablepos >= mod->song.length)
 81012b6:	683b      	ldr	r3, [r7, #0]
 81012b8:	f8b3 26c0 	ldrh.w	r2, [r3, #1728]	; 0x6c0
 81012bc:	683b      	ldr	r3, [r7, #0]
 81012be:	f893 33b6 	ldrb.w	r3, [r3, #950]	; 0x3b6
 81012c2:	b29b      	uxth	r3, r3
 81012c4:	429a      	cmp	r2, r3
 81012c6:	d303      	bcc.n	81012d0 <worknote+0x7d4>
					mod->tablepos = 0;
 81012c8:	683b      	ldr	r3, [r7, #0]
 81012ca:	2200      	movs	r2, #0
 81012cc:	f8a3 26c0 	strh.w	r2, [r3, #1728]	; 0x6c0
			}

			mod->jump_loop_effect = 1;
 81012d0:	683b      	ldr	r3, [r7, #0]
 81012d2:	2201      	movs	r2, #1
 81012d4:	f883 26c6 	strb.w	r2, [r3, #1734]	; 0x6c6
		break;
 81012d8:	e166      	b.n	81015a8 <worknote+0xaac>

		case EFFECT_EXTENDED:
			switch( effect_param_h )
 81012da:	7ebb      	ldrb	r3, [r7, #26]
 81012dc:	3b01      	subs	r3, #1
 81012de:	2b0e      	cmp	r3, #14
 81012e0:	f200 8118 	bhi.w	8101514 <worknote+0xa18>
 81012e4:	a201      	add	r2, pc, #4	; (adr r2, 81012ec <worknote+0x7f0>)
 81012e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81012ea:	bf00      	nop
 81012ec:	08101329 	.word	0x08101329
 81012f0:	08101353 	.word	0x08101353
 81012f4:	08101381 	.word	0x08101381
 81012f8:	08101515 	.word	0x08101515
 81012fc:	081013db 	.word	0x081013db
 8101300:	0810141f 	.word	0x0810141f
 8101304:	08101515 	.word	0x08101515
 8101308:	08101515 	.word	0x08101515
 810130c:	081014a7 	.word	0x081014a7
 8101310:	0810138b 	.word	0x0810138b
 8101314:	081013b3 	.word	0x081013b3
 8101318:	081014cf 	.word	0x081014cf
 810131c:	081014f3 	.word	0x081014f3
 8101320:	0810149b 	.word	0x0810149b
 8101324:	08101505 	.word	0x08101505
					by x". The incrementing takes place at the beginning of the
					division, and hence there is no actual sliding. You cannot slide
					beyond the note B3 (period 113).
					*/

					cptr->period -= effect_param_l;
 8101328:	68bb      	ldr	r3, [r7, #8]
 810132a:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 810132e:	7efb      	ldrb	r3, [r7, #27]
 8101330:	b29b      	uxth	r3, r3
 8101332:	1ad3      	subs	r3, r2, r3
 8101334:	b29a      	uxth	r2, r3
 8101336:	68bb      	ldr	r3, [r7, #8]
 8101338:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
					if( cptr->period < 113 )
 810133c:	68bb      	ldr	r3, [r7, #8]
 810133e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101342:	2b70      	cmp	r3, #112	; 0x70
 8101344:	f200 80e8 	bhi.w	8101518 <worknote+0xa1c>
						cptr->period = 113;
 8101348:	68bb      	ldr	r3, [r7, #8]
 810134a:	2271      	movs	r2, #113	; 0x71
 810134c:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
				break;
 8101350:	e0e2      	b.n	8101518 <worknote+0xa1c>
					Where [14][2][x] means "increment the period of the current sample
					by x". Similar to [14][1] but shifts the pitch down. You cannot
					slide beyond the note C1 (period 856).
					*/

					cptr->period += effect_param_l;
 8101352:	68bb      	ldr	r3, [r7, #8]
 8101354:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8101358:	7efb      	ldrb	r3, [r7, #27]
 810135a:	b29b      	uxth	r3, r3
 810135c:	4413      	add	r3, r2
 810135e:	b29a      	uxth	r2, r3
 8101360:	68bb      	ldr	r3, [r7, #8]
 8101362:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
					if( cptr->period > 856 )
 8101366:	68bb      	ldr	r3, [r7, #8]
 8101368:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 810136c:	f5b3 7f56 	cmp.w	r3, #856	; 0x358
 8101370:	f240 80d4 	bls.w	810151c <worknote+0xa20>
						cptr->period = 856;
 8101374:	68bb      	ldr	r3, [r7, #8]
 8101376:	f44f 7256 	mov.w	r2, #856	; 0x358
 810137a:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
				break;
 810137e:	e0cd      	b.n	810151c <worknote+0xa20>
					Used in conjunction with [3] ('Slide to note'). If glissando is on,
					then 'Slide to note' will slide in semitones, otherwise will
					perform the default smooth slide.
					*/

					cptr->glissando = effect_param_l;
 8101380:	7efb      	ldrb	r3, [r7, #27]
 8101382:	b21a      	sxth	r2, r3
 8101384:	68bb      	ldr	r3, [r7, #8]
 8101386:	869a      	strh	r2, [r3, #52]	; 0x34
				break;
 8101388:	e0d3      	b.n	8101532 <worknote+0xa36>
					by x". The incrementing takes place at the beginning of the
					division, and hence there is no sliding. You cannot slide beyond
					volume 64.
					*/

					cptr->volume += effect_param_l;
 810138a:	68bb      	ldr	r3, [r7, #8]
 810138c:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 8101390:	7efb      	ldrb	r3, [r7, #27]
 8101392:	4413      	add	r3, r2
 8101394:	b2da      	uxtb	r2, r3
 8101396:	68bb      	ldr	r3, [r7, #8]
 8101398:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
					if( cptr->volume > 64 )
 810139c:	68bb      	ldr	r3, [r7, #8]
 810139e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 81013a2:	2b40      	cmp	r3, #64	; 0x40
 81013a4:	f240 80bc 	bls.w	8101520 <worknote+0xa24>
						cptr->volume = 64;
 81013a8:	68bb      	ldr	r3, [r7, #8]
 81013aa:	2240      	movs	r2, #64	; 0x40
 81013ac:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
					cptr->volume_table = mod->volume_selection_table[cptr->volume];
#endif
				break;
 81013b0:	e0b6      	b.n	8101520 <worknote+0xa24>
					Where [14][11][x] means "decrement the volume of the current sample
					by x". Similar to [14][10] but lowers volume. You cannot slide
					beyond volume 0.
					*/

					cptr->volume -= effect_param_l;
 81013b2:	68bb      	ldr	r3, [r7, #8]
 81013b4:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 81013b8:	7efb      	ldrb	r3, [r7, #27]
 81013ba:	1ad3      	subs	r3, r2, r3
 81013bc:	b2da      	uxtb	r2, r3
 81013be:	68bb      	ldr	r3, [r7, #8]
 81013c0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
					if( cptr->volume > 200 )
 81013c4:	68bb      	ldr	r3, [r7, #8]
 81013c6:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 81013ca:	2bc8      	cmp	r3, #200	; 0xc8
 81013cc:	f240 80aa 	bls.w	8101524 <worknote+0xa28>
						cptr->volume = 0;
 81013d0:	68bb      	ldr	r3, [r7, #8]
 81013d2:	2200      	movs	r2, #0
 81013d4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
					cptr->volume_table = mod->volume_selection_table[cptr->volume];
#endif
				break;
 81013d8:	e0a4      	b.n	8101524 <worknote+0xa28>
					sample to the signed nibble x". x has legal values of 0..15,
					corresponding to signed nibbles 0..7,-8..-1 (see start of text for
					more info on finetune values).
					*/

					cptr->finetune = effect_param_l;
 81013da:	68bb      	ldr	r3, [r7, #8]
 81013dc:	7efa      	ldrb	r2, [r7, #27]
 81013de:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e

					if( period )
 81013e2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 81013e4:	2b00      	cmp	r3, #0
 81013e6:	f000 809f 	beq.w	8101528 <worknote+0xa2c>
					{
						period_table_ptr = periodtable_finetune_ptr[cptr->finetune&0xF];
 81013ea:	68bb      	ldr	r3, [r7, #8]
 81013ec:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 81013f0:	f003 030f 	and.w	r3, r3, #15
 81013f4:	4a6e      	ldr	r2, [pc, #440]	; (81015b0 <worknote+0xab4>)
 81013f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 81013fa:	617b      	str	r3, [r7, #20]
						period = period_table_ptr[getnote(mod,period)];
 81013fc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 81013fe:	4619      	mov	r1, r3
 8101400:	6838      	ldr	r0, [r7, #0]
 8101402:	f7ff faf3 	bl	81009ec <getnote>
 8101406:	4603      	mov	r3, r0
 8101408:	005b      	lsls	r3, r3, #1
 810140a:	697a      	ldr	r2, [r7, #20]
 810140c:	4413      	add	r3, r2
 810140e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8101412:	84fb      	strh	r3, [r7, #38]	; 0x26
						cptr->period = period;
 8101414:	68bb      	ldr	r3, [r7, #8]
 8101416:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8101418:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
					}

				break;
 810141c:	e084      	b.n	8101528 <worknote+0xa2c>
					current pattern. Hence 'loop pattern' cannot be performed across
					multiple patterns. Note that loops do not support nesting, and you
					may generate an infinite loop if you try to nest 'loop pattern's.
					*/

					if( effect_param_l )
 810141e:	7efb      	ldrb	r3, [r7, #27]
 8101420:	2b00      	cmp	r3, #0
 8101422:	d033      	beq.n	810148c <worknote+0x990>
					{
						if( cptr->patternloopcnt )
 8101424:	68bb      	ldr	r3, [r7, #8]
 8101426:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 810142a:	2b00      	cmp	r3, #0
 810142c:	d01e      	beq.n	810146c <worknote+0x970>
						{
							cptr->patternloopcnt--;
 810142e:	68bb      	ldr	r3, [r7, #8]
 8101430:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8101434:	3b01      	subs	r3, #1
 8101436:	b29a      	uxth	r2, r3
 8101438:	68bb      	ldr	r3, [r7, #8]
 810143a:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
							if( cptr->patternloopcnt )
 810143e:	68bb      	ldr	r3, [r7, #8]
 8101440:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
 8101444:	2b00      	cmp	r3, #0
 8101446:	d00a      	beq.n	810145e <worknote+0x962>
							{
								mod->patternpos = cptr->patternloopstartpoint;
 8101448:	68bb      	ldr	r3, [r7, #8]
 810144a:	f8b3 2062 	ldrh.w	r2, [r3, #98]	; 0x62
 810144e:	683b      	ldr	r3, [r7, #0]
 8101450:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2
								mod->jump_loop_effect = 1;
 8101454:	683b      	ldr	r3, [r7, #0]
 8101456:	2201      	movs	r2, #1
 8101458:	f883 26c6 	strb.w	r2, [r3, #1734]	; 0x6c6
					else // Start point
					{
						cptr->patternloopstartpoint = mod->patternpos;
					}

				break;
 810145c:	e069      	b.n	8101532 <worknote+0xa36>
								cptr->patternloopstartpoint = mod->patternpos ;
 810145e:	683b      	ldr	r3, [r7, #0]
 8101460:	f8b3 26c2 	ldrh.w	r2, [r3, #1730]	; 0x6c2
 8101464:	68bb      	ldr	r3, [r7, #8]
 8101466:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
				break;
 810146a:	e062      	b.n	8101532 <worknote+0xa36>
							cptr->patternloopcnt = effect_param_l;
 810146c:	7efb      	ldrb	r3, [r7, #27]
 810146e:	b29a      	uxth	r2, r3
 8101470:	68bb      	ldr	r3, [r7, #8]
 8101472:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
							mod->patternpos = cptr->patternloopstartpoint;
 8101476:	68bb      	ldr	r3, [r7, #8]
 8101478:	f8b3 2062 	ldrh.w	r2, [r3, #98]	; 0x62
 810147c:	683b      	ldr	r3, [r7, #0]
 810147e:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2
							mod->jump_loop_effect = 1;
 8101482:	683b      	ldr	r3, [r7, #0]
 8101484:	2201      	movs	r2, #1
 8101486:	f883 26c6 	strb.w	r2, [r3, #1734]	; 0x6c6
				break;
 810148a:	e052      	b.n	8101532 <worknote+0xa36>
						cptr->patternloopstartpoint = mod->patternpos;
 810148c:	683b      	ldr	r3, [r7, #0]
 810148e:	f8b3 26c2 	ldrh.w	r2, [r3, #1730]	; 0x6c2
 8101492:	68bb      	ldr	r3, [r7, #8]
 8101494:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
				break;
 8101498:	e04b      	b.n	8101532 <worknote+0xa36>
					pattern will be resumed". The delay only relates to the
					interpreting of new divisions, and all effects and previous notes
					continue during delay.
					*/

					mod->patterndelay = effect_param_l;
 810149a:	7efb      	ldrb	r3, [r7, #27]
 810149c:	b29a      	uxth	r2, r3
 810149e:	683b      	ldr	r3, [r7, #0]
 81014a0:	f8a3 26c4 	strh.w	r2, [r3, #1732]	; 0x6c4
				break;
 81014a4:	e045      	b.n	8101532 <worknote+0xa36>
					 this division". If x is 0, then no retriggering is done (acts as if
					 no effect was chosen), otherwise the retriggering begins on the
					 first tick and then x ticks after that, etc.
					*/

					if( effect_param_l )
 81014a6:	7efb      	ldrb	r3, [r7, #27]
 81014a8:	2b00      	cmp	r3, #0
 81014aa:	d03f      	beq.n	810152c <worknote+0xa30>
					{
						cptr->effect = EFFECT_EXTENDED;
 81014ac:	68bb      	ldr	r3, [r7, #8]
 81014ae:	220e      	movs	r2, #14
 81014b0:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
						cptr->parameffect = (EFFECT_E_RETRIGGER_NOTE<<4);
 81014b4:	68bb      	ldr	r3, [r7, #8]
 81014b6:	2290      	movs	r2, #144	; 0x90
 81014b8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
						cptr->retrig_param = effect_param_l;
 81014bc:	68bb      	ldr	r3, [r7, #8]
 81014be:	7efa      	ldrb	r2, [r7, #27]
 81014c0:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
						cptr->retrig_cnt = 0;
 81014c4:	68bb      	ldr	r3, [r7, #8]
 81014c6:	2200      	movs	r2, #0
 81014c8:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
					}
				break;
 81014cc:	e02e      	b.n	810152c <worknote+0xa30>
					If you wish to insert "silence" in a pattern, it is better to use a
					"silence"-sample (see above) due to the lack of proper support for
					this effect.
					*/

					cptr->effect = EFFECT_E_NOTE_CUT;
 81014ce:	68bb      	ldr	r3, [r7, #8]
 81014d0:	220c      	movs	r2, #12
 81014d2:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
					cptr->cut_param = effect_param_l;
 81014d6:	68bb      	ldr	r3, [r7, #8]
 81014d8:	7efa      	ldrb	r2, [r7, #27]
 81014da:	f883 205f 	strb.w	r2, [r3, #95]	; 0x5f
					if( !cptr->cut_param )
 81014de:	68bb      	ldr	r3, [r7, #8]
 81014e0:	f893 305f 	ldrb.w	r3, [r3, #95]	; 0x5f
 81014e4:	2b00      	cmp	r3, #0
 81014e6:	d123      	bne.n	8101530 <worknote+0xa34>
					{
						cptr->volume = 0;
 81014e8:	68bb      	ldr	r3, [r7, #8]
 81014ea:	2200      	movs	r2, #0
 81014ec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
						cptr->volume_table = mod->volume_selection_table[cptr->volume];
#endif
					}
				break;
 81014f0:	e01e      	b.n	8101530 <worknote+0xa34>
					 This implies that if x is 0, then you will hear no delay, but
					 actually there will be a VERY small delay. Note that this effect
					 only influences a sample if it was started in this division.
					*/

					cptr->effect = EFFECT_EXTENDED;
 81014f2:	68bb      	ldr	r3, [r7, #8]
 81014f4:	220e      	movs	r2, #14
 81014f6:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
					cptr->parameffect = (EFFECT_E_NOTE_DELAY<<4);
 81014fa:	68bb      	ldr	r3, [r7, #8]
 81014fc:	22d0      	movs	r2, #208	; 0xd0
 81014fe:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
				break;
 8101502:	e016      	b.n	8101532 <worknote+0xa36>
					sample's loop will have its sign changed (negated). It will only
					work if the sample's loop (defined previously) is not too big. The
					speed is based on an internal table.
					*/

					cptr->funkspeed = effect_param_l;
 8101504:	7efb      	ldrb	r3, [r7, #27]
 8101506:	b21a      	sxth	r2, r3
 8101508:	68bb      	ldr	r3, [r7, #8]
 810150a:	865a      	strh	r2, [r3, #50]	; 0x32

					doFunk(cptr);
 810150c:	68b8      	ldr	r0, [r7, #8]
 810150e:	f7ff fa93 	bl	8100a38 <doFunk>

				break;
 8101512:	e00e      	b.n	8101532 <worknote+0xa36>

				default:

				break;
 8101514:	bf00      	nop
 8101516:	e047      	b.n	81015a8 <worknote+0xaac>
				break;
 8101518:	bf00      	nop
 810151a:	e045      	b.n	81015a8 <worknote+0xaac>
				break;
 810151c:	bf00      	nop
 810151e:	e043      	b.n	81015a8 <worknote+0xaac>
				break;
 8101520:	bf00      	nop
 8101522:	e041      	b.n	81015a8 <worknote+0xaac>
				break;
 8101524:	bf00      	nop
 8101526:	e03f      	b.n	81015a8 <worknote+0xaac>
				break;
 8101528:	bf00      	nop
 810152a:	e03d      	b.n	81015a8 <worknote+0xaac>
				break;
 810152c:	bf00      	nop
 810152e:	e03b      	b.n	81015a8 <worknote+0xaac>
				break;
 8101530:	bf00      	nop
			}
		break;
 8101532:	e039      	b.n	81015a8 <worknote+0xaac>
			different implementations, but the one described here has the
			widest usage.
			*/


			if( effect_param )
 8101534:	7f3b      	ldrb	r3, [r7, #28]
 8101536:	2b00      	cmp	r3, #0
 8101538:	d035      	beq.n	81015a6 <worknote+0xaaa>
			{

				if( effect_param < 0x20 )
 810153a:	7f3b      	ldrb	r3, [r7, #28]
 810153c:	2b1f      	cmp	r3, #31
 810153e:	d804      	bhi.n	810154a <worknote+0xa4e>
				{
					mod->song.speed = effect_param;
 8101540:	683b      	ldr	r3, [r7, #0]
 8101542:	7f3a      	ldrb	r2, [r7, #28]
 8101544:	f883 243c 	strb.w	r2, [r3, #1084]	; 0x43c
 8101548:	e003      	b.n	8101552 <worknote+0xa56>
				}
				else
				{   // effect_param >= 0x20
					///	 HZ = 2 * BPM / 5
					mod->bpm = effect_param;
 810154a:	683b      	ldr	r3, [r7, #0]
 810154c:	7f3a      	ldrb	r2, [r7, #28]
 810154e:	f883 26c7 	strb.w	r2, [r3, #1735]	; 0x6c7
#else
				// song.speed = 1 <> 31
				// playrate = 8000 <> 96000
				// bpm = 32 <> 255

				mod->patternticksem = ( ( mod->playrate * 5 ) / ( (mulong)mod->bpm * 2 ) );
 8101552:	683b      	ldr	r3, [r7, #0]
 8101554:	f8d3 26bc 	ldr.w	r2, [r3, #1724]	; 0x6bc
 8101558:	4613      	mov	r3, r2
 810155a:	009b      	lsls	r3, r3, #2
 810155c:	441a      	add	r2, r3
 810155e:	683b      	ldr	r3, [r7, #0]
 8101560:	f893 36c7 	ldrb.w	r3, [r3, #1735]	; 0x6c7
 8101564:	005b      	lsls	r3, r3, #1
 8101566:	fbb2 f2f3 	udiv	r2, r2, r3
 810156a:	683b      	ldr	r3, [r7, #0]
 810156c:	f8c3 26d4 	str.w	r2, [r3, #1748]	; 0x6d4
#endif
				mod->patternticksaim = mod->song.speed * mod->patternticksem;
 8101570:	683b      	ldr	r3, [r7, #0]
 8101572:	f893 343c 	ldrb.w	r3, [r3, #1084]	; 0x43c
 8101576:	461a      	mov	r2, r3
 8101578:	683b      	ldr	r3, [r7, #0]
 810157a:	f8d3 36d4 	ldr.w	r3, [r3, #1748]	; 0x6d4
 810157e:	fb03 f202 	mul.w	r2, r3, r2
 8101582:	683b      	ldr	r3, [r7, #0]
 8101584:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
			}

		break;
 8101588:	e00d      	b.n	81015a6 <worknote+0xaaa>

		default:
		// Unsupported effect
		break;
 810158a:	bf00      	nop
 810158c:	e00c      	b.n	81015a8 <worknote+0xaac>
		break;
 810158e:	bf00      	nop
 8101590:	e00a      	b.n	81015a8 <worknote+0xaac>
		break;
 8101592:	bf00      	nop
 8101594:	e008      	b.n	81015a8 <worknote+0xaac>
		break;
 8101596:	bf00      	nop
 8101598:	e006      	b.n	81015a8 <worknote+0xaac>
		break;
 810159a:	bf00      	nop
 810159c:	e004      	b.n	81015a8 <worknote+0xaac>
		break;
 810159e:	bf00      	nop
 81015a0:	e002      	b.n	81015a8 <worknote+0xaac>
		break;
 81015a2:	bf00      	nop
 81015a4:	e000      	b.n	81015a8 <worknote+0xaac>
		break;
 81015a6:	bf00      	nop

	}

}
 81015a8:	bf00      	nop
 81015aa:	3728      	adds	r7, #40	; 0x28
 81015ac:	46bd      	mov	sp, r7
 81015ae:	bd80      	pop	{r7, pc}
 81015b0:	10000004 	.word	0x10000004

081015b4 <workeffect>:

static void workeffect( modcontext * modctx, note * nptr, channel * cptr )
{
 81015b4:	b580      	push	{r7, lr}
 81015b6:	b084      	sub	sp, #16
 81015b8:	af00      	add	r7, sp, #0
 81015ba:	60f8      	str	r0, [r7, #12]
 81015bc:	60b9      	str	r1, [r7, #8]
 81015be:	607a      	str	r2, [r7, #4]
	doFunk(cptr);
 81015c0:	6878      	ldr	r0, [r7, #4]
 81015c2:	f7ff fa39 	bl	8100a38 <doFunk>

	switch(cptr->effect)
 81015c6:	687b      	ldr	r3, [r7, #4]
 81015c8:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 81015cc:	2b0e      	cmp	r3, #14
 81015ce:	f200 8267 	bhi.w	8101aa0 <workeffect+0x4ec>
 81015d2:	a201      	add	r2, pc, #4	; (adr r2, 81015d8 <workeffect+0x24>)
 81015d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81015d8:	08101615 	.word	0x08101615
 81015dc:	0810166d 	.word	0x0810166d
 81015e0:	081016b5 	.word	0x081016b5
 81015e4:	081016f5 	.word	0x081016f5
 81015e8:	08101849 	.word	0x08101849
 81015ec:	081016f5 	.word	0x081016f5
 81015f0:	08101849 	.word	0x08101849
 81015f4:	08101aa1 	.word	0x08101aa1
 81015f8:	08101aa1 	.word	0x08101aa1
 81015fc:	08101aa1 	.word	0x08101aa1
 8101600:	08101925 	.word	0x08101925
 8101604:	08101aa1 	.word	0x08101aa1
 8101608:	08101aa1 	.word	0x08101aa1
 810160c:	08101aa1 	.word	0x08101aa1
 8101610:	0810198f 	.word	0x0810198f
	{
		case EFFECT_ARPEGGIO:

			if( cptr->parameffect )
 8101614:	687b      	ldr	r3, [r7, #4]
 8101616:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 810161a:	2b00      	cmp	r3, #0
 810161c:	f000 8242 	beq.w	8101aa4 <workeffect+0x4f0>
			{
				cptr->decalperiod = cptr->period - cptr->Arpperiods[cptr->ArpIndex];
 8101620:	687b      	ldr	r3, [r7, #4]
 8101622:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8101626:	687b      	ldr	r3, [r7, #4]
 8101628:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
 810162c:	6879      	ldr	r1, [r7, #4]
 810162e:	3328      	adds	r3, #40	; 0x28
 8101630:	005b      	lsls	r3, r3, #1
 8101632:	440b      	add	r3, r1
 8101634:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8101638:	b29b      	uxth	r3, r3
 810163a:	1ad3      	subs	r3, r2, r3
 810163c:	b29b      	uxth	r3, r3
 810163e:	b21a      	sxth	r2, r3
 8101640:	687b      	ldr	r3, [r7, #4]
 8101642:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c

				cptr->ArpIndex++;
 8101646:	687b      	ldr	r3, [r7, #4]
 8101648:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
 810164c:	3301      	adds	r3, #1
 810164e:	b2da      	uxtb	r2, r3
 8101650:	687b      	ldr	r3, [r7, #4]
 8101652:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a
				if( cptr->ArpIndex>2 )
 8101656:	687b      	ldr	r3, [r7, #4]
 8101658:	f893 305a 	ldrb.w	r3, [r3, #90]	; 0x5a
 810165c:	2b02      	cmp	r3, #2
 810165e:	f240 8221 	bls.w	8101aa4 <workeffect+0x4f0>
					cptr->ArpIndex = 0;
 8101662:	687b      	ldr	r3, [r7, #4]
 8101664:	2200      	movs	r2, #0
 8101666:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a
			}
		break;
 810166a:	e21b      	b.n	8101aa4 <workeffect+0x4f0>

		case EFFECT_PORTAMENTO_UP:

			if( cptr->period )
 810166c:	687b      	ldr	r3, [r7, #4]
 810166e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101672:	2b00      	cmp	r3, #0
 8101674:	f000 8218 	beq.w	8101aa8 <workeffect+0x4f4>
			{
				cptr->period -= cptr->parameffect;
 8101678:	687b      	ldr	r3, [r7, #4]
 810167a:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 810167e:	687b      	ldr	r3, [r7, #4]
 8101680:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8101684:	b29b      	uxth	r3, r3
 8101686:	1ad3      	subs	r3, r2, r3
 8101688:	b29a      	uxth	r2, r3
 810168a:	687b      	ldr	r3, [r7, #4]
 810168c:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

				if( cptr->period < 113 || cptr->period > 20000 )
 8101690:	687b      	ldr	r3, [r7, #4]
 8101692:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101696:	2b70      	cmp	r3, #112	; 0x70
 8101698:	d907      	bls.n	81016aa <workeffect+0xf6>
 810169a:	687b      	ldr	r3, [r7, #4]
 810169c:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 81016a0:	f644 6220 	movw	r2, #20000	; 0x4e20
 81016a4:	4293      	cmp	r3, r2
 81016a6:	f240 81ff 	bls.w	8101aa8 <workeffect+0x4f4>
					cptr->period = 113;
 81016aa:	687b      	ldr	r3, [r7, #4]
 81016ac:	2271      	movs	r2, #113	; 0x71
 81016ae:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
			}

		break;
 81016b2:	e1f9      	b.n	8101aa8 <workeffect+0x4f4>

		case EFFECT_PORTAMENTO_DOWN:

			if( cptr->period )
 81016b4:	687b      	ldr	r3, [r7, #4]
 81016b6:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 81016ba:	2b00      	cmp	r3, #0
 81016bc:	f000 81f6 	beq.w	8101aac <workeffect+0x4f8>
			{
				cptr->period += cptr->parameffect;
 81016c0:	687b      	ldr	r3, [r7, #4]
 81016c2:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 81016c6:	687b      	ldr	r3, [r7, #4]
 81016c8:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 81016cc:	b29b      	uxth	r3, r3
 81016ce:	4413      	add	r3, r2
 81016d0:	b29a      	uxth	r2, r3
 81016d2:	687b      	ldr	r3, [r7, #4]
 81016d4:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

				if( cptr->period > 20000 )
 81016d8:	687b      	ldr	r3, [r7, #4]
 81016da:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 81016de:	f644 6220 	movw	r2, #20000	; 0x4e20
 81016e2:	4293      	cmp	r3, r2
 81016e4:	f240 81e2 	bls.w	8101aac <workeffect+0x4f8>
					cptr->period = 20000;
 81016e8:	687b      	ldr	r3, [r7, #4]
 81016ea:	f644 6220 	movw	r2, #20000	; 0x4e20
 81016ee:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
			}

		break;
 81016f2:	e1db      	b.n	8101aac <workeffect+0x4f8>

		case EFFECT_VOLSLIDE_TONEPORTA:
		case EFFECT_TONE_PORTAMENTO:

			if( cptr->period && ( cptr->period != cptr->portaperiod ) && cptr->portaperiod )
 81016f4:	687b      	ldr	r3, [r7, #4]
 81016f6:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 81016fa:	2b00      	cmp	r3, #0
 81016fc:	d066      	beq.n	81017cc <workeffect+0x218>
 81016fe:	687b      	ldr	r3, [r7, #4]
 8101700:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101704:	461a      	mov	r2, r3
 8101706:	687b      	ldr	r3, [r7, #4]
 8101708:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 810170c:	429a      	cmp	r2, r3
 810170e:	d05d      	beq.n	81017cc <workeffect+0x218>
 8101710:	687b      	ldr	r3, [r7, #4]
 8101712:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 8101716:	2b00      	cmp	r3, #0
 8101718:	d058      	beq.n	81017cc <workeffect+0x218>
			{
				if( cptr->period > cptr->portaperiod )
 810171a:	687b      	ldr	r3, [r7, #4]
 810171c:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101720:	461a      	mov	r2, r3
 8101722:	687b      	ldr	r3, [r7, #4]
 8101724:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 8101728:	429a      	cmp	r2, r3
 810172a:	dd21      	ble.n	8101770 <workeffect+0x1bc>
				{
					if( cptr->period - cptr->portaperiod >= cptr->portaspeed )
 810172c:	687b      	ldr	r3, [r7, #4]
 810172e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101732:	461a      	mov	r2, r3
 8101734:	687b      	ldr	r3, [r7, #4]
 8101736:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 810173a:	1ad3      	subs	r3, r2, r3
 810173c:	687a      	ldr	r2, [r7, #4]
 810173e:	f9b2 204e 	ldrsh.w	r2, [r2, #78]	; 0x4e
 8101742:	4293      	cmp	r3, r2
 8101744:	db0c      	blt.n	8101760 <workeffect+0x1ac>
					{
						cptr->period -= cptr->portaspeed;
 8101746:	687b      	ldr	r3, [r7, #4]
 8101748:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 810174c:	687b      	ldr	r3, [r7, #4]
 810174e:	f9b3 304e 	ldrsh.w	r3, [r3, #78]	; 0x4e
 8101752:	b29b      	uxth	r3, r3
 8101754:	1ad3      	subs	r3, r2, r3
 8101756:	b29a      	uxth	r2, r3
 8101758:	687b      	ldr	r3, [r7, #4]
 810175a:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
 810175e:	e028      	b.n	81017b2 <workeffect+0x1fe>
					}
					else
					{
						cptr->period = cptr->portaperiod;
 8101760:	687b      	ldr	r3, [r7, #4]
 8101762:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 8101766:	b29a      	uxth	r2, r3
 8101768:	687b      	ldr	r3, [r7, #4]
 810176a:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
 810176e:	e020      	b.n	81017b2 <workeffect+0x1fe>
					}
				}
				else
				{
					if( cptr->portaperiod - cptr->period >= cptr->portaspeed )
 8101770:	687b      	ldr	r3, [r7, #4]
 8101772:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 8101776:	461a      	mov	r2, r3
 8101778:	687b      	ldr	r3, [r7, #4]
 810177a:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 810177e:	1ad3      	subs	r3, r2, r3
 8101780:	687a      	ldr	r2, [r7, #4]
 8101782:	f9b2 204e 	ldrsh.w	r2, [r2, #78]	; 0x4e
 8101786:	4293      	cmp	r3, r2
 8101788:	db0c      	blt.n	81017a4 <workeffect+0x1f0>
					{
						cptr->period += cptr->portaspeed;
 810178a:	687b      	ldr	r3, [r7, #4]
 810178c:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8101790:	687b      	ldr	r3, [r7, #4]
 8101792:	f9b3 304e 	ldrsh.w	r3, [r3, #78]	; 0x4e
 8101796:	b29b      	uxth	r3, r3
 8101798:	4413      	add	r3, r2
 810179a:	b29a      	uxth	r2, r3
 810179c:	687b      	ldr	r3, [r7, #4]
 810179e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
 81017a2:	e006      	b.n	81017b2 <workeffect+0x1fe>
					}
					else
					{
						cptr->period = cptr->portaperiod;
 81017a4:	687b      	ldr	r3, [r7, #4]
 81017a6:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 81017aa:	b29a      	uxth	r2, r3
 81017ac:	687b      	ldr	r3, [r7, #4]
 81017ae:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
					}
				}

				if( cptr->period == cptr->portaperiod )
 81017b2:	687b      	ldr	r3, [r7, #4]
 81017b4:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 81017b8:	461a      	mov	r2, r3
 81017ba:	687b      	ldr	r3, [r7, #4]
 81017bc:	f9b3 3050 	ldrsh.w	r3, [r3, #80]	; 0x50
 81017c0:	429a      	cmp	r2, r3
 81017c2:	d103      	bne.n	81017cc <workeffect+0x218>
				{
					// If the slide is over, don't let it to be retriggered.
					cptr->portaperiod = 0;
 81017c4:	687b      	ldr	r3, [r7, #4]
 81017c6:	2200      	movs	r2, #0
 81017c8:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
			if( cptr->glissando )
			{
				// TODO : Glissando effect.
			}

			if( cptr->effect == EFFECT_VOLSLIDE_TONEPORTA )
 81017cc:	687b      	ldr	r3, [r7, #4]
 81017ce:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 81017d2:	2b05      	cmp	r3, #5
 81017d4:	f040 816c 	bne.w	8101ab0 <workeffect+0x4fc>
			{
				if( cptr->volumeslide & 0xF0 )
 81017d8:	687b      	ldr	r3, [r7, #4]
 81017da:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 81017de:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 81017e2:	2b00      	cmp	r3, #0
 81017e4:	d017      	beq.n	8101816 <workeffect+0x262>
				{
					cptr->volume += ( cptr->volumeslide >> 4 );
 81017e6:	687b      	ldr	r3, [r7, #4]
 81017e8:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 81017ec:	687b      	ldr	r3, [r7, #4]
 81017ee:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 81017f2:	091b      	lsrs	r3, r3, #4
 81017f4:	b2db      	uxtb	r3, r3
 81017f6:	4413      	add	r3, r2
 81017f8:	b2da      	uxtb	r2, r3
 81017fa:	687b      	ldr	r3, [r7, #4]
 81017fc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

					if( cptr->volume > 63 )
 8101800:	687b      	ldr	r3, [r7, #4]
 8101802:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8101806:	2b3f      	cmp	r3, #63	; 0x3f
 8101808:	f240 8152 	bls.w	8101ab0 <workeffect+0x4fc>
						cptr->volume = 63;
 810180c:	687b      	ldr	r3, [r7, #4]
 810180e:	223f      	movs	r2, #63	; 0x3f
 8101810:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
				}
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
				cptr->volume_table = modctx->volume_selection_table[cptr->volume];
#endif
			}
		break;
 8101814:	e14c      	b.n	8101ab0 <workeffect+0x4fc>
					cptr->volume -= ( cptr->volumeslide & 0x0F );
 8101816:	687b      	ldr	r3, [r7, #4]
 8101818:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 810181c:	687b      	ldr	r3, [r7, #4]
 810181e:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 8101822:	f003 030f 	and.w	r3, r3, #15
 8101826:	b2db      	uxtb	r3, r3
 8101828:	1ad3      	subs	r3, r2, r3
 810182a:	b2da      	uxtb	r2, r3
 810182c:	687b      	ldr	r3, [r7, #4]
 810182e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
					if( cptr->volume > 63 )
 8101832:	687b      	ldr	r3, [r7, #4]
 8101834:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8101838:	2b3f      	cmp	r3, #63	; 0x3f
 810183a:	f240 8139 	bls.w	8101ab0 <workeffect+0x4fc>
						cptr->volume = 0;
 810183e:	687b      	ldr	r3, [r7, #4]
 8101840:	2200      	movs	r2, #0
 8101842:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
		break;
 8101846:	e133      	b.n	8101ab0 <workeffect+0x4fc>

		case EFFECT_VOLSLIDE_VIBRATO:
		case EFFECT_VIBRATO:

			cptr->vibraperiod = ( (cptr->vibraparam&0xF) * sintable[cptr->vibrapointeur&0x1F] )>>7;
 8101848:	687b      	ldr	r3, [r7, #4]
 810184a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 810184e:	f003 030f 	and.w	r3, r3, #15
 8101852:	687a      	ldr	r2, [r7, #4]
 8101854:	f892 205d 	ldrb.w	r2, [r2, #93]	; 0x5d
 8101858:	f002 021f 	and.w	r2, r2, #31
 810185c:	4999      	ldr	r1, [pc, #612]	; (8101ac4 <workeffect+0x510>)
 810185e:	f931 2012 	ldrsh.w	r2, [r1, r2, lsl #1]
 8101862:	fb02 f303 	mul.w	r3, r2, r3
 8101866:	11db      	asrs	r3, r3, #7
 8101868:	b21a      	sxth	r2, r3
 810186a:	687b      	ldr	r3, [r7, #4]
 810186c:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

			if( cptr->vibrapointeur > 31 )
 8101870:	687b      	ldr	r3, [r7, #4]
 8101872:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8101876:	2b1f      	cmp	r3, #31
 8101878:	d909      	bls.n	810188e <workeffect+0x2da>
				cptr->vibraperiod = -cptr->vibraperiod;
 810187a:	687b      	ldr	r3, [r7, #4]
 810187c:	f9b3 3052 	ldrsh.w	r3, [r3, #82]	; 0x52
 8101880:	b29b      	uxth	r3, r3
 8101882:	425b      	negs	r3, r3
 8101884:	b29b      	uxth	r3, r3
 8101886:	b21a      	sxth	r2, r3
 8101888:	687b      	ldr	r3, [r7, #4]
 810188a:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

			cptr->vibrapointeur = ( cptr->vibrapointeur + ( ( cptr->vibraparam>>4 ) & 0x0F) ) & 0x3F;
 810188e:	687b      	ldr	r3, [r7, #4]
 8101890:	f893 205d 	ldrb.w	r2, [r3, #93]	; 0x5d
 8101894:	687b      	ldr	r3, [r7, #4]
 8101896:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 810189a:	091b      	lsrs	r3, r3, #4
 810189c:	b2db      	uxtb	r3, r3
 810189e:	4413      	add	r3, r2
 81018a0:	b2db      	uxtb	r3, r3
 81018a2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 81018a6:	b2da      	uxtb	r2, r3
 81018a8:	687b      	ldr	r3, [r7, #4]
 81018aa:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

			if( cptr->effect == EFFECT_VOLSLIDE_VIBRATO )
 81018ae:	687b      	ldr	r3, [r7, #4]
 81018b0:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 81018b4:	2b06      	cmp	r3, #6
 81018b6:	f040 80fd 	bne.w	8101ab4 <workeffect+0x500>
			{
				if( cptr->volumeslide & 0xF0 )
 81018ba:	687b      	ldr	r3, [r7, #4]
 81018bc:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 81018c0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 81018c4:	2b00      	cmp	r3, #0
 81018c6:	d017      	beq.n	81018f8 <workeffect+0x344>
				{
					cptr->volume += ( cptr->volumeslide >> 4 );
 81018c8:	687b      	ldr	r3, [r7, #4]
 81018ca:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 81018ce:	687b      	ldr	r3, [r7, #4]
 81018d0:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 81018d4:	091b      	lsrs	r3, r3, #4
 81018d6:	b2db      	uxtb	r3, r3
 81018d8:	4413      	add	r3, r2
 81018da:	b2da      	uxtb	r2, r3
 81018dc:	687b      	ldr	r3, [r7, #4]
 81018de:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

					if( cptr->volume > 64 )
 81018e2:	687b      	ldr	r3, [r7, #4]
 81018e4:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 81018e8:	2b40      	cmp	r3, #64	; 0x40
 81018ea:	f240 80e3 	bls.w	8101ab4 <workeffect+0x500>
						cptr->volume = 64;
 81018ee:	687b      	ldr	r3, [r7, #4]
 81018f0:	2240      	movs	r2, #64	; 0x40
 81018f2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
				cptr->volume_table = modctx->volume_selection_table[cptr->volume];
#endif
			}

		break;
 81018f6:	e0dd      	b.n	8101ab4 <workeffect+0x500>
					cptr->volume -= cptr->volumeslide;
 81018f8:	687b      	ldr	r3, [r7, #4]
 81018fa:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 81018fe:	687b      	ldr	r3, [r7, #4]
 8101900:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 8101904:	1ad3      	subs	r3, r2, r3
 8101906:	b2da      	uxtb	r2, r3
 8101908:	687b      	ldr	r3, [r7, #4]
 810190a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
					if( cptr->volume > 64 )
 810190e:	687b      	ldr	r3, [r7, #4]
 8101910:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8101914:	2b40      	cmp	r3, #64	; 0x40
 8101916:	f240 80cd 	bls.w	8101ab4 <workeffect+0x500>
						cptr->volume = 0;
 810191a:	687b      	ldr	r3, [r7, #4]
 810191c:	2200      	movs	r2, #0
 810191e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
		break;
 8101922:	e0c7      	b.n	8101ab4 <workeffect+0x500>

		case EFFECT_VOLUME_SLIDE:

			if( cptr->volumeslide & 0xF0 )
 8101924:	687b      	ldr	r3, [r7, #4]
 8101926:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 810192a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 810192e:	2b00      	cmp	r3, #0
 8101930:	d017      	beq.n	8101962 <workeffect+0x3ae>
			{
				cptr->volume += ( cptr->volumeslide >> 4 );
 8101932:	687b      	ldr	r3, [r7, #4]
 8101934:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 8101938:	687b      	ldr	r3, [r7, #4]
 810193a:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 810193e:	091b      	lsrs	r3, r3, #4
 8101940:	b2db      	uxtb	r3, r3
 8101942:	4413      	add	r3, r2
 8101944:	b2da      	uxtb	r2, r3
 8101946:	687b      	ldr	r3, [r7, #4]
 8101948:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

				if( cptr->volume > 64 )
 810194c:	687b      	ldr	r3, [r7, #4]
 810194e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8101952:	2b40      	cmp	r3, #64	; 0x40
 8101954:	f240 80b0 	bls.w	8101ab8 <workeffect+0x504>
					cptr->volume = 64;
 8101958:	687b      	ldr	r3, [r7, #4]
 810195a:	2240      	movs	r2, #64	; 0x40
 810195c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
					cptr->volume = 0;
			}
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
			cptr->volume_table = modctx->volume_selection_table[cptr->volume];
#endif
		break;
 8101960:	e0aa      	b.n	8101ab8 <workeffect+0x504>
				cptr->volume -= cptr->volumeslide;
 8101962:	687b      	ldr	r3, [r7, #4]
 8101964:	f893 2042 	ldrb.w	r2, [r3, #66]	; 0x42
 8101968:	687b      	ldr	r3, [r7, #4]
 810196a:	f893 305b 	ldrb.w	r3, [r3, #91]	; 0x5b
 810196e:	1ad3      	subs	r3, r2, r3
 8101970:	b2da      	uxtb	r2, r3
 8101972:	687b      	ldr	r3, [r7, #4]
 8101974:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
				if( cptr->volume > 64 )
 8101978:	687b      	ldr	r3, [r7, #4]
 810197a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 810197e:	2b40      	cmp	r3, #64	; 0x40
 8101980:	f240 809a 	bls.w	8101ab8 <workeffect+0x504>
					cptr->volume = 0;
 8101984:	687b      	ldr	r3, [r7, #4]
 8101986:	2200      	movs	r2, #0
 8101988:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
		break;
 810198c:	e094      	b.n	8101ab8 <workeffect+0x504>

		case EFFECT_EXTENDED:
			switch( cptr->parameffect >> 4 )
 810198e:	687b      	ldr	r3, [r7, #4]
 8101990:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8101994:	091b      	lsrs	r3, r3, #4
 8101996:	b2db      	uxtb	r3, r3
 8101998:	2b0d      	cmp	r3, #13
 810199a:	d044      	beq.n	8101a26 <workeffect+0x472>
 810199c:	2b0d      	cmp	r3, #13
 810199e:	dc77      	bgt.n	8101a90 <workeffect+0x4dc>
 81019a0:	2b09      	cmp	r3, #9
 81019a2:	d018      	beq.n	81019d6 <workeffect+0x422>
 81019a4:	2b0c      	cmp	r3, #12
 81019a6:	d173      	bne.n	8101a90 <workeffect+0x4dc>
			{

				case EFFECT_E_NOTE_CUT:
					if( cptr->cut_param )
 81019a8:	687b      	ldr	r3, [r7, #4]
 81019aa:	f893 305f 	ldrb.w	r3, [r3, #95]	; 0x5f
 81019ae:	2b00      	cmp	r3, #0
 81019b0:	d007      	beq.n	81019c2 <workeffect+0x40e>
						cptr->cut_param--;
 81019b2:	687b      	ldr	r3, [r7, #4]
 81019b4:	f893 305f 	ldrb.w	r3, [r3, #95]	; 0x5f
 81019b8:	3b01      	subs	r3, #1
 81019ba:	b2da      	uxtb	r2, r3
 81019bc:	687b      	ldr	r3, [r7, #4]
 81019be:	f883 205f 	strb.w	r2, [r3, #95]	; 0x5f

					if( !cptr->cut_param )
 81019c2:	687b      	ldr	r3, [r7, #4]
 81019c4:	f893 305f 	ldrb.w	r3, [r3, #95]	; 0x5f
 81019c8:	2b00      	cmp	r3, #0
 81019ca:	d163      	bne.n	8101a94 <workeffect+0x4e0>
					{
						cptr->volume = 0;
 81019cc:	687b      	ldr	r3, [r7, #4]
 81019ce:	2200      	movs	r2, #0
 81019d0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
						cptr->volume_table = modctx->volume_selection_table[cptr->volume];
#endif
					}
				break;
 81019d4:	e05e      	b.n	8101a94 <workeffect+0x4e0>

				case EFFECT_E_RETRIGGER_NOTE:
					cptr->retrig_cnt++;
 81019d6:	687b      	ldr	r3, [r7, #4]
 81019d8:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 81019dc:	3301      	adds	r3, #1
 81019de:	b2da      	uxtb	r2, r3
 81019e0:	687b      	ldr	r3, [r7, #4]
 81019e2:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
					if( cptr->retrig_cnt >= cptr->retrig_param )
 81019e6:	687b      	ldr	r3, [r7, #4]
 81019e8:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
 81019ec:	687b      	ldr	r3, [r7, #4]
 81019ee:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 81019f2:	429a      	cmp	r2, r3
 81019f4:	d350      	bcc.n	8101a98 <workeffect+0x4e4>
					{
						cptr->retrig_cnt = 0;
 81019f6:	687b      	ldr	r3, [r7, #4]
 81019f8:	2200      	movs	r2, #0
 81019fa:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

						cptr->sampdata = cptr->lst_sampdata;
 81019fe:	687b      	ldr	r3, [r7, #4]
 8101a00:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8101a02:	687b      	ldr	r3, [r7, #4]
 8101a04:	601a      	str	r2, [r3, #0]
						cptr->length = cptr->lst_length;
 8101a06:	687b      	ldr	r3, [r7, #4]
 8101a08:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8101a0a:	687b      	ldr	r3, [r7, #4]
 8101a0c:	809a      	strh	r2, [r3, #4]
						cptr->reppnt = cptr->lst_reppnt;
 8101a0e:	687b      	ldr	r3, [r7, #4]
 8101a10:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
 8101a12:	687b      	ldr	r3, [r7, #4]
 8101a14:	80da      	strh	r2, [r3, #6]
						cptr->replen = cptr->lst_replen;
 8101a16:	687b      	ldr	r3, [r7, #4]
 8101a18:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 8101a1a:	687b      	ldr	r3, [r7, #4]
 8101a1c:	811a      	strh	r2, [r3, #8]
						cptr->samppos = 0;
 8101a1e:	687b      	ldr	r3, [r7, #4]
 8101a20:	2200      	movs	r2, #0
 8101a22:	639a      	str	r2, [r3, #56]	; 0x38
					}
				break;
 8101a24:	e038      	b.n	8101a98 <workeffect+0x4e4>

				case EFFECT_E_NOTE_DELAY:
					if( cptr->note_delay )
 8101a26:	687b      	ldr	r3, [r7, #4]
 8101a28:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8101a2c:	2b00      	cmp	r3, #0
 8101a2e:	d035      	beq.n	8101a9c <workeffect+0x4e8>
					{
						if( (unsigned char)( cptr->note_delay - 1 ) == modctx->tick_cnt )
 8101a30:	687b      	ldr	r3, [r7, #4]
 8101a32:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8101a36:	3b01      	subs	r3, #1
 8101a38:	b2db      	uxtb	r3, r3
 8101a3a:	461a      	mov	r2, r3
 8101a3c:	68fb      	ldr	r3, [r7, #12]
 8101a3e:	f8d3 36d8 	ldr.w	r3, [r3, #1752]	; 0x6d8
 8101a42:	429a      	cmp	r2, r3
 8101a44:	d12a      	bne.n	8101a9c <workeffect+0x4e8>
						{
							cptr->sampdata = cptr->dly_sampdata;
 8101a46:	687b      	ldr	r3, [r7, #4]
 8101a48:	699a      	ldr	r2, [r3, #24]
 8101a4a:	687b      	ldr	r3, [r7, #4]
 8101a4c:	601a      	str	r2, [r3, #0]
							cptr->length = cptr->dly_length;
 8101a4e:	687b      	ldr	r3, [r7, #4]
 8101a50:	8b9a      	ldrh	r2, [r3, #28]
 8101a52:	687b      	ldr	r3, [r7, #4]
 8101a54:	809a      	strh	r2, [r3, #4]
							cptr->reppnt = cptr->dly_reppnt;
 8101a56:	687b      	ldr	r3, [r7, #4]
 8101a58:	8bda      	ldrh	r2, [r3, #30]
 8101a5a:	687b      	ldr	r3, [r7, #4]
 8101a5c:	80da      	strh	r2, [r3, #6]
							cptr->replen = cptr->dly_replen;
 8101a5e:	687b      	ldr	r3, [r7, #4]
 8101a60:	8c1a      	ldrh	r2, [r3, #32]
 8101a62:	687b      	ldr	r3, [r7, #4]
 8101a64:	811a      	strh	r2, [r3, #8]

							cptr->lst_sampdata = cptr->sampdata;
 8101a66:	687b      	ldr	r3, [r7, #4]
 8101a68:	681a      	ldr	r2, [r3, #0]
 8101a6a:	687b      	ldr	r3, [r7, #4]
 8101a6c:	625a      	str	r2, [r3, #36]	; 0x24
							cptr->lst_length = cptr->length;
 8101a6e:	687b      	ldr	r3, [r7, #4]
 8101a70:	889a      	ldrh	r2, [r3, #4]
 8101a72:	687b      	ldr	r3, [r7, #4]
 8101a74:	851a      	strh	r2, [r3, #40]	; 0x28
							cptr->lst_reppnt = cptr->reppnt;
 8101a76:	687b      	ldr	r3, [r7, #4]
 8101a78:	88da      	ldrh	r2, [r3, #6]
 8101a7a:	687b      	ldr	r3, [r7, #4]
 8101a7c:	855a      	strh	r2, [r3, #42]	; 0x2a
							cptr->lst_replen = cptr->replen;
 8101a7e:	687b      	ldr	r3, [r7, #4]
 8101a80:	891a      	ldrh	r2, [r3, #8]
 8101a82:	687b      	ldr	r3, [r7, #4]
 8101a84:	859a      	strh	r2, [r3, #44]	; 0x2c
							cptr->note_delay = 0;
 8101a86:	687b      	ldr	r3, [r7, #4]
 8101a88:	2200      	movs	r2, #0
 8101a8a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
						}
					}
				break;
 8101a8e:	e005      	b.n	8101a9c <workeffect+0x4e8>
				default:
				break;
 8101a90:	bf00      	nop
 8101a92:	e012      	b.n	8101aba <workeffect+0x506>
				break;
 8101a94:	bf00      	nop
 8101a96:	e010      	b.n	8101aba <workeffect+0x506>
				break;
 8101a98:	bf00      	nop
 8101a9a:	e00e      	b.n	8101aba <workeffect+0x506>
				break;
 8101a9c:	bf00      	nop
			}
		break;
 8101a9e:	e00c      	b.n	8101aba <workeffect+0x506>

		default:
		break;
 8101aa0:	bf00      	nop
 8101aa2:	e00a      	b.n	8101aba <workeffect+0x506>
		break;
 8101aa4:	bf00      	nop
 8101aa6:	e008      	b.n	8101aba <workeffect+0x506>
		break;
 8101aa8:	bf00      	nop
 8101aaa:	e006      	b.n	8101aba <workeffect+0x506>
		break;
 8101aac:	bf00      	nop
 8101aae:	e004      	b.n	8101aba <workeffect+0x506>
		break;
 8101ab0:	bf00      	nop
 8101ab2:	e002      	b.n	8101aba <workeffect+0x506>
		break;
 8101ab4:	bf00      	nop
 8101ab6:	e000      	b.n	8101aba <workeffect+0x506>
		break;
 8101ab8:	bf00      	nop

	}

}
 8101aba:	bf00      	nop
 8101abc:	3710      	adds	r7, #16
 8101abe:	46bd      	mov	sp, r7
 8101ac0:	bd80      	pop	{r7, pc}
 8101ac2:	bf00      	nop
 8101ac4:	08104d8c 	.word	0x08104d8c

08101ac8 <hxcmod_fillbuffer>:

	return 0;
}

void hxcmod_fillbuffer(modcontext * modctx, msample * outbuffer, mssize nbsample, tracker_buffer_state * trkbuf)
{
 8101ac8:	b580      	push	{r7, lr}
 8101aca:	b092      	sub	sp, #72	; 0x48
 8101acc:	af00      	add	r7, sp, #0
 8101ace:	60f8      	str	r0, [r7, #12]
 8101ad0:	60b9      	str	r1, [r7, #8]
 8101ad2:	607a      	str	r2, [r7, #4]
 8101ad4:	603b      	str	r3, [r7, #0]

	short finalperiod;
	note	*nptr;
	channel *cptr;

	if( modctx && outbuffer )
 8101ad6:	68fb      	ldr	r3, [r7, #12]
 8101ad8:	2b00      	cmp	r3, #0
 8101ada:	f000 8482 	beq.w	81023e2 <hxcmod_fillbuffer+0x91a>
 8101ade:	68bb      	ldr	r3, [r7, #8]
 8101ae0:	2b00      	cmp	r3, #0
 8101ae2:	f000 847e 	beq.w	81023e2 <hxcmod_fillbuffer+0x91a>
	{
		if(modctx->mod_loaded)
 8101ae6:	68fb      	ldr	r3, [r7, #12]
 8101ae8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8101aec:	f8b3 3362 	ldrh.w	r3, [r3, #866]	; 0x362
 8101af0:	2b00      	cmp	r3, #0
 8101af2:	f000 8440 	beq.w	8102376 <hxcmod_fillbuffer+0x8ae>
		{
			state_remaining_steps = 0;
 8101af6:	2300      	movs	r3, #0
 8101af8:	63fb      	str	r3, [r7, #60]	; 0x3c

#ifdef HXCMOD_STATE_REPORT_SUPPORT
			if( trkbuf )
 8101afa:	683b      	ldr	r3, [r7, #0]
 8101afc:	2b00      	cmp	r3, #0
 8101afe:	d027      	beq.n	8101b50 <hxcmod_fillbuffer+0x88>
			{
				trkbuf->cur_rd_index = 0;
 8101b00:	683b      	ldr	r3, [r7, #0]
 8101b02:	2200      	movs	r2, #0
 8101b04:	609a      	str	r2, [r3, #8]

				memcopy(trkbuf->name,modctx->song.title,sizeof(modctx->song.title));
 8101b06:	683b      	ldr	r3, [r7, #0]
 8101b08:	3310      	adds	r3, #16
 8101b0a:	68f9      	ldr	r1, [r7, #12]
 8101b0c:	2214      	movs	r2, #20
 8101b0e:	4618      	mov	r0, r3
 8101b10:	f7fe ff2a 	bl	8100968 <memcopy>

				for(i=0;i<31;i++)
 8101b14:	2300      	movs	r3, #0
 8101b16:	647b      	str	r3, [r7, #68]	; 0x44
 8101b18:	e017      	b.n	8101b4a <hxcmod_fillbuffer+0x82>
				{
					memcopy(trkbuf->instruments[i].name,modctx->song.samples[i].name,sizeof(trkbuf->instruments[i].name));
 8101b1a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8101b1c:	4613      	mov	r3, r2
 8101b1e:	00db      	lsls	r3, r3, #3
 8101b20:	1a9b      	subs	r3, r3, r2
 8101b22:	009b      	lsls	r3, r3, #2
 8101b24:	3350      	adds	r3, #80	; 0x50
 8101b26:	683a      	ldr	r2, [r7, #0]
 8101b28:	18d0      	adds	r0, r2, r3
 8101b2a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8101b2c:	4613      	mov	r3, r2
 8101b2e:	011b      	lsls	r3, r3, #4
 8101b30:	1a9b      	subs	r3, r3, r2
 8101b32:	005b      	lsls	r3, r3, #1
 8101b34:	3310      	adds	r3, #16
 8101b36:	68fa      	ldr	r2, [r7, #12]
 8101b38:	4413      	add	r3, r2
 8101b3a:	3304      	adds	r3, #4
 8101b3c:	2216      	movs	r2, #22
 8101b3e:	4619      	mov	r1, r3
 8101b40:	f7fe ff12 	bl	8100968 <memcopy>
				for(i=0;i<31;i++)
 8101b44:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8101b46:	3301      	adds	r3, #1
 8101b48:	647b      	str	r3, [r7, #68]	; 0x44
 8101b4a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8101b4c:	2b1e      	cmp	r3, #30
 8101b4e:	d9e4      	bls.n	8101b1a <hxcmod_fillbuffer+0x52>
			}
#endif

#ifdef HXCMOD_OUTPUT_FILTER
	#ifndef HXCMOD_MONO_OUTPUT
			ll = modctx->last_l_sample;
 8101b50:	68fb      	ldr	r3, [r7, #12]
 8101b52:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8101b56:	f9b3 3366 	ldrsh.w	r3, [r3, #870]	; 0x366
 8101b5a:	63bb      	str	r3, [r7, #56]	; 0x38
	#endif
			lr = modctx->last_r_sample;
 8101b5c:	68fb      	ldr	r3, [r7, #12]
 8101b5e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8101b62:	f9b3 3364 	ldrsh.w	r3, [r3, #868]	; 0x364
 8101b66:	637b      	str	r3, [r7, #52]	; 0x34
#endif

			for (i = 0; i < nbsample; i++)
 8101b68:	2300      	movs	r3, #0
 8101b6a:	647b      	str	r3, [r7, #68]	; 0x44
 8101b6c:	e3ef      	b.n	810234e <hxcmod_fillbuffer+0x886>
			{
				//---------------------------------------
				if( modctx->patternticks++ > modctx->patternticksaim )
 8101b6e:	68fb      	ldr	r3, [r7, #12]
 8101b70:	f8d3 36c8 	ldr.w	r3, [r3, #1736]	; 0x6c8
 8101b74:	1c59      	adds	r1, r3, #1
 8101b76:	68fa      	ldr	r2, [r7, #12]
 8101b78:	f8c2 16c8 	str.w	r1, [r2, #1736]	; 0x6c8
 8101b7c:	68fa      	ldr	r2, [r7, #12]
 8101b7e:	f8d2 26d0 	ldr.w	r2, [r2, #1744]	; 0x6d0
 8101b82:	4293      	cmp	r3, r2
 8101b84:	f240 80c9 	bls.w	8101d1a <hxcmod_fillbuffer+0x252>
				{
					if( !modctx->patterndelay )
 8101b88:	68fb      	ldr	r3, [r7, #12]
 8101b8a:	f8b3 36c4 	ldrh.w	r3, [r3, #1732]	; 0x6c4
 8101b8e:	2b00      	cmp	r3, #0
 8101b90:	f040 80af 	bne.w	8101cf2 <hxcmod_fillbuffer+0x22a>
					{
						nptr = modctx->patterndata[modctx->song.patterntable[modctx->tablepos]];
 8101b94:	68fb      	ldr	r3, [r7, #12]
 8101b96:	f8b3 36c0 	ldrh.w	r3, [r3, #1728]	; 0x6c0
 8101b9a:	461a      	mov	r2, r3
 8101b9c:	68fb      	ldr	r3, [r7, #12]
 8101b9e:	4413      	add	r3, r2
 8101ba0:	f893 33b8 	ldrb.w	r3, [r3, #952]	; 0x3b8
 8101ba4:	68fa      	ldr	r2, [r7, #12]
 8101ba6:	f503 7397 	add.w	r3, r3, #302	; 0x12e
 8101baa:	009b      	lsls	r3, r3, #2
 8101bac:	4413      	add	r3, r2
 8101bae:	685b      	ldr	r3, [r3, #4]
 8101bb0:	62bb      	str	r3, [r7, #40]	; 0x28
						nptr = nptr + modctx->patternpos;
 8101bb2:	68fb      	ldr	r3, [r7, #12]
 8101bb4:	f8b3 36c2 	ldrh.w	r3, [r3, #1730]	; 0x6c2
 8101bb8:	009b      	lsls	r3, r3, #2
 8101bba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8101bbc:	4413      	add	r3, r2
 8101bbe:	62bb      	str	r3, [r7, #40]	; 0x28
						cptr = modctx->channels;
 8101bc0:	68fb      	ldr	r3, [r7, #12]
 8101bc2:	f503 63dc 	add.w	r3, r3, #1760	; 0x6e0
 8101bc6:	627b      	str	r3, [r7, #36]	; 0x24

						modctx->tick_cnt = 0;
 8101bc8:	68fb      	ldr	r3, [r7, #12]
 8101bca:	2200      	movs	r2, #0
 8101bcc:	f8c3 26d8 	str.w	r2, [r3, #1752]	; 0x6d8

						modctx->patternticks = 0;
 8101bd0:	68fb      	ldr	r3, [r7, #12]
 8101bd2:	2200      	movs	r2, #0
 8101bd4:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
						modctx->patterntickse = 0;
 8101bd8:	68fb      	ldr	r3, [r7, #12]
 8101bda:	2200      	movs	r2, #0
 8101bdc:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc

						for(c=0;c<modctx->number_of_channels;c++)
 8101be0:	2300      	movs	r3, #0
 8101be2:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
 8101be6:	e03e      	b.n	8101c66 <hxcmod_fillbuffer+0x19e>
						{
							worknote((note*)(nptr), (channel*)(cptr),(char)(c+1),modctx);
 8101be8:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8101bec:	b2db      	uxtb	r3, r3
 8101bee:	3301      	adds	r3, #1
 8101bf0:	b2da      	uxtb	r2, r3
 8101bf2:	68fb      	ldr	r3, [r7, #12]
 8101bf4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8101bf6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8101bf8:	f7fe ff80 	bl	8100afc <worknote>

							if (cptr->period != 0)
 8101bfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101bfe:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101c02:	2b00      	cmp	r3, #0
 8101c04:	d021      	beq.n	8101c4a <hxcmod_fillbuffer+0x182>
							{
								finalperiod = cptr->period - cptr->decalperiod - cptr->vibraperiod;
 8101c06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101c08:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8101c0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101c0e:	f9b3 304c 	ldrsh.w	r3, [r3, #76]	; 0x4c
 8101c12:	b29b      	uxth	r3, r3
 8101c14:	1ad3      	subs	r3, r2, r3
 8101c16:	b29a      	uxth	r2, r3
 8101c18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101c1a:	f9b3 3052 	ldrsh.w	r3, [r3, #82]	; 0x52
 8101c1e:	b29b      	uxth	r3, r3
 8101c20:	1ad3      	subs	r3, r2, r3
 8101c22:	b29b      	uxth	r3, r3
 8101c24:	847b      	strh	r3, [r7, #34]	; 0x22
								if (finalperiod)
 8101c26:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8101c2a:	2b00      	cmp	r3, #0
 8101c2c:	d009      	beq.n	8101c42 <hxcmod_fillbuffer+0x17a>
								{
									cptr->sampinc = ((modctx->sampleticksconst) / finalperiod);
 8101c2e:	68fb      	ldr	r3, [r7, #12]
 8101c30:	f8d3 26dc 	ldr.w	r2, [r3, #1756]	; 0x6dc
 8101c34:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8101c38:	fbb2 f2f3 	udiv	r2, r2, r3
 8101c3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101c3e:	63da      	str	r2, [r3, #60]	; 0x3c
 8101c40:	e006      	b.n	8101c50 <hxcmod_fillbuffer+0x188>
								}
								else
								{
									cptr->sampinc = 0;
 8101c42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101c44:	2200      	movs	r2, #0
 8101c46:	63da      	str	r2, [r3, #60]	; 0x3c
 8101c48:	e002      	b.n	8101c50 <hxcmod_fillbuffer+0x188>
								}
							}
							else
								cptr->sampinc = 0;
 8101c4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101c4c:	2200      	movs	r2, #0
 8101c4e:	63da      	str	r2, [r3, #60]	; 0x3c

							nptr++;
 8101c50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8101c52:	3304      	adds	r3, #4
 8101c54:	62bb      	str	r3, [r7, #40]	; 0x28
							cptr++;
 8101c56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101c58:	3364      	adds	r3, #100	; 0x64
 8101c5a:	627b      	str	r3, [r7, #36]	; 0x24
						for(c=0;c<modctx->number_of_channels;c++)
 8101c5c:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8101c60:	3301      	adds	r3, #1
 8101c62:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
 8101c66:	68fb      	ldr	r3, [r7, #12]
 8101c68:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8101c6c:	f8b3 3360 	ldrh.w	r3, [r3, #864]	; 0x360
 8101c70:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 8101c74:	429a      	cmp	r2, r3
 8101c76:	d3b7      	bcc.n	8101be8 <hxcmod_fillbuffer+0x120>
						}

						if( !modctx->jump_loop_effect )
 8101c78:	68fb      	ldr	r3, [r7, #12]
 8101c7a:	f893 36c6 	ldrb.w	r3, [r3, #1734]	; 0x6c6
 8101c7e:	2b00      	cmp	r3, #0
 8101c80:	d10d      	bne.n	8101c9e <hxcmod_fillbuffer+0x1d6>
							modctx->patternpos += modctx->number_of_channels;
 8101c82:	68fb      	ldr	r3, [r7, #12]
 8101c84:	f8b3 26c2 	ldrh.w	r2, [r3, #1730]	; 0x6c2
 8101c88:	68fb      	ldr	r3, [r7, #12]
 8101c8a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8101c8e:	f8b3 3360 	ldrh.w	r3, [r3, #864]	; 0x360
 8101c92:	4413      	add	r3, r2
 8101c94:	b29a      	uxth	r2, r3
 8101c96:	68fb      	ldr	r3, [r7, #12]
 8101c98:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2
 8101c9c:	e003      	b.n	8101ca6 <hxcmod_fillbuffer+0x1de>
						else
							modctx->jump_loop_effect = 0;
 8101c9e:	68fb      	ldr	r3, [r7, #12]
 8101ca0:	2200      	movs	r2, #0
 8101ca2:	f883 26c6 	strb.w	r2, [r3, #1734]	; 0x6c6

						if( modctx->patternpos == 64*modctx->number_of_channels )
 8101ca6:	68fb      	ldr	r3, [r7, #12]
 8101ca8:	f8b3 36c2 	ldrh.w	r3, [r3, #1730]	; 0x6c2
 8101cac:	461a      	mov	r2, r3
 8101cae:	68fb      	ldr	r3, [r7, #12]
 8101cb0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8101cb4:	f8b3 3360 	ldrh.w	r3, [r3, #864]	; 0x360
 8101cb8:	019b      	lsls	r3, r3, #6
 8101cba:	429a      	cmp	r2, r3
 8101cbc:	d12d      	bne.n	8101d1a <hxcmod_fillbuffer+0x252>
						{
							modctx->tablepos++;
 8101cbe:	68fb      	ldr	r3, [r7, #12]
 8101cc0:	f8b3 36c0 	ldrh.w	r3, [r3, #1728]	; 0x6c0
 8101cc4:	3301      	adds	r3, #1
 8101cc6:	b29a      	uxth	r2, r3
 8101cc8:	68fb      	ldr	r3, [r7, #12]
 8101cca:	f8a3 26c0 	strh.w	r2, [r3, #1728]	; 0x6c0
							modctx->patternpos = 0;
 8101cce:	68fb      	ldr	r3, [r7, #12]
 8101cd0:	2200      	movs	r2, #0
 8101cd2:	f8a3 26c2 	strh.w	r2, [r3, #1730]	; 0x6c2
							if(modctx->tablepos >= modctx->song.length)
 8101cd6:	68fb      	ldr	r3, [r7, #12]
 8101cd8:	f8b3 26c0 	ldrh.w	r2, [r3, #1728]	; 0x6c0
 8101cdc:	68fb      	ldr	r3, [r7, #12]
 8101cde:	f893 33b6 	ldrb.w	r3, [r3, #950]	; 0x3b6
 8101ce2:	b29b      	uxth	r3, r3
 8101ce4:	429a      	cmp	r2, r3
 8101ce6:	d318      	bcc.n	8101d1a <hxcmod_fillbuffer+0x252>
								modctx->tablepos = 0;
 8101ce8:	68fb      	ldr	r3, [r7, #12]
 8101cea:	2200      	movs	r2, #0
 8101cec:	f8a3 26c0 	strh.w	r2, [r3, #1728]	; 0x6c0
 8101cf0:	e013      	b.n	8101d1a <hxcmod_fillbuffer+0x252>
						}
					}
					else
					{
						modctx->patterndelay--;
 8101cf2:	68fb      	ldr	r3, [r7, #12]
 8101cf4:	f8b3 36c4 	ldrh.w	r3, [r3, #1732]	; 0x6c4
 8101cf8:	3b01      	subs	r3, #1
 8101cfa:	b29a      	uxth	r2, r3
 8101cfc:	68fb      	ldr	r3, [r7, #12]
 8101cfe:	f8a3 26c4 	strh.w	r2, [r3, #1732]	; 0x6c4
						modctx->patternticks = 0;
 8101d02:	68fb      	ldr	r3, [r7, #12]
 8101d04:	2200      	movs	r2, #0
 8101d06:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
						modctx->patterntickse = 0;
 8101d0a:	68fb      	ldr	r3, [r7, #12]
 8101d0c:	2200      	movs	r2, #0
 8101d0e:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc
						modctx->tick_cnt = 0;
 8101d12:	68fb      	ldr	r3, [r7, #12]
 8101d14:	2200      	movs	r2, #0
 8101d16:	f8c3 26d8 	str.w	r2, [r3, #1752]	; 0x6d8
					}

				}

				if (modctx->patterntickse++ > modctx->patternticksem)
 8101d1a:	68fb      	ldr	r3, [r7, #12]
 8101d1c:	f8d3 36cc 	ldr.w	r3, [r3, #1740]	; 0x6cc
 8101d20:	1c59      	adds	r1, r3, #1
 8101d22:	68fa      	ldr	r2, [r7, #12]
 8101d24:	f8c2 16cc 	str.w	r1, [r2, #1740]	; 0x6cc
 8101d28:	68fa      	ldr	r2, [r7, #12]
 8101d2a:	f8d2 26d4 	ldr.w	r2, [r2, #1748]	; 0x6d4
 8101d2e:	4293      	cmp	r3, r2
 8101d30:	d96b      	bls.n	8101e0a <hxcmod_fillbuffer+0x342>
				{
					nptr = modctx->patterndata[modctx->song.patterntable[modctx->tablepos]];
 8101d32:	68fb      	ldr	r3, [r7, #12]
 8101d34:	f8b3 36c0 	ldrh.w	r3, [r3, #1728]	; 0x6c0
 8101d38:	461a      	mov	r2, r3
 8101d3a:	68fb      	ldr	r3, [r7, #12]
 8101d3c:	4413      	add	r3, r2
 8101d3e:	f893 33b8 	ldrb.w	r3, [r3, #952]	; 0x3b8
 8101d42:	68fa      	ldr	r2, [r7, #12]
 8101d44:	f503 7397 	add.w	r3, r3, #302	; 0x12e
 8101d48:	009b      	lsls	r3, r3, #2
 8101d4a:	4413      	add	r3, r2
 8101d4c:	685b      	ldr	r3, [r3, #4]
 8101d4e:	62bb      	str	r3, [r7, #40]	; 0x28
					nptr = nptr + modctx->patternpos;
 8101d50:	68fb      	ldr	r3, [r7, #12]
 8101d52:	f8b3 36c2 	ldrh.w	r3, [r3, #1730]	; 0x6c2
 8101d56:	009b      	lsls	r3, r3, #2
 8101d58:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8101d5a:	4413      	add	r3, r2
 8101d5c:	62bb      	str	r3, [r7, #40]	; 0x28
					cptr = modctx->channels;
 8101d5e:	68fb      	ldr	r3, [r7, #12]
 8101d60:	f503 63dc 	add.w	r3, r3, #1760	; 0x6e0
 8101d64:	627b      	str	r3, [r7, #36]	; 0x24

					for(c=0;c<modctx->number_of_channels;c++)
 8101d66:	2300      	movs	r3, #0
 8101d68:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
 8101d6c:	e039      	b.n	8101de2 <hxcmod_fillbuffer+0x31a>
					{
						workeffect( modctx, nptr, cptr );
 8101d6e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8101d70:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8101d72:	68f8      	ldr	r0, [r7, #12]
 8101d74:	f7ff fc1e 	bl	81015b4 <workeffect>

						if (cptr->period != 0)
 8101d78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101d7a:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101d7e:	2b00      	cmp	r3, #0
 8101d80:	d021      	beq.n	8101dc6 <hxcmod_fillbuffer+0x2fe>
						{
							finalperiod = cptr->period - cptr->decalperiod - cptr->vibraperiod;
 8101d82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101d84:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8101d88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101d8a:	f9b3 304c 	ldrsh.w	r3, [r3, #76]	; 0x4c
 8101d8e:	b29b      	uxth	r3, r3
 8101d90:	1ad3      	subs	r3, r2, r3
 8101d92:	b29a      	uxth	r2, r3
 8101d94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101d96:	f9b3 3052 	ldrsh.w	r3, [r3, #82]	; 0x52
 8101d9a:	b29b      	uxth	r3, r3
 8101d9c:	1ad3      	subs	r3, r2, r3
 8101d9e:	b29b      	uxth	r3, r3
 8101da0:	847b      	strh	r3, [r7, #34]	; 0x22
							if (finalperiod)
 8101da2:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8101da6:	2b00      	cmp	r3, #0
 8101da8:	d009      	beq.n	8101dbe <hxcmod_fillbuffer+0x2f6>
							{
								cptr->sampinc = ((modctx->sampleticksconst) / finalperiod);
 8101daa:	68fb      	ldr	r3, [r7, #12]
 8101dac:	f8d3 26dc 	ldr.w	r2, [r3, #1756]	; 0x6dc
 8101db0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8101db4:	fbb2 f2f3 	udiv	r2, r2, r3
 8101db8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101dba:	63da      	str	r2, [r3, #60]	; 0x3c
 8101dbc:	e006      	b.n	8101dcc <hxcmod_fillbuffer+0x304>
							}
							else
							{
								cptr->sampinc = 0;
 8101dbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101dc0:	2200      	movs	r2, #0
 8101dc2:	63da      	str	r2, [r3, #60]	; 0x3c
 8101dc4:	e002      	b.n	8101dcc <hxcmod_fillbuffer+0x304>
							}
						}
						else
							cptr->sampinc = 0;
 8101dc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101dc8:	2200      	movs	r2, #0
 8101dca:	63da      	str	r2, [r3, #60]	; 0x3c

						nptr++;
 8101dcc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8101dce:	3304      	adds	r3, #4
 8101dd0:	62bb      	str	r3, [r7, #40]	; 0x28
						cptr++;
 8101dd2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101dd4:	3364      	adds	r3, #100	; 0x64
 8101dd6:	627b      	str	r3, [r7, #36]	; 0x24
					for(c=0;c<modctx->number_of_channels;c++)
 8101dd8:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8101ddc:	3301      	adds	r3, #1
 8101dde:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
 8101de2:	68fb      	ldr	r3, [r7, #12]
 8101de4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8101de8:	f8b3 3360 	ldrh.w	r3, [r3, #864]	; 0x360
 8101dec:	f8b7 2040 	ldrh.w	r2, [r7, #64]	; 0x40
 8101df0:	429a      	cmp	r2, r3
 8101df2:	d3bc      	bcc.n	8101d6e <hxcmod_fillbuffer+0x2a6>
					}

					modctx->tick_cnt++;
 8101df4:	68fb      	ldr	r3, [r7, #12]
 8101df6:	f8d3 36d8 	ldr.w	r3, [r3, #1752]	; 0x6d8
 8101dfa:	1c5a      	adds	r2, r3, #1
 8101dfc:	68fb      	ldr	r3, [r7, #12]
 8101dfe:	f8c3 26d8 	str.w	r2, [r3, #1752]	; 0x6d8
					modctx->patterntickse = 0;
 8101e02:	68fb      	ldr	r3, [r7, #12]
 8101e04:	2200      	movs	r2, #0
 8101e06:	f8c3 26cc 	str.w	r2, [r3, #1740]	; 0x6cc
				}

				//---------------------------------------

#ifdef HXCMOD_STATE_REPORT_SUPPORT
				if( trkbuf && !state_remaining_steps )
 8101e0a:	683b      	ldr	r3, [r7, #0]
 8101e0c:	2b00      	cmp	r3, #0
 8101e0e:	d019      	beq.n	8101e44 <hxcmod_fillbuffer+0x37c>
 8101e10:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8101e12:	2b00      	cmp	r3, #0
 8101e14:	d116      	bne.n	8101e44 <hxcmod_fillbuffer+0x37c>
				{
					if( trkbuf->nb_of_state < trkbuf->nb_max_of_state )
 8101e16:	683b      	ldr	r3, [r7, #0]
 8101e18:	685a      	ldr	r2, [r3, #4]
 8101e1a:	683b      	ldr	r3, [r7, #0]
 8101e1c:	681b      	ldr	r3, [r3, #0]
 8101e1e:	429a      	cmp	r2, r3
 8101e20:	da10      	bge.n	8101e44 <hxcmod_fillbuffer+0x37c>
					{
						memclear(&trkbuf->track_state_buf[trkbuf->nb_of_state],0,sizeof(tracker_state));
 8101e22:	683b      	ldr	r3, [r7, #0]
 8101e24:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 8101e28:	683b      	ldr	r3, [r7, #0]
 8101e2a:	685b      	ldr	r3, [r3, #4]
 8101e2c:	4619      	mov	r1, r3
 8101e2e:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8101e32:	fb01 f303 	mul.w	r3, r1, r3
 8101e36:	4413      	add	r3, r2
 8101e38:	f44f 72ae 	mov.w	r2, #348	; 0x15c
 8101e3c:	2100      	movs	r1, #0
 8101e3e:	4618      	mov	r0, r3
 8101e40:	f7fe fdb5 	bl	81009ae <memclear>
					}
				}
#endif

#ifndef HXCMOD_MONO_OUTPUT
				l=0;
 8101e44:	2300      	movs	r3, #0
 8101e46:	633b      	str	r3, [r7, #48]	; 0x30
#endif
				r=0;
 8101e48:	2300      	movs	r3, #0
 8101e4a:	62fb      	str	r3, [r7, #44]	; 0x2c

				for( j = 0, cptr = modctx->channels; j < modctx->number_of_channels ; j++, cptr++)
 8101e4c:	2300      	movs	r3, #0
 8101e4e:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
 8101e52:	68fb      	ldr	r3, [r7, #12]
 8101e54:	f503 63dc 	add.w	r3, r3, #1760	; 0x6e0
 8101e58:	627b      	str	r3, [r7, #36]	; 0x24
 8101e5a:	e201      	b.n	8102260 <hxcmod_fillbuffer+0x798>
				{
					if( cptr->period != 0 )
 8101e5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e5e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8101e62:	2b00      	cmp	r3, #0
 8101e64:	f000 81f4 	beq.w	8102250 <hxcmod_fillbuffer+0x788>
					{
						cptr->samppos += cptr->sampinc;
 8101e68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e6a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8101e6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e6e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8101e70:	441a      	add	r2, r3
 8101e72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e74:	639a      	str	r2, [r3, #56]	; 0x38

						if( cptr->replen < 2 )
 8101e76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e78:	891b      	ldrh	r3, [r3, #8]
 8101e7a:	2b01      	cmp	r3, #1
 8101e7c:	d849      	bhi.n	8101f12 <hxcmod_fillbuffer+0x44a>
						{
							if( ( cptr->samppos >> 11) >= cptr->length )
 8101e7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e80:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8101e82:	0adb      	lsrs	r3, r3, #11
 8101e84:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8101e86:	8892      	ldrh	r2, [r2, #4]
 8101e88:	4293      	cmp	r3, r2
 8101e8a:	f0c0 808c 	bcc.w	8101fa6 <hxcmod_fillbuffer+0x4de>
							{
								cptr->length = 0;
 8101e8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e90:	2200      	movs	r2, #0
 8101e92:	809a      	strh	r2, [r3, #4]
								cptr->reppnt = 0;
 8101e94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e96:	2200      	movs	r2, #0
 8101e98:	80da      	strh	r2, [r3, #6]

								if(cptr->update_nxt_repeat)
 8101e9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101e9c:	7d9b      	ldrb	r3, [r3, #22]
 8101e9e:	2b00      	cmp	r3, #0
 8101ea0:	d022      	beq.n	8101ee8 <hxcmod_fillbuffer+0x420>
								{
									cptr->replen = cptr->nxt_replen;
 8101ea2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ea4:	8a9a      	ldrh	r2, [r3, #20]
 8101ea6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ea8:	811a      	strh	r2, [r3, #8]
									cptr->reppnt = cptr->nxt_reppnt;
 8101eaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101eac:	8a5a      	ldrh	r2, [r3, #18]
 8101eae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101eb0:	80da      	strh	r2, [r3, #6]
									cptr->sampdata = cptr->nxt_sampdata;
 8101eb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101eb4:	68da      	ldr	r2, [r3, #12]
 8101eb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101eb8:	601a      	str	r2, [r3, #0]
									cptr->length = cptr->nxt_length;
 8101eba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ebc:	8a1a      	ldrh	r2, [r3, #16]
 8101ebe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ec0:	809a      	strh	r2, [r3, #4]

									cptr->lst_sampdata = cptr->sampdata;
 8101ec2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ec4:	681a      	ldr	r2, [r3, #0]
 8101ec6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ec8:	625a      	str	r2, [r3, #36]	; 0x24
									cptr->lst_length = cptr->length;
 8101eca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ecc:	889a      	ldrh	r2, [r3, #4]
 8101ece:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ed0:	851a      	strh	r2, [r3, #40]	; 0x28
									cptr->lst_reppnt = cptr->reppnt;
 8101ed2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ed4:	88da      	ldrh	r2, [r3, #6]
 8101ed6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ed8:	855a      	strh	r2, [r3, #42]	; 0x2a
									cptr->lst_replen = cptr->replen;
 8101eda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101edc:	891a      	ldrh	r2, [r3, #8]
 8101ede:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ee0:	859a      	strh	r2, [r3, #44]	; 0x2c

									cptr->update_nxt_repeat = 0;
 8101ee2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ee4:	2200      	movs	r2, #0
 8101ee6:	759a      	strb	r2, [r3, #22]
								}

								if( cptr->length )
 8101ee8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101eea:	889b      	ldrh	r3, [r3, #4]
 8101eec:	2b00      	cmp	r3, #0
 8101eee:	d00c      	beq.n	8101f0a <hxcmod_fillbuffer+0x442>
									cptr->samppos = cptr->samppos % (((unsigned long)cptr->length)<<11);
 8101ef0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ef2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8101ef4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8101ef6:	8892      	ldrh	r2, [r2, #4]
 8101ef8:	02d2      	lsls	r2, r2, #11
 8101efa:	fbb3 f1f2 	udiv	r1, r3, r2
 8101efe:	fb01 f202 	mul.w	r2, r1, r2
 8101f02:	1a9a      	subs	r2, r3, r2
 8101f04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f06:	639a      	str	r2, [r3, #56]	; 0x38
 8101f08:	e04d      	b.n	8101fa6 <hxcmod_fillbuffer+0x4de>
								else
									cptr->samppos = 0;
 8101f0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f0c:	2200      	movs	r2, #0
 8101f0e:	639a      	str	r2, [r3, #56]	; 0x38
 8101f10:	e049      	b.n	8101fa6 <hxcmod_fillbuffer+0x4de>
							}
						}
						else
						{
							if( ( cptr->samppos >> 11 ) >= (unsigned long)(cptr->replen+cptr->reppnt) )
 8101f12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f14:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8101f16:	0adb      	lsrs	r3, r3, #11
 8101f18:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8101f1a:	8912      	ldrh	r2, [r2, #8]
 8101f1c:	4611      	mov	r1, r2
 8101f1e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8101f20:	88d2      	ldrh	r2, [r2, #6]
 8101f22:	440a      	add	r2, r1
 8101f24:	4293      	cmp	r3, r2
 8101f26:	d33e      	bcc.n	8101fa6 <hxcmod_fillbuffer+0x4de>
							{
								if( cptr->update_nxt_repeat )
 8101f28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f2a:	7d9b      	ldrb	r3, [r3, #22]
 8101f2c:	2b00      	cmp	r3, #0
 8101f2e:	d022      	beq.n	8101f76 <hxcmod_fillbuffer+0x4ae>
								{
									cptr->replen = cptr->nxt_replen;
 8101f30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f32:	8a9a      	ldrh	r2, [r3, #20]
 8101f34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f36:	811a      	strh	r2, [r3, #8]
									cptr->reppnt = cptr->nxt_reppnt;
 8101f38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f3a:	8a5a      	ldrh	r2, [r3, #18]
 8101f3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f3e:	80da      	strh	r2, [r3, #6]
									cptr->sampdata = cptr->nxt_sampdata;
 8101f40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f42:	68da      	ldr	r2, [r3, #12]
 8101f44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f46:	601a      	str	r2, [r3, #0]
									cptr->length = cptr->nxt_length;
 8101f48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f4a:	8a1a      	ldrh	r2, [r3, #16]
 8101f4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f4e:	809a      	strh	r2, [r3, #4]

									cptr->lst_sampdata = cptr->sampdata;
 8101f50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f52:	681a      	ldr	r2, [r3, #0]
 8101f54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f56:	625a      	str	r2, [r3, #36]	; 0x24
									cptr->lst_length = cptr->length;
 8101f58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f5a:	889a      	ldrh	r2, [r3, #4]
 8101f5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f5e:	851a      	strh	r2, [r3, #40]	; 0x28
									cptr->lst_reppnt = cptr->reppnt;
 8101f60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f62:	88da      	ldrh	r2, [r3, #6]
 8101f64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f66:	855a      	strh	r2, [r3, #42]	; 0x2a
									cptr->lst_replen = cptr->replen;
 8101f68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f6a:	891a      	ldrh	r2, [r3, #8]
 8101f6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f6e:	859a      	strh	r2, [r3, #44]	; 0x2c

									cptr->update_nxt_repeat = 0;
 8101f70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f72:	2200      	movs	r2, #0
 8101f74:	759a      	strb	r2, [r3, #22]
								}

								if( cptr->sampdata )
 8101f76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f78:	681b      	ldr	r3, [r3, #0]
 8101f7a:	2b00      	cmp	r3, #0
 8101f7c:	d013      	beq.n	8101fa6 <hxcmod_fillbuffer+0x4de>
								{
									cptr->samppos = ((unsigned long)(cptr->reppnt)<<11) + (cptr->samppos % ((unsigned long)(cptr->replen+cptr->reppnt)<<11));
 8101f7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f80:	88db      	ldrh	r3, [r3, #6]
 8101f82:	02d9      	lsls	r1, r3, #11
 8101f84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101f86:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8101f88:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8101f8a:	8912      	ldrh	r2, [r2, #8]
 8101f8c:	4610      	mov	r0, r2
 8101f8e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8101f90:	88d2      	ldrh	r2, [r2, #6]
 8101f92:	4402      	add	r2, r0
 8101f94:	02d2      	lsls	r2, r2, #11
 8101f96:	fbb3 f0f2 	udiv	r0, r3, r2
 8101f9a:	fb00 f202 	mul.w	r2, r0, r2
 8101f9e:	1a9b      	subs	r3, r3, r2
 8101fa0:	18ca      	adds	r2, r1, r3
 8101fa2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101fa4:	639a      	str	r2, [r3, #56]	; 0x38
								}
							}
						}

						k = cptr->samppos >> 10;
 8101fa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101fa8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8101faa:	0a9b      	lsrs	r3, r3, #10
 8101fac:	617b      	str	r3, [r7, #20]
#else
							r += ( cptr->sampdata[k] *  cptr->volume );
#endif
						}
#else
						if (cptr->sampdata != 0)
 8101fae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101fb0:	681b      	ldr	r3, [r3, #0]
 8101fb2:	2b00      	cmp	r3, #0
 8101fb4:	d02a      	beq.n	810200c <hxcmod_fillbuffer+0x544>
						{
							if ( !(j & 3) || ((j & 3) == 3) )
 8101fb6:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8101fba:	f003 0303 	and.w	r3, r3, #3
 8101fbe:	2b00      	cmp	r3, #0
 8101fc0:	d005      	beq.n	8101fce <hxcmod_fillbuffer+0x506>
 8101fc2:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8101fc6:	f003 0303 	and.w	r3, r3, #3
 8101fca:	2b03      	cmp	r3, #3
 8101fcc:	d10f      	bne.n	8101fee <hxcmod_fillbuffer+0x526>
							{
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
								l += cptr->volume_table[cptr->sampdata[k]];
#else
								l += (cptr->sampdata[k] * cptr->volume);
 8101fce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101fd0:	681a      	ldr	r2, [r3, #0]
 8101fd2:	697b      	ldr	r3, [r7, #20]
 8101fd4:	4413      	add	r3, r2
 8101fd6:	f993 3000 	ldrsb.w	r3, [r3]
 8101fda:	461a      	mov	r2, r3
 8101fdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101fde:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8101fe2:	fb02 f303 	mul.w	r3, r2, r3
 8101fe6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8101fe8:	4413      	add	r3, r2
 8101fea:	633b      	str	r3, [r7, #48]	; 0x30
 8101fec:	e00e      	b.n	810200c <hxcmod_fillbuffer+0x544>
							else
							{
#ifdef HXCMOD_USE_PRECALC_VOLUME_TABLE
								r += cptr->volume_table[cptr->sampdata[k]];
#else
								r += (cptr->sampdata[k] * cptr->volume);
 8101fee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ff0:	681a      	ldr	r2, [r3, #0]
 8101ff2:	697b      	ldr	r3, [r7, #20]
 8101ff4:	4413      	add	r3, r2
 8101ff6:	f993 3000 	ldrsb.w	r3, [r3]
 8101ffa:	461a      	mov	r2, r3
 8101ffc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8101ffe:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 8102002:	fb02 f303 	mul.w	r3, r2, r3
 8102006:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8102008:	4413      	add	r3, r2
 810200a:	62fb      	str	r3, [r7, #44]	; 0x2c
							}
						}
#endif

#ifdef HXCMOD_STATE_REPORT_SUPPORT
						if( trkbuf && !state_remaining_steps )
 810200c:	683b      	ldr	r3, [r7, #0]
 810200e:	2b00      	cmp	r3, #0
 8102010:	f000 811e 	beq.w	8102250 <hxcmod_fillbuffer+0x788>
 8102014:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8102016:	2b00      	cmp	r3, #0
 8102018:	f040 811a 	bne.w	8102250 <hxcmod_fillbuffer+0x788>
						{
							if( trkbuf->nb_of_state < trkbuf->nb_max_of_state )
 810201c:	683b      	ldr	r3, [r7, #0]
 810201e:	685a      	ldr	r2, [r3, #4]
 8102020:	683b      	ldr	r3, [r7, #0]
 8102022:	681b      	ldr	r3, [r3, #0]
 8102024:	429a      	cmp	r2, r3
 8102026:	f280 8113 	bge.w	8102250 <hxcmod_fillbuffer+0x788>
							{
								trkbuf->track_state_buf[trkbuf->nb_of_state].number_of_tracks = modctx->number_of_channels;
 810202a:	68fb      	ldr	r3, [r7, #12]
 810202c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8102030:	f8b3 1360 	ldrh.w	r1, [r3, #864]	; 0x360
 8102034:	683b      	ldr	r3, [r7, #0]
 8102036:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 810203a:	683b      	ldr	r3, [r7, #0]
 810203c:	685b      	ldr	r3, [r3, #4]
 810203e:	4618      	mov	r0, r3
 8102040:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8102044:	fb00 f303 	mul.w	r3, r0, r3
 8102048:	4413      	add	r3, r2
 810204a:	460a      	mov	r2, r1
 810204c:	601a      	str	r2, [r3, #0]
								trkbuf->track_state_buf[trkbuf->nb_of_state].buf_index = i;
 810204e:	683b      	ldr	r3, [r7, #0]
 8102050:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 8102054:	683b      	ldr	r3, [r7, #0]
 8102056:	685b      	ldr	r3, [r3, #4]
 8102058:	4619      	mov	r1, r3
 810205a:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 810205e:	fb01 f303 	mul.w	r3, r1, r3
 8102062:	4413      	add	r3, r2
 8102064:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8102066:	619a      	str	r2, [r3, #24]
								trkbuf->track_state_buf[trkbuf->nb_of_state].cur_pattern = modctx->song.patterntable[modctx->tablepos];
 8102068:	68fb      	ldr	r3, [r7, #12]
 810206a:	f8b3 36c0 	ldrh.w	r3, [r3, #1728]	; 0x6c0
 810206e:	461a      	mov	r2, r3
 8102070:	68fb      	ldr	r3, [r7, #12]
 8102072:	4413      	add	r3, r2
 8102074:	f893 13b8 	ldrb.w	r1, [r3, #952]	; 0x3b8
 8102078:	683b      	ldr	r3, [r7, #0]
 810207a:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 810207e:	683b      	ldr	r3, [r7, #0]
 8102080:	685b      	ldr	r3, [r3, #4]
 8102082:	4618      	mov	r0, r3
 8102084:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8102088:	fb00 f303 	mul.w	r3, r0, r3
 810208c:	4413      	add	r3, r2
 810208e:	460a      	mov	r2, r1
 8102090:	60da      	str	r2, [r3, #12]
								trkbuf->track_state_buf[trkbuf->nb_of_state].cur_pattern_pos = modctx->patternpos / modctx->number_of_channels;
 8102092:	68fb      	ldr	r3, [r7, #12]
 8102094:	f8b3 26c2 	ldrh.w	r2, [r3, #1730]	; 0x6c2
 8102098:	68fb      	ldr	r3, [r7, #12]
 810209a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 810209e:	f8b3 3360 	ldrh.w	r3, [r3, #864]	; 0x360
 81020a2:	fbb2 f3f3 	udiv	r3, r2, r3
 81020a6:	b299      	uxth	r1, r3
 81020a8:	683b      	ldr	r3, [r7, #0]
 81020aa:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 81020ae:	683b      	ldr	r3, [r7, #0]
 81020b0:	685b      	ldr	r3, [r3, #4]
 81020b2:	4618      	mov	r0, r3
 81020b4:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 81020b8:	fb00 f303 	mul.w	r3, r0, r3
 81020bc:	4413      	add	r3, r2
 81020be:	460a      	mov	r2, r1
 81020c0:	611a      	str	r2, [r3, #16]
								trkbuf->track_state_buf[trkbuf->nb_of_state].cur_pattern_table_pos = modctx->tablepos;
 81020c2:	68fb      	ldr	r3, [r7, #12]
 81020c4:	f8b3 16c0 	ldrh.w	r1, [r3, #1728]	; 0x6c0
 81020c8:	683b      	ldr	r3, [r7, #0]
 81020ca:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 81020ce:	683b      	ldr	r3, [r7, #0]
 81020d0:	685b      	ldr	r3, [r3, #4]
 81020d2:	4618      	mov	r0, r3
 81020d4:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 81020d8:	fb00 f303 	mul.w	r3, r0, r3
 81020dc:	4413      	add	r3, r2
 81020de:	460a      	mov	r2, r1
 81020e0:	615a      	str	r2, [r3, #20]
								trkbuf->track_state_buf[trkbuf->nb_of_state].bpm = modctx->bpm;
 81020e2:	68fb      	ldr	r3, [r7, #12]
 81020e4:	f893 16c7 	ldrb.w	r1, [r3, #1735]	; 0x6c7
 81020e8:	683b      	ldr	r3, [r7, #0]
 81020ea:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 81020ee:	683b      	ldr	r3, [r7, #0]
 81020f0:	685b      	ldr	r3, [r3, #4]
 81020f2:	4618      	mov	r0, r3
 81020f4:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 81020f8:	fb00 f303 	mul.w	r3, r0, r3
 81020fc:	4413      	add	r3, r2
 81020fe:	460a      	mov	r2, r1
 8102100:	605a      	str	r2, [r3, #4]
								trkbuf->track_state_buf[trkbuf->nb_of_state].speed = modctx->song.speed;
 8102102:	68fb      	ldr	r3, [r7, #12]
 8102104:	f893 143c 	ldrb.w	r1, [r3, #1084]	; 0x43c
 8102108:	683b      	ldr	r3, [r7, #0]
 810210a:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 810210e:	683b      	ldr	r3, [r7, #0]
 8102110:	685b      	ldr	r3, [r3, #4]
 8102112:	4618      	mov	r0, r3
 8102114:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8102118:	fb00 f303 	mul.w	r3, r0, r3
 810211c:	4413      	add	r3, r2
 810211e:	460a      	mov	r2, r1
 8102120:	609a      	str	r2, [r3, #8]
								trkbuf->track_state_buf[trkbuf->nb_of_state].tracks[j].cur_effect = cptr->effect_code;
 8102122:	683b      	ldr	r3, [r7, #0]
 8102124:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 8102128:	683b      	ldr	r3, [r7, #0]
 810212a:	685b      	ldr	r3, [r3, #4]
 810212c:	4619      	mov	r1, r3
 810212e:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8102132:	fb01 f303 	mul.w	r3, r1, r3
 8102136:	18d1      	adds	r1, r2, r3
 8102138:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 810213c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810213e:	f8b3 0046 	ldrh.w	r0, [r3, #70]	; 0x46
 8102142:	4613      	mov	r3, r2
 8102144:	009b      	lsls	r3, r3, #2
 8102146:	4413      	add	r3, r2
 8102148:	005b      	lsls	r3, r3, #1
 810214a:	440b      	add	r3, r1
 810214c:	3322      	adds	r3, #34	; 0x22
 810214e:	4602      	mov	r2, r0
 8102150:	801a      	strh	r2, [r3, #0]
								trkbuf->track_state_buf[trkbuf->nb_of_state].tracks[j].cur_parameffect = cptr->parameffect;
 8102152:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8102154:	f893 0044 	ldrb.w	r0, [r3, #68]	; 0x44
 8102158:	683b      	ldr	r3, [r7, #0]
 810215a:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 810215e:	683b      	ldr	r3, [r7, #0]
 8102160:	685b      	ldr	r3, [r3, #4]
 8102162:	4619      	mov	r1, r3
 8102164:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8102168:	fb01 f303 	mul.w	r3, r1, r3
 810216c:	18d1      	adds	r1, r2, r3
 810216e:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 8102172:	b280      	uxth	r0, r0
 8102174:	4613      	mov	r3, r2
 8102176:	009b      	lsls	r3, r3, #2
 8102178:	4413      	add	r3, r2
 810217a:	005b      	lsls	r3, r3, #1
 810217c:	440b      	add	r3, r1
 810217e:	3324      	adds	r3, #36	; 0x24
 8102180:	4602      	mov	r2, r0
 8102182:	801a      	strh	r2, [r3, #0]
								if(cptr->sampinc)
 8102184:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8102186:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8102188:	2b00      	cmp	r3, #0
 810218a:	d01d      	beq.n	81021c8 <hxcmod_fillbuffer+0x700>
									trkbuf->track_state_buf[trkbuf->nb_of_state].tracks[j].cur_period = (muint)(modctx->sampleticksconst / cptr->sampinc);
 810218c:	68fb      	ldr	r3, [r7, #12]
 810218e:	f8d3 26dc 	ldr.w	r2, [r3, #1756]	; 0x6dc
 8102192:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8102194:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8102196:	fbb2 f0f3 	udiv	r0, r2, r3
 810219a:	683b      	ldr	r3, [r7, #0]
 810219c:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 81021a0:	683b      	ldr	r3, [r7, #0]
 81021a2:	685b      	ldr	r3, [r3, #4]
 81021a4:	4619      	mov	r1, r3
 81021a6:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 81021aa:	fb01 f303 	mul.w	r3, r1, r3
 81021ae:	18d1      	adds	r1, r2, r3
 81021b0:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 81021b4:	b280      	uxth	r0, r0
 81021b6:	4613      	mov	r3, r2
 81021b8:	009b      	lsls	r3, r3, #2
 81021ba:	4413      	add	r3, r2
 81021bc:	005b      	lsls	r3, r3, #1
 81021be:	440b      	add	r3, r1
 81021c0:	331e      	adds	r3, #30
 81021c2:	4602      	mov	r2, r0
 81021c4:	801a      	strh	r2, [r3, #0]
 81021c6:	e014      	b.n	81021f2 <hxcmod_fillbuffer+0x72a>
								else
									trkbuf->track_state_buf[trkbuf->nb_of_state].tracks[j].cur_period = 0;
 81021c8:	683b      	ldr	r3, [r7, #0]
 81021ca:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 81021ce:	683b      	ldr	r3, [r7, #0]
 81021d0:	685b      	ldr	r3, [r3, #4]
 81021d2:	4619      	mov	r1, r3
 81021d4:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 81021d8:	fb01 f303 	mul.w	r3, r1, r3
 81021dc:	18d1      	adds	r1, r2, r3
 81021de:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 81021e2:	4613      	mov	r3, r2
 81021e4:	009b      	lsls	r3, r3, #2
 81021e6:	4413      	add	r3, r2
 81021e8:	005b      	lsls	r3, r3, #1
 81021ea:	440b      	add	r3, r1
 81021ec:	331e      	adds	r3, #30
 81021ee:	2200      	movs	r2, #0
 81021f0:	801a      	strh	r2, [r3, #0]
								trkbuf->track_state_buf[trkbuf->nb_of_state].tracks[j].cur_volume = cptr->volume;
 81021f2:	683b      	ldr	r3, [r7, #0]
 81021f4:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 81021f8:	683b      	ldr	r3, [r7, #0]
 81021fa:	685b      	ldr	r3, [r3, #4]
 81021fc:	4619      	mov	r1, r3
 81021fe:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8102202:	fb01 f303 	mul.w	r3, r1, r3
 8102206:	18d1      	adds	r1, r2, r3
 8102208:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 810220c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810220e:	f893 0042 	ldrb.w	r0, [r3, #66]	; 0x42
 8102212:	4613      	mov	r3, r2
 8102214:	009b      	lsls	r3, r3, #2
 8102216:	4413      	add	r3, r2
 8102218:	005b      	lsls	r3, r3, #1
 810221a:	440b      	add	r3, r1
 810221c:	3320      	adds	r3, #32
 810221e:	4602      	mov	r2, r0
 8102220:	701a      	strb	r2, [r3, #0]
								trkbuf->track_state_buf[trkbuf->nb_of_state].tracks[j].instrument_number = (unsigned char)cptr->sampnum;
 8102222:	683b      	ldr	r3, [r7, #0]
 8102224:	f8d3 23b4 	ldr.w	r2, [r3, #948]	; 0x3b4
 8102228:	683b      	ldr	r3, [r7, #0]
 810222a:	685b      	ldr	r3, [r3, #4]
 810222c:	4619      	mov	r1, r3
 810222e:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 8102232:	fb01 f303 	mul.w	r3, r1, r3
 8102236:	18d1      	adds	r1, r2, r3
 8102238:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 810223c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810223e:	7a98      	ldrb	r0, [r3, #10]
 8102240:	4613      	mov	r3, r2
 8102242:	009b      	lsls	r3, r3, #2
 8102244:	4413      	add	r3, r2
 8102246:	005b      	lsls	r3, r3, #1
 8102248:	440b      	add	r3, r1
 810224a:	331c      	adds	r3, #28
 810224c:	4602      	mov	r2, r0
 810224e:	701a      	strb	r2, [r3, #0]
				for( j = 0, cptr = modctx->channels; j < modctx->number_of_channels ; j++, cptr++)
 8102250:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 8102254:	3301      	adds	r3, #1
 8102256:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
 810225a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810225c:	3364      	adds	r3, #100	; 0x64
 810225e:	627b      	str	r3, [r7, #36]	; 0x24
 8102260:	68fb      	ldr	r3, [r7, #12]
 8102262:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8102266:	f8b3 3360 	ldrh.w	r3, [r3, #864]	; 0x360
 810226a:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 810226e:	429a      	cmp	r2, r3
 8102270:	f4ff adf4 	bcc.w	8101e5c <hxcmod_fillbuffer+0x394>
#endif
					}
				}

#ifdef HXCMOD_STATE_REPORT_SUPPORT
				if( trkbuf && !state_remaining_steps )
 8102274:	683b      	ldr	r3, [r7, #0]
 8102276:	2b00      	cmp	r3, #0
 8102278:	d011      	beq.n	810229e <hxcmod_fillbuffer+0x7d6>
 810227a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 810227c:	2b00      	cmp	r3, #0
 810227e:	d10e      	bne.n	810229e <hxcmod_fillbuffer+0x7d6>
				{
					state_remaining_steps = trkbuf->sample_step;
 8102280:	683b      	ldr	r3, [r7, #0]
 8102282:	68db      	ldr	r3, [r3, #12]
 8102284:	63fb      	str	r3, [r7, #60]	; 0x3c

					if(trkbuf->nb_of_state < trkbuf->nb_max_of_state)
 8102286:	683b      	ldr	r3, [r7, #0]
 8102288:	685a      	ldr	r2, [r3, #4]
 810228a:	683b      	ldr	r3, [r7, #0]
 810228c:	681b      	ldr	r3, [r3, #0]
 810228e:	429a      	cmp	r2, r3
 8102290:	da08      	bge.n	81022a4 <hxcmod_fillbuffer+0x7dc>
						trkbuf->nb_of_state++;
 8102292:	683b      	ldr	r3, [r7, #0]
 8102294:	685b      	ldr	r3, [r3, #4]
 8102296:	1c5a      	adds	r2, r3, #1
 8102298:	683b      	ldr	r3, [r7, #0]
 810229a:	605a      	str	r2, [r3, #4]
					if(trkbuf->nb_of_state < trkbuf->nb_max_of_state)
 810229c:	e002      	b.n	81022a4 <hxcmod_fillbuffer+0x7dc>
				}
				else
#endif
				{
					state_remaining_steps--;
 810229e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81022a0:	3b01      	subs	r3, #1
 81022a2:	63fb      	str	r3, [r7, #60]	; 0x3c
	#endif

#else

	#ifdef HXCMOD_OUTPUT_FILTER
				tl = (short)l;
 81022a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81022a6:	b21b      	sxth	r3, r3
 81022a8:	61fb      	str	r3, [r7, #28]
				tr = (short)r;
 81022aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81022ac:	b21b      	sxth	r3, r3
 81022ae:	61bb      	str	r3, [r7, #24]

				if ( modctx->filter )
 81022b0:	68fb      	ldr	r3, [r7, #12]
 81022b2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81022b6:	f9b3 336e 	ldrsh.w	r3, [r3, #878]	; 0x36e
 81022ba:	2b00      	cmp	r3, #0
 81022bc:	d009      	beq.n	81022d2 <hxcmod_fillbuffer+0x80a>
				{
					// Filter
					l = (l+ll)>>1;
 81022be:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 81022c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 81022c2:	4413      	add	r3, r2
 81022c4:	105b      	asrs	r3, r3, #1
 81022c6:	633b      	str	r3, [r7, #48]	; 0x30
					r = (r+lr)>>1;
 81022c8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 81022ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 81022cc:	4413      	add	r3, r2
 81022ce:	105b      	asrs	r3, r3, #1
 81022d0:	62fb      	str	r3, [r7, #44]	; 0x2c
				}
	#endif

	#ifdef HXCMOD_OUTPUT_STEREO_MIX
				if ( modctx->stereo_separation == 1 )
 81022d2:	68fb      	ldr	r3, [r7, #12]
 81022d4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 81022d8:	f9b3 336a 	ldrsh.w	r3, [r3, #874]	; 0x36a
 81022dc:	2b01      	cmp	r3, #1
 81022de:	d109      	bne.n	81022f4 <hxcmod_fillbuffer+0x82c>
				{
					// Left & Right Stereo panning
					l = (l+(r>>1));
 81022e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 81022e2:	105b      	asrs	r3, r3, #1
 81022e4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 81022e6:	4413      	add	r3, r2
 81022e8:	633b      	str	r3, [r7, #48]	; 0x30
					r = (r+(l>>1));
 81022ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81022ec:	105b      	asrs	r3, r3, #1
 81022ee:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 81022f0:	4413      	add	r3, r2
 81022f2:	62fb      	str	r3, [r7, #44]	; 0x2c
				}
	#endif

	#ifdef HXCMOD_CLIPPING_CHECK
				// Level limitation
				if( l > 32767 ) l = 32767;
 81022f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 81022f6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 81022fa:	db02      	blt.n	8102302 <hxcmod_fillbuffer+0x83a>
 81022fc:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8102300:	633b      	str	r3, [r7, #48]	; 0x30
				if( l < -32768 ) l = -32768;
 8102302:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8102304:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8102308:	da01      	bge.n	810230e <hxcmod_fillbuffer+0x846>
 810230a:	4b38      	ldr	r3, [pc, #224]	; (81023ec <hxcmod_fillbuffer+0x924>)
 810230c:	633b      	str	r3, [r7, #48]	; 0x30
				if( r > 32767 ) r = 32767;
 810230e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8102310:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8102314:	db02      	blt.n	810231c <hxcmod_fillbuffer+0x854>
 8102316:	f647 73ff 	movw	r3, #32767	; 0x7fff
 810231a:	62fb      	str	r3, [r7, #44]	; 0x2c
				if( r < -32768 ) r = -32768;
 810231c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 810231e:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8102322:	da01      	bge.n	8102328 <hxcmod_fillbuffer+0x860>
 8102324:	4b31      	ldr	r3, [pc, #196]	; (81023ec <hxcmod_fillbuffer+0x924>)
 8102326:	62fb      	str	r3, [r7, #44]	; 0x2c

		#ifdef HXCMOD_UNSIGNED_OUTPUT
				*outbuffer++ = l + 32767;
				*outbuffer++ = r + 32767;
		#else
				*outbuffer++ = l;
 8102328:	68bb      	ldr	r3, [r7, #8]
 810232a:	1c9a      	adds	r2, r3, #2
 810232c:	60ba      	str	r2, [r7, #8]
 810232e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8102330:	b212      	sxth	r2, r2
 8102332:	801a      	strh	r2, [r3, #0]
				*outbuffer++ = r;
 8102334:	68bb      	ldr	r3, [r7, #8]
 8102336:	1c9a      	adds	r2, r3, #2
 8102338:	60ba      	str	r2, [r7, #8]
 810233a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 810233c:	b212      	sxth	r2, r2
 810233e:	801a      	strh	r2, [r3, #0]
		#endif

	#endif

	#ifdef HXCMOD_OUTPUT_FILTER
				ll = tl;
 8102340:	69fb      	ldr	r3, [r7, #28]
 8102342:	63bb      	str	r3, [r7, #56]	; 0x38
				lr = tr;
 8102344:	69bb      	ldr	r3, [r7, #24]
 8102346:	637b      	str	r3, [r7, #52]	; 0x34
			for (i = 0; i < nbsample; i++)
 8102348:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 810234a:	3301      	adds	r3, #1
 810234c:	647b      	str	r3, [r7, #68]	; 0x44
 810234e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8102350:	687b      	ldr	r3, [r7, #4]
 8102352:	429a      	cmp	r2, r3
 8102354:	f4ff ac0b 	bcc.w	8101b6e <hxcmod_fillbuffer+0xa6>

			}

#ifdef HXCMOD_OUTPUT_FILTER
	#ifndef HXCMOD_MONO_OUTPUT
			modctx->last_l_sample = ll;
 8102358:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810235a:	b21a      	sxth	r2, r3
 810235c:	68fb      	ldr	r3, [r7, #12]
 810235e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8102362:	f8a3 2366 	strh.w	r2, [r3, #870]	; 0x366
	#endif
			modctx->last_r_sample = lr;
 8102366:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8102368:	b21a      	sxth	r2, r3
 810236a:	68fb      	ldr	r3, [r7, #12]
 810236c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8102370:	f8a3 2364 	strh.w	r2, [r3, #868]	; 0x364
				memclear(trkbuf->instruments,0,sizeof(trkbuf->instruments));
			}
#endif
		}
	}
}
 8102374:	e035      	b.n	81023e2 <hxcmod_fillbuffer+0x91a>
			for (i = 0; i < nbsample; i++)
 8102376:	2300      	movs	r3, #0
 8102378:	647b      	str	r3, [r7, #68]	; 0x44
 810237a:	e00c      	b.n	8102396 <hxcmod_fillbuffer+0x8ce>
				*outbuffer++ = 0;
 810237c:	68bb      	ldr	r3, [r7, #8]
 810237e:	1c9a      	adds	r2, r3, #2
 8102380:	60ba      	str	r2, [r7, #8]
 8102382:	2200      	movs	r2, #0
 8102384:	801a      	strh	r2, [r3, #0]
				*outbuffer++ = 0;
 8102386:	68bb      	ldr	r3, [r7, #8]
 8102388:	1c9a      	adds	r2, r3, #2
 810238a:	60ba      	str	r2, [r7, #8]
 810238c:	2200      	movs	r2, #0
 810238e:	801a      	strh	r2, [r3, #0]
			for (i = 0; i < nbsample; i++)
 8102390:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8102392:	3301      	adds	r3, #1
 8102394:	647b      	str	r3, [r7, #68]	; 0x44
 8102396:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8102398:	687b      	ldr	r3, [r7, #4]
 810239a:	429a      	cmp	r2, r3
 810239c:	d3ee      	bcc.n	810237c <hxcmod_fillbuffer+0x8b4>
			if(trkbuf)
 810239e:	683b      	ldr	r3, [r7, #0]
 81023a0:	2b00      	cmp	r3, #0
 81023a2:	d01e      	beq.n	81023e2 <hxcmod_fillbuffer+0x91a>
				trkbuf->nb_of_state = 0;
 81023a4:	683b      	ldr	r3, [r7, #0]
 81023a6:	2200      	movs	r2, #0
 81023a8:	605a      	str	r2, [r3, #4]
				trkbuf->cur_rd_index = 0;
 81023aa:	683b      	ldr	r3, [r7, #0]
 81023ac:	2200      	movs	r2, #0
 81023ae:	609a      	str	r2, [r3, #8]
				trkbuf->name[0] = 0;
 81023b0:	683b      	ldr	r3, [r7, #0]
 81023b2:	2200      	movs	r2, #0
 81023b4:	741a      	strb	r2, [r3, #16]
				memclear(trkbuf->track_state_buf,0,sizeof(tracker_state) * trkbuf->nb_max_of_state);
 81023b6:	683b      	ldr	r3, [r7, #0]
 81023b8:	f8d3 03b4 	ldr.w	r0, [r3, #948]	; 0x3b4
 81023bc:	683b      	ldr	r3, [r7, #0]
 81023be:	681b      	ldr	r3, [r3, #0]
 81023c0:	461a      	mov	r2, r3
 81023c2:	f44f 73ae 	mov.w	r3, #348	; 0x15c
 81023c6:	fb02 f303 	mul.w	r3, r2, r3
 81023ca:	461a      	mov	r2, r3
 81023cc:	2100      	movs	r1, #0
 81023ce:	f7fe faee 	bl	81009ae <memclear>
				memclear(trkbuf->instruments,0,sizeof(trkbuf->instruments));
 81023d2:	683b      	ldr	r3, [r7, #0]
 81023d4:	3350      	adds	r3, #80	; 0x50
 81023d6:	f44f 7259 	mov.w	r2, #868	; 0x364
 81023da:	2100      	movs	r1, #0
 81023dc:	4618      	mov	r0, r3
 81023de:	f7fe fae6 	bl	81009ae <memclear>
}
 81023e2:	bf00      	nop
 81023e4:	3748      	adds	r7, #72	; 0x48
 81023e6:	46bd      	mov	sp, r7
 81023e8:	bd80      	pop	{r7, pc}
 81023ea:	bf00      	nop
 81023ec:	ffff8000 	.word	0xffff8000

081023f0 <BDMA_Stream_IRQHandler>:

	return BSP_OK;
}


void BDMA_Stream_IRQHandler(TxRxContext_TypeDef * ctx) {
 81023f0:	b480      	push	{r7}
 81023f2:	b087      	sub	sp, #28
 81023f4:	af00      	add	r7, sp, #0
 81023f6:	6078      	str	r0, [r7, #4]
	BDMA_Base_Registers  *regs_bdma  = (BDMA_Base_Registers *)ctx->dma_baseregs;
 81023f8:	687b      	ldr	r3, [r7, #4]
 81023fa:	68db      	ldr	r3, [r3, #12]
 81023fc:	617b      	str	r3, [r7, #20]
	BDMA_Channel_TypeDef *regs_bdma_channel = (BDMA_Channel_TypeDef *)ctx->dma_stream;
 81023fe:	687b      	ldr	r3, [r7, #4]
 8102400:	685b      	ldr	r3, [r3, #4]
 8102402:	613b      	str	r3, [r7, #16]
	uint32_t ccr_reg = regs_bdma_channel->CCR;
 8102404:	693b      	ldr	r3, [r7, #16]
 8102406:	681b      	ldr	r3, [r3, #0]
 8102408:	60fb      	str	r3, [r7, #12]

	// Half Transfer Complete Interrupt management ******************************
    if (((regs_bdma->ISR & (BDMA_FLAG_HT0 << (ctx->dma_index & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U)) {
 810240a:	697b      	ldr	r3, [r7, #20]
 810240c:	681a      	ldr	r2, [r3, #0]
 810240e:	687b      	ldr	r3, [r7, #4]
 8102410:	689b      	ldr	r3, [r3, #8]
 8102412:	f003 031f 	and.w	r3, r3, #31
 8102416:	2104      	movs	r1, #4
 8102418:	fa01 f303 	lsl.w	r3, r1, r3
 810241c:	4013      	ands	r3, r2
 810241e:	2b00      	cmp	r3, #0
 8102420:	d017      	beq.n	8102452 <BDMA_Stream_IRQHandler+0x62>
 8102422:	68fb      	ldr	r3, [r7, #12]
 8102424:	f003 0304 	and.w	r3, r3, #4
 8102428:	2b00      	cmp	r3, #0
 810242a:	d012      	beq.n	8102452 <BDMA_Stream_IRQHandler+0x62>

      // Clear the half transfer complete flag
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (ctx->dma_index & 0x1FU));
 810242c:	687b      	ldr	r3, [r7, #4]
 810242e:	689b      	ldr	r3, [r3, #8]
 8102430:	f003 031f 	and.w	r3, r3, #31
 8102434:	2204      	movs	r2, #4
 8102436:	409a      	lsls	r2, r3
 8102438:	697b      	ldr	r3, [r7, #20]
 810243a:	605a      	str	r2, [r3, #4]

      // Disable the half transfer interrupt if the BDMA mode is not CIRCULAR
      if((ccr_reg & BDMA_CCR_CIRC) == 0U) regs_bdma_channel->CCR &= ~(BDMA_CCR_HTIE);
 810243c:	68fb      	ldr	r3, [r7, #12]
 810243e:	f003 0320 	and.w	r3, r3, #32
 8102442:	2b00      	cmp	r3, #0
 8102444:	d105      	bne.n	8102452 <BDMA_Stream_IRQHandler+0x62>
 8102446:	693b      	ldr	r3, [r7, #16]
 8102448:	681b      	ldr	r3, [r3, #0]
 810244a:	f023 0204 	bic.w	r2, r3, #4
 810244e:	693b      	ldr	r3, [r7, #16]
 8102450:	601a      	str	r2, [r3, #0]
      // TODO: HALF TRANSFER CALLBACK

    }

	// Transfer Complete Interrupt management ***********************************
    if (((regs_bdma->ISR & (BDMA_FLAG_TC0 << (ctx->dma_index & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U)) {
 8102452:	697b      	ldr	r3, [r7, #20]
 8102454:	681a      	ldr	r2, [r3, #0]
 8102456:	687b      	ldr	r3, [r7, #4]
 8102458:	689b      	ldr	r3, [r3, #8]
 810245a:	f003 031f 	and.w	r3, r3, #31
 810245e:	2102      	movs	r1, #2
 8102460:	fa01 f303 	lsl.w	r3, r1, r3
 8102464:	4013      	ands	r3, r2
 8102466:	2b00      	cmp	r3, #0
 8102468:	d017      	beq.n	810249a <BDMA_Stream_IRQHandler+0xaa>
 810246a:	68fb      	ldr	r3, [r7, #12]
 810246c:	f003 0302 	and.w	r3, r3, #2
 8102470:	2b00      	cmp	r3, #0
 8102472:	d012      	beq.n	810249a <BDMA_Stream_IRQHandler+0xaa>

      // Clear the transfer complete flag
      regs_bdma->IFCR = (BDMA_ISR_TCIF0 << (ctx->dma_index & 0x1FU));
 8102474:	687b      	ldr	r3, [r7, #4]
 8102476:	689b      	ldr	r3, [r3, #8]
 8102478:	f003 031f 	and.w	r3, r3, #31
 810247c:	2202      	movs	r2, #2
 810247e:	409a      	lsls	r2, r3
 8102480:	697b      	ldr	r3, [r7, #20]
 8102482:	605a      	str	r2, [r3, #4]

      // Disable the transfer complete interrupt if the BDMA mode is not CIRCULAR
      if((ccr_reg & BDMA_CCR_CIRC) == 0U) regs_bdma_channel->CCR &= ~(BDMA_CCR_TCIE);
 8102484:	68fb      	ldr	r3, [r7, #12]
 8102486:	f003 0320 	and.w	r3, r3, #32
 810248a:	2b00      	cmp	r3, #0
 810248c:	d105      	bne.n	810249a <BDMA_Stream_IRQHandler+0xaa>
 810248e:	693b      	ldr	r3, [r7, #16]
 8102490:	681b      	ldr	r3, [r3, #0]
 8102492:	f023 0202 	bic.w	r2, r3, #2
 8102496:	693b      	ldr	r3, [r7, #16]
 8102498:	601a      	str	r2, [r3, #0]
      // TODO: HALF TRANSFER CALLBACK

    }

	// Transfer Error Interrupt management **************************************
    if (((regs_bdma->ISR & (BDMA_FLAG_TE0 << (ctx->dma_index & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U)) {
 810249a:	697b      	ldr	r3, [r7, #20]
 810249c:	681a      	ldr	r2, [r3, #0]
 810249e:	687b      	ldr	r3, [r7, #4]
 81024a0:	689b      	ldr	r3, [r3, #8]
 81024a2:	f003 031f 	and.w	r3, r3, #31
 81024a6:	2108      	movs	r1, #8
 81024a8:	fa01 f303 	lsl.w	r3, r1, r3
 81024ac:	4013      	ands	r3, r2
 81024ae:	2b00      	cmp	r3, #0
 81024b0:	d012      	beq.n	81024d8 <BDMA_Stream_IRQHandler+0xe8>
 81024b2:	68fb      	ldr	r3, [r7, #12]
 81024b4:	f003 0308 	and.w	r3, r3, #8
 81024b8:	2b00      	cmp	r3, #0
 81024ba:	d00d      	beq.n	81024d8 <BDMA_Stream_IRQHandler+0xe8>

    	// Disable all interrupts
    	regs_bdma_channel->CCR &= ~(BDMA_CCR_TCIE | BDMA_CCR_TEIE | BDMA_CCR_HTIE );
 81024bc:	693b      	ldr	r3, [r7, #16]
 81024be:	681b      	ldr	r3, [r3, #0]
 81024c0:	f023 020e 	bic.w	r2, r3, #14
 81024c4:	693b      	ldr	r3, [r7, #16]
 81024c6:	601a      	str	r2, [r3, #0]

    	// Clear all flags
    	regs_bdma->IFCR = (BDMA_ISR_GIF0) << (ctx->dma_index & 0x1FU);
 81024c8:	687b      	ldr	r3, [r7, #4]
 81024ca:	689b      	ldr	r3, [r3, #8]
 81024cc:	f003 031f 	and.w	r3, r3, #31
 81024d0:	2201      	movs	r2, #1
 81024d2:	409a      	lsls	r2, r3
 81024d4:	697b      	ldr	r3, [r7, #20]
 81024d6:	605a      	str	r2, [r3, #4]
    }


}
 81024d8:	bf00      	nop
 81024da:	371c      	adds	r7, #28
 81024dc:	46bd      	mov	sp, r7
 81024de:	f85d 7b04 	ldr.w	r7, [sp], #4
 81024e2:	4770      	bx	lr

081024e4 <BDMA_Channel0_IRQHandler>:


void BDMA_Channel0_IRQHandler() {
 81024e4:	b580      	push	{r7, lr}
 81024e6:	af00      	add	r7, sp, #0
	if (BDMACTXvectors[0x00]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x00]));
 81024e8:	4b05      	ldr	r3, [pc, #20]	; (8102500 <BDMA_Channel0_IRQHandler+0x1c>)
 81024ea:	681b      	ldr	r3, [r3, #0]
 81024ec:	2b00      	cmp	r3, #0
 81024ee:	d004      	beq.n	81024fa <BDMA_Channel0_IRQHandler+0x16>
 81024f0:	4b03      	ldr	r3, [pc, #12]	; (8102500 <BDMA_Channel0_IRQHandler+0x1c>)
 81024f2:	681b      	ldr	r3, [r3, #0]
 81024f4:	4618      	mov	r0, r3
 81024f6:	f7ff ff7b 	bl	81023f0 <BDMA_Stream_IRQHandler>
}
 81024fa:	bf00      	nop
 81024fc:	bd80      	pop	{r7, pc}
 81024fe:	bf00      	nop
 8102500:	10003444 	.word	0x10003444

08102504 <BDMA_Channel1_IRQHandler>:
void BDMA_Channel1_IRQHandler() { if (BDMACTXvectors[0x01]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x01])); }
 8102504:	b580      	push	{r7, lr}
 8102506:	af00      	add	r7, sp, #0
 8102508:	4b05      	ldr	r3, [pc, #20]	; (8102520 <BDMA_Channel1_IRQHandler+0x1c>)
 810250a:	685b      	ldr	r3, [r3, #4]
 810250c:	2b00      	cmp	r3, #0
 810250e:	d004      	beq.n	810251a <BDMA_Channel1_IRQHandler+0x16>
 8102510:	4b03      	ldr	r3, [pc, #12]	; (8102520 <BDMA_Channel1_IRQHandler+0x1c>)
 8102512:	685b      	ldr	r3, [r3, #4]
 8102514:	4618      	mov	r0, r3
 8102516:	f7ff ff6b 	bl	81023f0 <BDMA_Stream_IRQHandler>
 810251a:	bf00      	nop
 810251c:	bd80      	pop	{r7, pc}
 810251e:	bf00      	nop
 8102520:	10003444 	.word	0x10003444

08102524 <BDMA_Channel2_IRQHandler>:
void BDMA_Channel2_IRQHandler() { if (BDMACTXvectors[0x02]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x02])); }
 8102524:	b580      	push	{r7, lr}
 8102526:	af00      	add	r7, sp, #0
 8102528:	4b05      	ldr	r3, [pc, #20]	; (8102540 <BDMA_Channel2_IRQHandler+0x1c>)
 810252a:	689b      	ldr	r3, [r3, #8]
 810252c:	2b00      	cmp	r3, #0
 810252e:	d004      	beq.n	810253a <BDMA_Channel2_IRQHandler+0x16>
 8102530:	4b03      	ldr	r3, [pc, #12]	; (8102540 <BDMA_Channel2_IRQHandler+0x1c>)
 8102532:	689b      	ldr	r3, [r3, #8]
 8102534:	4618      	mov	r0, r3
 8102536:	f7ff ff5b 	bl	81023f0 <BDMA_Stream_IRQHandler>
 810253a:	bf00      	nop
 810253c:	bd80      	pop	{r7, pc}
 810253e:	bf00      	nop
 8102540:	10003444 	.word	0x10003444

08102544 <BDMA_Channel3_IRQHandler>:
void BDMA_Channel3_IRQHandler() { if (BDMACTXvectors[0x03]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x03])); }
 8102544:	b580      	push	{r7, lr}
 8102546:	af00      	add	r7, sp, #0
 8102548:	4b05      	ldr	r3, [pc, #20]	; (8102560 <BDMA_Channel3_IRQHandler+0x1c>)
 810254a:	68db      	ldr	r3, [r3, #12]
 810254c:	2b00      	cmp	r3, #0
 810254e:	d004      	beq.n	810255a <BDMA_Channel3_IRQHandler+0x16>
 8102550:	4b03      	ldr	r3, [pc, #12]	; (8102560 <BDMA_Channel3_IRQHandler+0x1c>)
 8102552:	68db      	ldr	r3, [r3, #12]
 8102554:	4618      	mov	r0, r3
 8102556:	f7ff ff4b 	bl	81023f0 <BDMA_Stream_IRQHandler>
 810255a:	bf00      	nop
 810255c:	bd80      	pop	{r7, pc}
 810255e:	bf00      	nop
 8102560:	10003444 	.word	0x10003444

08102564 <BDMA_Channel4_IRQHandler>:
void BDMA_Channel4_IRQHandler() { if (BDMACTXvectors[0x04]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x04])); }
 8102564:	b580      	push	{r7, lr}
 8102566:	af00      	add	r7, sp, #0
 8102568:	4b05      	ldr	r3, [pc, #20]	; (8102580 <BDMA_Channel4_IRQHandler+0x1c>)
 810256a:	691b      	ldr	r3, [r3, #16]
 810256c:	2b00      	cmp	r3, #0
 810256e:	d004      	beq.n	810257a <BDMA_Channel4_IRQHandler+0x16>
 8102570:	4b03      	ldr	r3, [pc, #12]	; (8102580 <BDMA_Channel4_IRQHandler+0x1c>)
 8102572:	691b      	ldr	r3, [r3, #16]
 8102574:	4618      	mov	r0, r3
 8102576:	f7ff ff3b 	bl	81023f0 <BDMA_Stream_IRQHandler>
 810257a:	bf00      	nop
 810257c:	bd80      	pop	{r7, pc}
 810257e:	bf00      	nop
 8102580:	10003444 	.word	0x10003444

08102584 <BDMA_Channel5_IRQHandler>:
void BDMA_Channel5_IRQHandler() { if (BDMACTXvectors[0x05]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x05])); }
 8102584:	b580      	push	{r7, lr}
 8102586:	af00      	add	r7, sp, #0
 8102588:	4b05      	ldr	r3, [pc, #20]	; (81025a0 <BDMA_Channel5_IRQHandler+0x1c>)
 810258a:	695b      	ldr	r3, [r3, #20]
 810258c:	2b00      	cmp	r3, #0
 810258e:	d004      	beq.n	810259a <BDMA_Channel5_IRQHandler+0x16>
 8102590:	4b03      	ldr	r3, [pc, #12]	; (81025a0 <BDMA_Channel5_IRQHandler+0x1c>)
 8102592:	695b      	ldr	r3, [r3, #20]
 8102594:	4618      	mov	r0, r3
 8102596:	f7ff ff2b 	bl	81023f0 <BDMA_Stream_IRQHandler>
 810259a:	bf00      	nop
 810259c:	bd80      	pop	{r7, pc}
 810259e:	bf00      	nop
 81025a0:	10003444 	.word	0x10003444

081025a4 <BDMA_Channel6_IRQHandler>:
void BDMA_Channel6_IRQHandler() { if (BDMACTXvectors[0x06]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x06])); }
 81025a4:	b580      	push	{r7, lr}
 81025a6:	af00      	add	r7, sp, #0
 81025a8:	4b05      	ldr	r3, [pc, #20]	; (81025c0 <BDMA_Channel6_IRQHandler+0x1c>)
 81025aa:	699b      	ldr	r3, [r3, #24]
 81025ac:	2b00      	cmp	r3, #0
 81025ae:	d004      	beq.n	81025ba <BDMA_Channel6_IRQHandler+0x16>
 81025b0:	4b03      	ldr	r3, [pc, #12]	; (81025c0 <BDMA_Channel6_IRQHandler+0x1c>)
 81025b2:	699b      	ldr	r3, [r3, #24]
 81025b4:	4618      	mov	r0, r3
 81025b6:	f7ff ff1b 	bl	81023f0 <BDMA_Stream_IRQHandler>
 81025ba:	bf00      	nop
 81025bc:	bd80      	pop	{r7, pc}
 81025be:	bf00      	nop
 81025c0:	10003444 	.word	0x10003444

081025c4 <BDMA_Channel7_IRQHandler>:
void BDMA_Channel7_IRQHandler() { if (BDMACTXvectors[0x07]>0) BDMA_Stream_IRQHandler((TxRxContext_TypeDef *)(BDMACTXvectors[0x07])); }
 81025c4:	b580      	push	{r7, lr}
 81025c6:	af00      	add	r7, sp, #0
 81025c8:	4b05      	ldr	r3, [pc, #20]	; (81025e0 <BDMA_Channel7_IRQHandler+0x1c>)
 81025ca:	69db      	ldr	r3, [r3, #28]
 81025cc:	2b00      	cmp	r3, #0
 81025ce:	d004      	beq.n	81025da <BDMA_Channel7_IRQHandler+0x16>
 81025d0:	4b03      	ldr	r3, [pc, #12]	; (81025e0 <BDMA_Channel7_IRQHandler+0x1c>)
 81025d2:	69db      	ldr	r3, [r3, #28]
 81025d4:	4618      	mov	r0, r3
 81025d6:	f7ff ff0b 	bl	81023f0 <BDMA_Stream_IRQHandler>
 81025da:	bf00      	nop
 81025dc:	bd80      	pop	{r7, pc}
 81025de:	bf00      	nop
 81025e0:	10003444 	.word	0x10003444

081025e4 <__NVIC_SetPriorityGrouping>:
{
 81025e4:	b480      	push	{r7}
 81025e6:	b085      	sub	sp, #20
 81025e8:	af00      	add	r7, sp, #0
 81025ea:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 81025ec:	687b      	ldr	r3, [r7, #4]
 81025ee:	f003 0307 	and.w	r3, r3, #7
 81025f2:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 81025f4:	4b0c      	ldr	r3, [pc, #48]	; (8102628 <__NVIC_SetPriorityGrouping+0x44>)
 81025f6:	68db      	ldr	r3, [r3, #12]
 81025f8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 81025fa:	68ba      	ldr	r2, [r7, #8]
 81025fc:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8102600:	4013      	ands	r3, r2
 8102602:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8102604:	68fb      	ldr	r3, [r7, #12]
 8102606:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8102608:	68bb      	ldr	r3, [r7, #8]
 810260a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 810260c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8102610:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8102614:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8102616:	4a04      	ldr	r2, [pc, #16]	; (8102628 <__NVIC_SetPriorityGrouping+0x44>)
 8102618:	68bb      	ldr	r3, [r7, #8]
 810261a:	60d3      	str	r3, [r2, #12]
}
 810261c:	bf00      	nop
 810261e:	3714      	adds	r7, #20
 8102620:	46bd      	mov	sp, r7
 8102622:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102626:	4770      	bx	lr
 8102628:	e000ed00 	.word	0xe000ed00

0810262c <__NVIC_GetPriorityGrouping>:
{
 810262c:	b480      	push	{r7}
 810262e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8102630:	4b04      	ldr	r3, [pc, #16]	; (8102644 <__NVIC_GetPriorityGrouping+0x18>)
 8102632:	68db      	ldr	r3, [r3, #12]
 8102634:	0a1b      	lsrs	r3, r3, #8
 8102636:	f003 0307 	and.w	r3, r3, #7
}
 810263a:	4618      	mov	r0, r3
 810263c:	46bd      	mov	sp, r7
 810263e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102642:	4770      	bx	lr
 8102644:	e000ed00 	.word	0xe000ed00

08102648 <__NVIC_EnableIRQ>:
{
 8102648:	b480      	push	{r7}
 810264a:	b083      	sub	sp, #12
 810264c:	af00      	add	r7, sp, #0
 810264e:	4603      	mov	r3, r0
 8102650:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8102652:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8102656:	2b00      	cmp	r3, #0
 8102658:	db0b      	blt.n	8102672 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 810265a:	88fb      	ldrh	r3, [r7, #6]
 810265c:	f003 021f 	and.w	r2, r3, #31
 8102660:	4907      	ldr	r1, [pc, #28]	; (8102680 <__NVIC_EnableIRQ+0x38>)
 8102662:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8102666:	095b      	lsrs	r3, r3, #5
 8102668:	2001      	movs	r0, #1
 810266a:	fa00 f202 	lsl.w	r2, r0, r2
 810266e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8102672:	bf00      	nop
 8102674:	370c      	adds	r7, #12
 8102676:	46bd      	mov	sp, r7
 8102678:	f85d 7b04 	ldr.w	r7, [sp], #4
 810267c:	4770      	bx	lr
 810267e:	bf00      	nop
 8102680:	e000e100 	.word	0xe000e100

08102684 <__NVIC_SetPriority>:
{
 8102684:	b480      	push	{r7}
 8102686:	b083      	sub	sp, #12
 8102688:	af00      	add	r7, sp, #0
 810268a:	4603      	mov	r3, r0
 810268c:	6039      	str	r1, [r7, #0]
 810268e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8102690:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8102694:	2b00      	cmp	r3, #0
 8102696:	db0a      	blt.n	81026ae <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8102698:	683b      	ldr	r3, [r7, #0]
 810269a:	b2da      	uxtb	r2, r3
 810269c:	490c      	ldr	r1, [pc, #48]	; (81026d0 <__NVIC_SetPriority+0x4c>)
 810269e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 81026a2:	0112      	lsls	r2, r2, #4
 81026a4:	b2d2      	uxtb	r2, r2
 81026a6:	440b      	add	r3, r1
 81026a8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 81026ac:	e00a      	b.n	81026c4 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 81026ae:	683b      	ldr	r3, [r7, #0]
 81026b0:	b2da      	uxtb	r2, r3
 81026b2:	4908      	ldr	r1, [pc, #32]	; (81026d4 <__NVIC_SetPriority+0x50>)
 81026b4:	88fb      	ldrh	r3, [r7, #6]
 81026b6:	f003 030f 	and.w	r3, r3, #15
 81026ba:	3b04      	subs	r3, #4
 81026bc:	0112      	lsls	r2, r2, #4
 81026be:	b2d2      	uxtb	r2, r2
 81026c0:	440b      	add	r3, r1
 81026c2:	761a      	strb	r2, [r3, #24]
}
 81026c4:	bf00      	nop
 81026c6:	370c      	adds	r7, #12
 81026c8:	46bd      	mov	sp, r7
 81026ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 81026ce:	4770      	bx	lr
 81026d0:	e000e100 	.word	0xe000e100
 81026d4:	e000ed00 	.word	0xe000ed00

081026d8 <NVIC_EncodePriority>:
{
 81026d8:	b480      	push	{r7}
 81026da:	b089      	sub	sp, #36	; 0x24
 81026dc:	af00      	add	r7, sp, #0
 81026de:	60f8      	str	r0, [r7, #12]
 81026e0:	60b9      	str	r1, [r7, #8]
 81026e2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 81026e4:	68fb      	ldr	r3, [r7, #12]
 81026e6:	f003 0307 	and.w	r3, r3, #7
 81026ea:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 81026ec:	69fb      	ldr	r3, [r7, #28]
 81026ee:	f1c3 0307 	rsb	r3, r3, #7
 81026f2:	2b04      	cmp	r3, #4
 81026f4:	bf28      	it	cs
 81026f6:	2304      	movcs	r3, #4
 81026f8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 81026fa:	69fb      	ldr	r3, [r7, #28]
 81026fc:	3304      	adds	r3, #4
 81026fe:	2b06      	cmp	r3, #6
 8102700:	d902      	bls.n	8102708 <NVIC_EncodePriority+0x30>
 8102702:	69fb      	ldr	r3, [r7, #28]
 8102704:	3b03      	subs	r3, #3
 8102706:	e000      	b.n	810270a <NVIC_EncodePriority+0x32>
 8102708:	2300      	movs	r3, #0
 810270a:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 810270c:	f04f 32ff 	mov.w	r2, #4294967295
 8102710:	69bb      	ldr	r3, [r7, #24]
 8102712:	fa02 f303 	lsl.w	r3, r2, r3
 8102716:	43da      	mvns	r2, r3
 8102718:	68bb      	ldr	r3, [r7, #8]
 810271a:	401a      	ands	r2, r3
 810271c:	697b      	ldr	r3, [r7, #20]
 810271e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8102720:	f04f 31ff 	mov.w	r1, #4294967295
 8102724:	697b      	ldr	r3, [r7, #20]
 8102726:	fa01 f303 	lsl.w	r3, r1, r3
 810272a:	43d9      	mvns	r1, r3
 810272c:	687b      	ldr	r3, [r7, #4]
 810272e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8102730:	4313      	orrs	r3, r2
}
 8102732:	4618      	mov	r0, r3
 8102734:	3724      	adds	r7, #36	; 0x24
 8102736:	46bd      	mov	sp, r7
 8102738:	f85d 7b04 	ldr.w	r7, [sp], #4
 810273c:	4770      	bx	lr

0810273e <BSP_STM32_NVIC_EnableIRQ>:
 *******************************************************************/

#include "BSP_STM32_CORE.h"


uint8_t BSP_STM32_NVIC_EnableIRQ(IRQn_Type IRQn) {
 810273e:	b580      	push	{r7, lr}
 8102740:	b082      	sub	sp, #8
 8102742:	af00      	add	r7, sp, #0
 8102744:	4603      	mov	r3, r0
 8102746:	80fb      	strh	r3, [r7, #6]
	NVIC_EnableIRQ(IRQn);
 8102748:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810274c:	4618      	mov	r0, r3
 810274e:	f7ff ff7b 	bl	8102648 <__NVIC_EnableIRQ>
	return BSP_OK;
 8102752:	2300      	movs	r3, #0
}
 8102754:	4618      	mov	r0, r3
 8102756:	3708      	adds	r7, #8
 8102758:	46bd      	mov	sp, r7
 810275a:	bd80      	pop	{r7, pc}

0810275c <BSP_STM32_NVIC_SetPriority>:


uint8_t BSP_STM32_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority) {
 810275c:	b580      	push	{r7, lr}
 810275e:	b086      	sub	sp, #24
 8102760:	af00      	add	r7, sp, #0
 8102762:	4603      	mov	r3, r0
 8102764:	60b9      	str	r1, [r7, #8]
 8102766:	607a      	str	r2, [r7, #4]
 8102768:	81fb      	strh	r3, [r7, #14]
	uint32_t prioritygroup = NVIC_GetPriorityGrouping();
 810276a:	f7ff ff5f 	bl	810262c <__NVIC_GetPriorityGrouping>
 810276e:	6178      	str	r0, [r7, #20]
	NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8102770:	687a      	ldr	r2, [r7, #4]
 8102772:	68b9      	ldr	r1, [r7, #8]
 8102774:	6978      	ldr	r0, [r7, #20]
 8102776:	f7ff ffaf 	bl	81026d8 <NVIC_EncodePriority>
 810277a:	4602      	mov	r2, r0
 810277c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8102780:	4611      	mov	r1, r2
 8102782:	4618      	mov	r0, r3
 8102784:	f7ff ff7e 	bl	8102684 <__NVIC_SetPriority>
	return BSP_OK;
 8102788:	2300      	movs	r3, #0
}
 810278a:	4618      	mov	r0, r3
 810278c:	3718      	adds	r7, #24
 810278e:	46bd      	mov	sp, r7
 8102790:	bd80      	pop	{r7, pc}

08102792 <BSP_STM32_NVIC_SetPriorityGrouping>:

uint8_t BSP_STM32_NVIC_SetPriorityGrouping(uint32_t PriorityGroup) {
 8102792:	b580      	push	{r7, lr}
 8102794:	b082      	sub	sp, #8
 8102796:	af00      	add	r7, sp, #0
 8102798:	6078      	str	r0, [r7, #4]
	// Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value
	NVIC_SetPriorityGrouping(PriorityGroup);
 810279a:	6878      	ldr	r0, [r7, #4]
 810279c:	f7ff ff22 	bl	81025e4 <__NVIC_SetPriorityGrouping>
	return BSP_OK;
 81027a0:	2300      	movs	r3, #0
}
 81027a2:	4618      	mov	r0, r3
 81027a4:	3708      	adds	r7, #8
 81027a6:	46bd      	mov	sp, r7
 81027a8:	bd80      	pop	{r7, pc}
	...

081027ac <BSP_STM32_MPU_Enable>:

uint8_t BSP_STM32_MPU_Enable(uint32_t MPU_Control) {
 81027ac:	b480      	push	{r7}
 81027ae:	b083      	sub	sp, #12
 81027b0:	af00      	add	r7, sp, #0
 81027b2:	6078      	str	r0, [r7, #4]
	// Enable the MPU
	MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 81027b4:	4a0b      	ldr	r2, [pc, #44]	; (81027e4 <BSP_STM32_MPU_Enable+0x38>)
 81027b6:	687b      	ldr	r3, [r7, #4]
 81027b8:	f043 0301 	orr.w	r3, r3, #1
 81027bc:	6053      	str	r3, [r2, #4]
	// Enable fault exceptions
	SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 81027be:	4b0a      	ldr	r3, [pc, #40]	; (81027e8 <BSP_STM32_MPU_Enable+0x3c>)
 81027c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81027c2:	4a09      	ldr	r2, [pc, #36]	; (81027e8 <BSP_STM32_MPU_Enable+0x3c>)
 81027c4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 81027c8:	6253      	str	r3, [r2, #36]	; 0x24
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 81027ca:	f3bf 8f4f 	dsb	sy
}
 81027ce:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 81027d0:	f3bf 8f6f 	isb	sy
}
 81027d4:	bf00      	nop
	// Ensure MPU setting take effects
	  __DSB();
	  __ISB();
	return BSP_OK;
 81027d6:	2300      	movs	r3, #0
}
 81027d8:	4618      	mov	r0, r3
 81027da:	370c      	adds	r7, #12
 81027dc:	46bd      	mov	sp, r7
 81027de:	f85d 7b04 	ldr.w	r7, [sp], #4
 81027e2:	4770      	bx	lr
 81027e4:	e000ed90 	.word	0xe000ed90
 81027e8:	e000ed00 	.word	0xe000ed00

081027ec <BSP_STM32_MPU_Disable>:

uint8_t BSP_STM32_MPU_Disable() {
 81027ec:	b480      	push	{r7}
 81027ee:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 81027f0:	f3bf 8f5f 	dmb	sy
}
 81027f4:	bf00      	nop
	// Make sure outstanding transfers are done
	__DMB();
	// Disable fault exceptions
	SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 81027f6:	4b07      	ldr	r3, [pc, #28]	; (8102814 <BSP_STM32_MPU_Disable+0x28>)
 81027f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81027fa:	4a06      	ldr	r2, [pc, #24]	; (8102814 <BSP_STM32_MPU_Disable+0x28>)
 81027fc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8102800:	6253      	str	r3, [r2, #36]	; 0x24
	// Disable the MPU and clear the control register
	MPU->CTRL = 0;
 8102802:	4b05      	ldr	r3, [pc, #20]	; (8102818 <BSP_STM32_MPU_Disable+0x2c>)
 8102804:	2200      	movs	r2, #0
 8102806:	605a      	str	r2, [r3, #4]
	return BSP_OK;
 8102808:	2300      	movs	r3, #0
}
 810280a:	4618      	mov	r0, r3
 810280c:	46bd      	mov	sp, r7
 810280e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102812:	4770      	bx	lr
 8102814:	e000ed00 	.word	0xe000ed00
 8102818:	e000ed90 	.word	0xe000ed90

0810281c <BSP_STM32_MPU_ConfigRegion>:

uint8_t BSP_STM32_MPU_ConfigRegion(MPU_Region_TypeDef *MPU_Init) {
 810281c:	b480      	push	{r7}
 810281e:	b083      	sub	sp, #12
 8102820:	af00      	add	r7, sp, #0
 8102822:	6078      	str	r0, [r7, #4]
	// Set the Region number
	MPU->RNR = MPU_Init->Number;
 8102824:	687b      	ldr	r3, [r7, #4]
 8102826:	785a      	ldrb	r2, [r3, #1]
 8102828:	4b1e      	ldr	r3, [pc, #120]	; (81028a4 <BSP_STM32_MPU_ConfigRegion+0x88>)
 810282a:	609a      	str	r2, [r3, #8]

	if (MPU_Init->Enable == MPU_REGION_DISABLE) { MPU->RBAR = 0; MPU->RASR = 0; return BSP_OK; }
 810282c:	687b      	ldr	r3, [r7, #4]
 810282e:	781b      	ldrb	r3, [r3, #0]
 8102830:	2b00      	cmp	r3, #0
 8102832:	d107      	bne.n	8102844 <BSP_STM32_MPU_ConfigRegion+0x28>
 8102834:	4b1b      	ldr	r3, [pc, #108]	; (81028a4 <BSP_STM32_MPU_ConfigRegion+0x88>)
 8102836:	2200      	movs	r2, #0
 8102838:	60da      	str	r2, [r3, #12]
 810283a:	4b1a      	ldr	r3, [pc, #104]	; (81028a4 <BSP_STM32_MPU_ConfigRegion+0x88>)
 810283c:	2200      	movs	r2, #0
 810283e:	611a      	str	r2, [r3, #16]
 8102840:	2300      	movs	r3, #0
 8102842:	e029      	b.n	8102898 <BSP_STM32_MPU_ConfigRegion+0x7c>

	MPU->RBAR = MPU_Init->BaseAddress;
 8102844:	4a17      	ldr	r2, [pc, #92]	; (81028a4 <BSP_STM32_MPU_ConfigRegion+0x88>)
 8102846:	687b      	ldr	r3, [r7, #4]
 8102848:	685b      	ldr	r3, [r3, #4]
 810284a:	60d3      	str	r3, [r2, #12]
	MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 810284c:	687b      	ldr	r3, [r7, #4]
 810284e:	7b1b      	ldrb	r3, [r3, #12]
 8102850:	071a      	lsls	r2, r3, #28
	            ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8102852:	687b      	ldr	r3, [r7, #4]
 8102854:	7adb      	ldrb	r3, [r3, #11]
 8102856:	061b      	lsls	r3, r3, #24
	MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8102858:	431a      	orrs	r2, r3
	            ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 810285a:	687b      	ldr	r3, [r7, #4]
 810285c:	7a9b      	ldrb	r3, [r3, #10]
 810285e:	04db      	lsls	r3, r3, #19
	            ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8102860:	431a      	orrs	r2, r3
	            ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8102862:	687b      	ldr	r3, [r7, #4]
 8102864:	7b5b      	ldrb	r3, [r3, #13]
 8102866:	049b      	lsls	r3, r3, #18
	            ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8102868:	431a      	orrs	r2, r3
	            ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 810286a:	687b      	ldr	r3, [r7, #4]
 810286c:	7b9b      	ldrb	r3, [r3, #14]
 810286e:	045b      	lsls	r3, r3, #17
	            ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8102870:	431a      	orrs	r2, r3
	            ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8102872:	687b      	ldr	r3, [r7, #4]
 8102874:	7bdb      	ldrb	r3, [r3, #15]
 8102876:	041b      	lsls	r3, r3, #16
	            ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8102878:	431a      	orrs	r2, r3
	            ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 810287a:	687b      	ldr	r3, [r7, #4]
 810287c:	7a5b      	ldrb	r3, [r3, #9]
 810287e:	021b      	lsls	r3, r3, #8
	            ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8102880:	431a      	orrs	r2, r3
	            ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8102882:	687b      	ldr	r3, [r7, #4]
 8102884:	7a1b      	ldrb	r3, [r3, #8]
 8102886:	005b      	lsls	r3, r3, #1
	            ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8102888:	4313      	orrs	r3, r2
	            ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 810288a:	687a      	ldr	r2, [r7, #4]
 810288c:	7812      	ldrb	r2, [r2, #0]
 810288e:	4611      	mov	r1, r2
	MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8102890:	4a04      	ldr	r2, [pc, #16]	; (81028a4 <BSP_STM32_MPU_ConfigRegion+0x88>)
	            ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8102892:	430b      	orrs	r3, r1
	MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8102894:	6113      	str	r3, [r2, #16]

	return BSP_OK;
 8102896:	2300      	movs	r3, #0
}
 8102898:	4618      	mov	r0, r3
 810289a:	370c      	adds	r7, #12
 810289c:	46bd      	mov	sp, r7
 810289e:	f85d 7b04 	ldr.w	r7, [sp], #4
 81028a2:	4770      	bx	lr
 81028a4:	e000ed90 	.word	0xe000ed90

081028a8 <BSP_STM32_DMA_Init>:


uint32_t DMACTXvectors[16] = {0};


uint8_t BSP_STM32_DMA_Init(DMA_Stream_TypeDef *hdma, uint32_t dir, uint32_t pinc, uint32_t minc, uint32_t pdatalign, uint32_t mdatalign, uint32_t mode, uint32_t priority) {
 81028a8:	b580      	push	{r7, lr}
 81028aa:	b086      	sub	sp, #24
 81028ac:	af00      	add	r7, sp, #0
 81028ae:	60f8      	str	r0, [r7, #12]
 81028b0:	60b9      	str	r1, [r7, #8]
 81028b2:	607a      	str	r2, [r7, #4]
 81028b4:	603b      	str	r3, [r7, #0]

	uint32_t tickstart = BSP_GetTick();
 81028b6:	f7fe f82f 	bl	8100918 <BSP_GetTick>
 81028ba:	6178      	str	r0, [r7, #20]

    // Disable the peripheral
    hdma->CR &= ~DMA_SxCR_EN;
 81028bc:	68fb      	ldr	r3, [r7, #12]
 81028be:	681b      	ldr	r3, [r3, #0]
 81028c0:	f023 0201 	bic.w	r2, r3, #1
 81028c4:	68fb      	ldr	r3, [r7, #12]
 81028c6:	601a      	str	r2, [r3, #0]

    // Check if the DMA Stream is effectively disabled
    while ((hdma->CR & DMA_SxCR_EN) > 0) if ((BSP_GetTick() - tickstart) > 2) return BSP_ERROR;
 81028c8:	e008      	b.n	81028dc <BSP_STM32_DMA_Init+0x34>
 81028ca:	f7fe f825 	bl	8100918 <BSP_GetTick>
 81028ce:	4602      	mov	r2, r0
 81028d0:	697b      	ldr	r3, [r7, #20]
 81028d2:	1ad3      	subs	r3, r2, r3
 81028d4:	2b02      	cmp	r3, #2
 81028d6:	d901      	bls.n	81028dc <BSP_STM32_DMA_Init+0x34>
 81028d8:	2301      	movs	r3, #1
 81028da:	e02a      	b.n	8102932 <BSP_STM32_DMA_Init+0x8a>
 81028dc:	68fb      	ldr	r3, [r7, #12]
 81028de:	681b      	ldr	r3, [r3, #0]
 81028e0:	f003 0301 	and.w	r3, r3, #1
 81028e4:	2b00      	cmp	r3, #0
 81028e6:	d1f0      	bne.n	81028ca <BSP_STM32_DMA_Init+0x22>

    // Get the CR register value
    uint32_t registerValue = hdma->CR;
 81028e8:	68fb      	ldr	r3, [r7, #12]
 81028ea:	681b      	ldr	r3, [r3, #0]
 81028ec:	613b      	str	r3, [r7, #16]

    // Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | DMA_SxCR_DIR | DMA_SxCR_CT | DMA_SxCR_DBM));
 81028ee:	693a      	ldr	r2, [r7, #16]
 81028f0:	4b12      	ldr	r3, [pc, #72]	; (810293c <BSP_STM32_DMA_Init+0x94>)
 81028f2:	4013      	ands	r3, r2
 81028f4:	613b      	str	r3, [r7, #16]

    // Prepare the DMA Stream configuration
    registerValue |=  dir | pinc | minc | pdatalign | mdatalign | mode | priority;
 81028f6:	68ba      	ldr	r2, [r7, #8]
 81028f8:	687b      	ldr	r3, [r7, #4]
 81028fa:	431a      	orrs	r2, r3
 81028fc:	683b      	ldr	r3, [r7, #0]
 81028fe:	431a      	orrs	r2, r3
 8102900:	6a3b      	ldr	r3, [r7, #32]
 8102902:	431a      	orrs	r2, r3
 8102904:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8102906:	431a      	orrs	r2, r3
 8102908:	6abb      	ldr	r3, [r7, #40]	; 0x28
 810290a:	431a      	orrs	r2, r3
 810290c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 810290e:	4313      	orrs	r3, r2
 8102910:	693a      	ldr	r2, [r7, #16]
 8102912:	4313      	orrs	r3, r2
 8102914:	613b      	str	r3, [r7, #16]

    // Write to DMA Stream CR register
    hdma->CR = registerValue;
 8102916:	68fb      	ldr	r3, [r7, #12]
 8102918:	693a      	ldr	r2, [r7, #16]
 810291a:	601a      	str	r2, [r3, #0]

    // Get the FCR register value
    registerValue = hdma->FCR;
 810291c:	68fb      	ldr	r3, [r7, #12]
 810291e:	695b      	ldr	r3, [r3, #20]
 8102920:	613b      	str	r3, [r7, #16]

    // Clear Direct mode and FIFO threshold bits
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8102922:	693b      	ldr	r3, [r7, #16]
 8102924:	f023 0307 	bic.w	r3, r3, #7
 8102928:	613b      	str	r3, [r7, #16]

    // Write to DMA Stream FCR
    hdma->FCR = registerValue;
 810292a:	68fb      	ldr	r3, [r7, #12]
 810292c:	693a      	ldr	r2, [r7, #16]
 810292e:	615a      	str	r2, [r3, #20]

	return BSP_OK;
 8102930:	2300      	movs	r3, #0
}
 8102932:	4618      	mov	r0, r3
 8102934:	3718      	adds	r7, #24
 8102936:	46bd      	mov	sp, r7
 8102938:	bd80      	pop	{r7, pc}
 810293a:	bf00      	nop
 810293c:	fe10803f 	.word	0xfe10803f

08102940 <BSP_STM32_DMA_CtxLink>:


uint8_t BSP_STM32_DMA_CtxLink(DMA_Stream_TypeDef *hdma, TxRxContext_TypeDef *ctx, uint32_t request) {
 8102940:	b480      	push	{r7}
 8102942:	b089      	sub	sp, #36	; 0x24
 8102944:	af00      	add	r7, sp, #0
 8102946:	60f8      	str	r0, [r7, #12]
 8102948:	60b9      	str	r1, [r7, #8]
 810294a:	607a      	str	r2, [r7, #4]

	ctx->dma_stream = (uint32_t)hdma;
 810294c:	68fa      	ldr	r2, [r7, #12]
 810294e:	68bb      	ldr	r3, [r7, #8]
 8102950:	605a      	str	r2, [r3, #4]
	ctx->dma_mode = TXRX_CTX_MODE_DMA;
 8102952:	68bb      	ldr	r3, [r7, #8]
 8102954:	2201      	movs	r2, #1
 8102956:	601a      	str	r2, [r3, #0]

    // Initialize StreamBaseAddress and StreamIndex parameters
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma) & 0xFFU) - 16U) / 24U;
 8102958:	68fb      	ldr	r3, [r7, #12]
 810295a:	b2db      	uxtb	r3, r3
 810295c:	3b10      	subs	r3, #16
 810295e:	4a32      	ldr	r2, [pc, #200]	; (8102a28 <BSP_STM32_DMA_CtxLink+0xe8>)
 8102960:	fba2 2303 	umull	r2, r3, r2, r3
 8102964:	091b      	lsrs	r3, r3, #4
 8102966:	61fb      	str	r3, [r7, #28]
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    ctx->dma_index = flagBitshiftOffset[stream_number & 0x7U];
 8102968:	69fb      	ldr	r3, [r7, #28]
 810296a:	f003 0307 	and.w	r3, r3, #7
 810296e:	4a2f      	ldr	r2, [pc, #188]	; (8102a2c <BSP_STM32_DMA_CtxLink+0xec>)
 8102970:	5cd3      	ldrb	r3, [r2, r3]
 8102972:	461a      	mov	r2, r3
 8102974:	68bb      	ldr	r3, [r7, #8]
 8102976:	609a      	str	r2, [r3, #8]
    if (stream_number > 3U) ctx->dma_baseregs = (((uint32_t)((uint32_t*)hdma) & (uint32_t)(~0x3FFU)) + 4U);
 8102978:	69fb      	ldr	r3, [r7, #28]
 810297a:	2b03      	cmp	r3, #3
 810297c:	d908      	bls.n	8102990 <BSP_STM32_DMA_CtxLink+0x50>
 810297e:	68fb      	ldr	r3, [r7, #12]
 8102980:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8102984:	f023 0303 	bic.w	r3, r3, #3
 8102988:	1d1a      	adds	r2, r3, #4
 810298a:	68bb      	ldr	r3, [r7, #8]
 810298c:	60da      	str	r2, [r3, #12]
 810298e:	e006      	b.n	810299e <BSP_STM32_DMA_CtxLink+0x5e>
    	else ctx->dma_baseregs = ((uint32_t)((uint32_t*)hdma) & (uint32_t)(~0x3FFU));
 8102990:	68fb      	ldr	r3, [r7, #12]
 8102992:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8102996:	f023 0303 	bic.w	r3, r3, #3
 810299a:	68ba      	ldr	r2, [r7, #8]
 810299c:	60d3      	str	r3, [r2, #12]

    //Clear all interrupt flags
    DMA_Base_Registers * regs_dma = (DMA_Base_Registers * )ctx->dma_baseregs;
 810299e:	68bb      	ldr	r3, [r7, #8]
 81029a0:	68db      	ldr	r3, [r3, #12]
 81029a2:	61bb      	str	r3, [r7, #24]
    regs_dma->IFCR = 0x3FUL << (ctx->dma_index & 0x1FU);
 81029a4:	68bb      	ldr	r3, [r7, #8]
 81029a6:	689b      	ldr	r3, [r3, #8]
 81029a8:	f003 031f 	and.w	r3, r3, #31
 81029ac:	223f      	movs	r2, #63	; 0x3f
 81029ae:	409a      	lsls	r2, r3
 81029b0:	69bb      	ldr	r3, [r7, #24]
 81029b2:	609a      	str	r2, [r3, #8]

    // Initialize parameters for DMAMUX channel
    if((ctx->dma_baseregs <= ((uint32_t)DMA2_Stream7)) && (ctx->dma_baseregs >= ((uint32_t)DMA2_Stream0))) stream_number += 8U;
 81029b4:	68bb      	ldr	r3, [r7, #8]
 81029b6:	68db      	ldr	r3, [r3, #12]
 81029b8:	4a1d      	ldr	r2, [pc, #116]	; (8102a30 <BSP_STM32_DMA_CtxLink+0xf0>)
 81029ba:	4293      	cmp	r3, r2
 81029bc:	d807      	bhi.n	81029ce <BSP_STM32_DMA_CtxLink+0x8e>
 81029be:	68bb      	ldr	r3, [r7, #8]
 81029c0:	68db      	ldr	r3, [r3, #12]
 81029c2:	4a1c      	ldr	r2, [pc, #112]	; (8102a34 <BSP_STM32_DMA_CtxLink+0xf4>)
 81029c4:	4293      	cmp	r3, r2
 81029c6:	d902      	bls.n	81029ce <BSP_STM32_DMA_CtxLink+0x8e>
 81029c8:	69fb      	ldr	r3, [r7, #28]
 81029ca:	3308      	adds	r3, #8
 81029cc:	61fb      	str	r3, [r7, #28]

    ctx->dma_muxchannel = ((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 81029ce:	69fb      	ldr	r3, [r7, #28]
 81029d0:	f103 5380 	add.w	r3, r3, #268435456	; 0x10000000
 81029d4:	f503 4302 	add.w	r3, r3, #33280	; 0x8200
 81029d8:	009a      	lsls	r2, r3, #2
 81029da:	68bb      	ldr	r3, [r7, #8]
 81029dc:	611a      	str	r2, [r3, #16]
    ctx->dma_muxchannelstatus = DMAMUX1_ChannelStatus_BASE;
 81029de:	68bb      	ldr	r3, [r7, #8]
 81029e0:	4a15      	ldr	r2, [pc, #84]	; (8102a38 <BSP_STM32_DMA_CtxLink+0xf8>)
 81029e2:	615a      	str	r2, [r3, #20]
    ctx->dma_muxchannelstatusmask = 1UL << (stream_number & 0x1FU);
 81029e4:	69fb      	ldr	r3, [r7, #28]
 81029e6:	f003 031f 	and.w	r3, r3, #31
 81029ea:	2201      	movs	r2, #1
 81029ec:	409a      	lsls	r2, r3
 81029ee:	68bb      	ldr	r3, [r7, #8]
 81029f0:	619a      	str	r2, [r3, #24]

    // Set peripheral request  to DMAMUX channel
    DMAMUX_Channel_TypeDef * dma_muxchannel = (DMAMUX_Channel_TypeDef *)ctx->dma_muxchannel;
 81029f2:	68bb      	ldr	r3, [r7, #8]
 81029f4:	691b      	ldr	r3, [r3, #16]
 81029f6:	617b      	str	r3, [r7, #20]
    dma_muxchannel->CCR = (request & DMAMUX_CxCR_DMAREQ_ID);
 81029f8:	687b      	ldr	r3, [r7, #4]
 81029fa:	b2da      	uxtb	r2, r3
 81029fc:	697b      	ldr	r3, [r7, #20]
 81029fe:	601a      	str	r2, [r3, #0]

    // Clear the DMAMUX synchro overrun flag
    DMAMUX_ChannelStatus_TypeDef * dma_muxchannelstatus = (DMAMUX_ChannelStatus_TypeDef *)ctx->dma_muxchannelstatus;
 8102a00:	68bb      	ldr	r3, [r7, #8]
 8102a02:	695b      	ldr	r3, [r3, #20]
 8102a04:	613b      	str	r3, [r7, #16]
    dma_muxchannelstatus->CFR = ctx->dma_muxchannelstatusmask;
 8102a06:	68bb      	ldr	r3, [r7, #8]
 8102a08:	699a      	ldr	r2, [r3, #24]
 8102a0a:	693b      	ldr	r3, [r7, #16]
 8102a0c:	605a      	str	r2, [r3, #4]

    // Assigning TxRx Context to DMA stream
    DMACTXvectors[stream_number] = (uint32_t)ctx;
 8102a0e:	68ba      	ldr	r2, [r7, #8]
 8102a10:	490a      	ldr	r1, [pc, #40]	; (8102a3c <BSP_STM32_DMA_CtxLink+0xfc>)
 8102a12:	69fb      	ldr	r3, [r7, #28]
 8102a14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	return BSP_OK;
 8102a18:	2300      	movs	r3, #0
}
 8102a1a:	4618      	mov	r0, r3
 8102a1c:	3724      	adds	r7, #36	; 0x24
 8102a1e:	46bd      	mov	sp, r7
 8102a20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102a24:	4770      	bx	lr
 8102a26:	bf00      	nop
 8102a28:	aaaaaaab 	.word	0xaaaaaaab
 8102a2c:	08104ddc 	.word	0x08104ddc
 8102a30:	400204b8 	.word	0x400204b8
 8102a34:	4002040f 	.word	0x4002040f
 8102a38:	40020880 	.word	0x40020880
 8102a3c:	10003464 	.word	0x10003464

08102a40 <DMA_Stream_IRQHandler>:



// ************* DMA INT handlers *************

void DMA_Stream_IRQHandler(TxRxContext_TypeDef * ctx) {
 8102a40:	b580      	push	{r7, lr}
 8102a42:	b088      	sub	sp, #32
 8102a44:	af00      	add	r7, sp, #0
 8102a46:	6078      	str	r0, [r7, #4]
	// Callback management
	void (* pCallback_TE)(TxRxContext_TypeDef * ctx);
	void (* pCallback_HT)(TxRxContext_TypeDef * ctx);
	void (* pCallback_TC)(TxRxContext_TypeDef * ctx);

	pCallback_TE = (void *)ctx->callback_TE;
 8102a48:	687b      	ldr	r3, [r7, #4]
 8102a4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8102a4c:	61fb      	str	r3, [r7, #28]
	pCallback_HT = (void *)ctx->callback_HT;
 8102a4e:	687b      	ldr	r3, [r7, #4]
 8102a50:	69db      	ldr	r3, [r3, #28]
 8102a52:	61bb      	str	r3, [r7, #24]
	pCallback_TC = (void *)ctx->callback_TC;
 8102a54:	687b      	ldr	r3, [r7, #4]
 8102a56:	6a1b      	ldr	r3, [r3, #32]
 8102a58:	617b      	str	r3, [r7, #20]

	// Accessing DMA registers
	DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)ctx->dma_baseregs;
 8102a5a:	687b      	ldr	r3, [r7, #4]
 8102a5c:	68db      	ldr	r3, [r3, #12]
 8102a5e:	613b      	str	r3, [r7, #16]
	DMA_Stream_TypeDef	*regs_dma_stream = (DMA_Stream_TypeDef *)ctx->dma_stream;
 8102a60:	687b      	ldr	r3, [r7, #4]
 8102a62:	685b      	ldr	r3, [r3, #4]
 8102a64:	60fb      	str	r3, [r7, #12]

	// Transfer Error Interrupt management
	if (((regs_dma_stream->CR & DMA_IT_TE) != 0) && ((regs_dma->ISR & (DMA_FLAG_TEIF0_4 << (ctx->dma_index & 0x1FU))) != 0)) {
 8102a66:	68fb      	ldr	r3, [r7, #12]
 8102a68:	681b      	ldr	r3, [r3, #0]
 8102a6a:	f003 0304 	and.w	r3, r3, #4
 8102a6e:	2b00      	cmp	r3, #0
 8102a70:	d026      	beq.n	8102ac0 <DMA_Stream_IRQHandler+0x80>
 8102a72:	693b      	ldr	r3, [r7, #16]
 8102a74:	681a      	ldr	r2, [r3, #0]
 8102a76:	687b      	ldr	r3, [r7, #4]
 8102a78:	689b      	ldr	r3, [r3, #8]
 8102a7a:	f003 031f 	and.w	r3, r3, #31
 8102a7e:	2108      	movs	r1, #8
 8102a80:	fa01 f303 	lsl.w	r3, r1, r3
 8102a84:	4013      	ands	r3, r2
 8102a86:	2b00      	cmp	r3, #0
 8102a88:	d01a      	beq.n	8102ac0 <DMA_Stream_IRQHandler+0x80>
        // Disable the transfer error interrupt
        regs_dma_stream->CR  &= ~(DMA_IT_TE);
 8102a8a:	68fb      	ldr	r3, [r7, #12]
 8102a8c:	681b      	ldr	r3, [r3, #0]
 8102a8e:	f023 0204 	bic.w	r2, r3, #4
 8102a92:	68fb      	ldr	r3, [r7, #12]
 8102a94:	601a      	str	r2, [r3, #0]
        // Clear the transfer error flag
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (ctx->dma_index & 0x1FU);
 8102a96:	687b      	ldr	r3, [r7, #4]
 8102a98:	689b      	ldr	r3, [r3, #8]
 8102a9a:	f003 031f 	and.w	r3, r3, #31
 8102a9e:	2208      	movs	r2, #8
 8102aa0:	409a      	lsls	r2, r3
 8102aa2:	693b      	ldr	r3, [r7, #16]
 8102aa4:	609a      	str	r2, [r3, #8]
	    // Disable DMA
	    regs_dma_stream->CR &= ~DMA_SxCR_EN;
 8102aa6:	68fb      	ldr	r3, [r7, #12]
 8102aa8:	681b      	ldr	r3, [r3, #0]
 8102aaa:	f023 0201 	bic.w	r2, r3, #1
 8102aae:	68fb      	ldr	r3, [r7, #12]
 8102ab0:	601a      	str	r2, [r3, #0]

	    // Execute error callback if set
	    if (ctx->callback_TE > 0) pCallback_TE(ctx);
 8102ab2:	687b      	ldr	r3, [r7, #4]
 8102ab4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8102ab6:	2b00      	cmp	r3, #0
 8102ab8:	d002      	beq.n	8102ac0 <DMA_Stream_IRQHandler+0x80>
 8102aba:	69fb      	ldr	r3, [r7, #28]
 8102abc:	6878      	ldr	r0, [r7, #4]
 8102abe:	4798      	blx	r3
	}

	// FIFO Error Interrupt management
	if (((regs_dma_stream->FCR & DMA_IT_FE) != 0) && ((regs_dma->ISR & (DMA_FLAG_FEIF0_4 << (ctx->dma_index & 0x1FU))) != 0)) {
 8102ac0:	68fb      	ldr	r3, [r7, #12]
 8102ac2:	695b      	ldr	r3, [r3, #20]
 8102ac4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8102ac8:	2b00      	cmp	r3, #0
 8102aca:	d026      	beq.n	8102b1a <DMA_Stream_IRQHandler+0xda>
 8102acc:	693b      	ldr	r3, [r7, #16]
 8102ace:	681a      	ldr	r2, [r3, #0]
 8102ad0:	687b      	ldr	r3, [r7, #4]
 8102ad2:	689b      	ldr	r3, [r3, #8]
 8102ad4:	f003 031f 	and.w	r3, r3, #31
 8102ad8:	fa22 f303 	lsr.w	r3, r2, r3
 8102adc:	f003 0301 	and.w	r3, r3, #1
 8102ae0:	2b00      	cmp	r3, #0
 8102ae2:	d01a      	beq.n	8102b1a <DMA_Stream_IRQHandler+0xda>
        // Disable the FIFO error interrupt
        regs_dma_stream->FCR &= ~(DMA_IT_FE);
 8102ae4:	68fb      	ldr	r3, [r7, #12]
 8102ae6:	695b      	ldr	r3, [r3, #20]
 8102ae8:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8102aec:	68fb      	ldr	r3, [r7, #12]
 8102aee:	615a      	str	r2, [r3, #20]
		// Clear the FIFO error flag
	    regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (ctx->dma_index & 0x1FU);
 8102af0:	687b      	ldr	r3, [r7, #4]
 8102af2:	689b      	ldr	r3, [r3, #8]
 8102af4:	f003 031f 	and.w	r3, r3, #31
 8102af8:	2201      	movs	r2, #1
 8102afa:	409a      	lsls	r2, r3
 8102afc:	693b      	ldr	r3, [r7, #16]
 8102afe:	609a      	str	r2, [r3, #8]
	    // Disable DMA
	    regs_dma_stream->CR &= ~DMA_SxCR_EN;
 8102b00:	68fb      	ldr	r3, [r7, #12]
 8102b02:	681b      	ldr	r3, [r3, #0]
 8102b04:	f023 0201 	bic.w	r2, r3, #1
 8102b08:	68fb      	ldr	r3, [r7, #12]
 8102b0a:	601a      	str	r2, [r3, #0]

	    // Execute error callback if set
	    if (ctx->callback_TE > 0) pCallback_TE(ctx);
 8102b0c:	687b      	ldr	r3, [r7, #4]
 8102b0e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8102b10:	2b00      	cmp	r3, #0
 8102b12:	d002      	beq.n	8102b1a <DMA_Stream_IRQHandler+0xda>
 8102b14:	69fb      	ldr	r3, [r7, #28]
 8102b16:	6878      	ldr	r0, [r7, #4]
 8102b18:	4798      	blx	r3
	}

	// Direct Mode Error Interrupt management
	if (((regs_dma_stream->CR & DMA_IT_DME) != 0) && ((regs_dma->ISR & (DMA_FLAG_DMEIF0_4 << (ctx->dma_index & 0x1FU))) != 0)) {
 8102b1a:	68fb      	ldr	r3, [r7, #12]
 8102b1c:	681b      	ldr	r3, [r3, #0]
 8102b1e:	f003 0302 	and.w	r3, r3, #2
 8102b22:	2b00      	cmp	r3, #0
 8102b24:	d01a      	beq.n	8102b5c <DMA_Stream_IRQHandler+0x11c>
 8102b26:	693b      	ldr	r3, [r7, #16]
 8102b28:	681a      	ldr	r2, [r3, #0]
 8102b2a:	687b      	ldr	r3, [r7, #4]
 8102b2c:	689b      	ldr	r3, [r3, #8]
 8102b2e:	f003 031f 	and.w	r3, r3, #31
 8102b32:	2104      	movs	r1, #4
 8102b34:	fa01 f303 	lsl.w	r3, r1, r3
 8102b38:	4013      	ands	r3, r2
 8102b3a:	2b00      	cmp	r3, #0
 8102b3c:	d00e      	beq.n	8102b5c <DMA_Stream_IRQHandler+0x11c>
        // Clear the direct mode error flag
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (ctx->dma_index & 0x1FU);
 8102b3e:	687b      	ldr	r3, [r7, #4]
 8102b40:	689b      	ldr	r3, [r3, #8]
 8102b42:	f003 031f 	and.w	r3, r3, #31
 8102b46:	2204      	movs	r2, #4
 8102b48:	409a      	lsls	r2, r3
 8102b4a:	693b      	ldr	r3, [r7, #16]
 8102b4c:	609a      	str	r2, [r3, #8]

        // Execute error callback if set
        if (ctx->callback_TE > 0) pCallback_TE(ctx);
 8102b4e:	687b      	ldr	r3, [r7, #4]
 8102b50:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8102b52:	2b00      	cmp	r3, #0
 8102b54:	d002      	beq.n	8102b5c <DMA_Stream_IRQHandler+0x11c>
 8102b56:	69fb      	ldr	r3, [r7, #28]
 8102b58:	6878      	ldr	r0, [r7, #4]
 8102b5a:	4798      	blx	r3
	}

	// Half Transfer Complete Interrupt management
	if (((regs_dma_stream->CR & DMA_IT_HT) != 0) && ((regs_dma->ISR & (DMA_FLAG_HTIF0_4 << (ctx->dma_index & 0x1FU))) != 0)) {
 8102b5c:	68fb      	ldr	r3, [r7, #12]
 8102b5e:	681b      	ldr	r3, [r3, #0]
 8102b60:	f003 0308 	and.w	r3, r3, #8
 8102b64:	2b00      	cmp	r3, #0
 8102b66:	d026      	beq.n	8102bb6 <DMA_Stream_IRQHandler+0x176>
 8102b68:	693b      	ldr	r3, [r7, #16]
 8102b6a:	681a      	ldr	r2, [r3, #0]
 8102b6c:	687b      	ldr	r3, [r7, #4]
 8102b6e:	689b      	ldr	r3, [r3, #8]
 8102b70:	f003 031f 	and.w	r3, r3, #31
 8102b74:	2110      	movs	r1, #16
 8102b76:	fa01 f303 	lsl.w	r3, r1, r3
 8102b7a:	4013      	ands	r3, r2
 8102b7c:	2b00      	cmp	r3, #0
 8102b7e:	d01a      	beq.n	8102bb6 <DMA_Stream_IRQHandler+0x176>
        // Clear the half transfer complete flag
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (ctx->dma_index & 0x1FU);
 8102b80:	687b      	ldr	r3, [r7, #4]
 8102b82:	689b      	ldr	r3, [r3, #8]
 8102b84:	f003 031f 	and.w	r3, r3, #31
 8102b88:	2210      	movs	r2, #16
 8102b8a:	409a      	lsls	r2, r3
 8102b8c:	693b      	ldr	r3, [r7, #16]
 8102b8e:	609a      	str	r2, [r3, #8]
        // Disable the half transfer interrupt if the DMA mode is not CIRCULAR
        if ((regs_dma_stream->CR & DMA_SxCR_CIRC) == 0U) regs_dma_stream->CR  &= ~(DMA_IT_HT);
 8102b90:	68fb      	ldr	r3, [r7, #12]
 8102b92:	681b      	ldr	r3, [r3, #0]
 8102b94:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8102b98:	2b00      	cmp	r3, #0
 8102b9a:	d105      	bne.n	8102ba8 <DMA_Stream_IRQHandler+0x168>
 8102b9c:	68fb      	ldr	r3, [r7, #12]
 8102b9e:	681b      	ldr	r3, [r3, #0]
 8102ba0:	f023 0208 	bic.w	r2, r3, #8
 8102ba4:	68fb      	ldr	r3, [r7, #12]
 8102ba6:	601a      	str	r2, [r3, #0]

        // Execute half transfer callback if set
        if (ctx->callback_HT > 0) pCallback_HT(ctx);
 8102ba8:	687b      	ldr	r3, [r7, #4]
 8102baa:	69db      	ldr	r3, [r3, #28]
 8102bac:	2b00      	cmp	r3, #0
 8102bae:	d002      	beq.n	8102bb6 <DMA_Stream_IRQHandler+0x176>
 8102bb0:	69bb      	ldr	r3, [r7, #24]
 8102bb2:	6878      	ldr	r0, [r7, #4]
 8102bb4:	4798      	blx	r3

	}

	// Transfer Complete Interrupt management
	if (((regs_dma_stream->CR & DMA_IT_TC) != 0) && ((regs_dma->ISR & (DMA_FLAG_TCIF0_4 << (ctx->dma_index & 0x1FU))) != 0)) {
 8102bb6:	68fb      	ldr	r3, [r7, #12]
 8102bb8:	681b      	ldr	r3, [r3, #0]
 8102bba:	f003 0310 	and.w	r3, r3, #16
 8102bbe:	2b00      	cmp	r3, #0
 8102bc0:	d026      	beq.n	8102c10 <DMA_Stream_IRQHandler+0x1d0>
 8102bc2:	693b      	ldr	r3, [r7, #16]
 8102bc4:	681a      	ldr	r2, [r3, #0]
 8102bc6:	687b      	ldr	r3, [r7, #4]
 8102bc8:	689b      	ldr	r3, [r3, #8]
 8102bca:	f003 031f 	and.w	r3, r3, #31
 8102bce:	2120      	movs	r1, #32
 8102bd0:	fa01 f303 	lsl.w	r3, r1, r3
 8102bd4:	4013      	ands	r3, r2
 8102bd6:	2b00      	cmp	r3, #0
 8102bd8:	d01a      	beq.n	8102c10 <DMA_Stream_IRQHandler+0x1d0>
		// Clear the transfer complete flag
		regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (ctx->dma_index & 0x1FU);
 8102bda:	687b      	ldr	r3, [r7, #4]
 8102bdc:	689b      	ldr	r3, [r3, #8]
 8102bde:	f003 031f 	and.w	r3, r3, #31
 8102be2:	2220      	movs	r2, #32
 8102be4:	409a      	lsls	r2, r3
 8102be6:	693b      	ldr	r3, [r7, #16]
 8102be8:	609a      	str	r2, [r3, #8]
		// Disable the transfer complete interrupt if the DMA mode is not CIRCULAR
		if ((regs_dma_stream->CR & DMA_SxCR_CIRC) == 0U) regs_dma_stream->CR  &= ~(DMA_IT_TC);
 8102bea:	68fb      	ldr	r3, [r7, #12]
 8102bec:	681b      	ldr	r3, [r3, #0]
 8102bee:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8102bf2:	2b00      	cmp	r3, #0
 8102bf4:	d105      	bne.n	8102c02 <DMA_Stream_IRQHandler+0x1c2>
 8102bf6:	68fb      	ldr	r3, [r7, #12]
 8102bf8:	681b      	ldr	r3, [r3, #0]
 8102bfa:	f023 0210 	bic.w	r2, r3, #16
 8102bfe:	68fb      	ldr	r3, [r7, #12]
 8102c00:	601a      	str	r2, [r3, #0]

        // Execute transfer completed callback if set
        if (ctx->callback_TC > 0) pCallback_TC(ctx);
 8102c02:	687b      	ldr	r3, [r7, #4]
 8102c04:	6a1b      	ldr	r3, [r3, #32]
 8102c06:	2b00      	cmp	r3, #0
 8102c08:	d002      	beq.n	8102c10 <DMA_Stream_IRQHandler+0x1d0>
 8102c0a:	697b      	ldr	r3, [r7, #20]
 8102c0c:	6878      	ldr	r0, [r7, #4]
 8102c0e:	4798      	blx	r3
	}

}
 8102c10:	bf00      	nop
 8102c12:	3720      	adds	r7, #32
 8102c14:	46bd      	mov	sp, r7
 8102c16:	bd80      	pop	{r7, pc}

08102c18 <DMA1_Stream0_IRQHandler>:

void DMA1_Stream0_IRQHandler() { if (DMACTXvectors[0x00]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x00])); }
 8102c18:	b580      	push	{r7, lr}
 8102c1a:	af00      	add	r7, sp, #0
 8102c1c:	4b05      	ldr	r3, [pc, #20]	; (8102c34 <DMA1_Stream0_IRQHandler+0x1c>)
 8102c1e:	681b      	ldr	r3, [r3, #0]
 8102c20:	2b00      	cmp	r3, #0
 8102c22:	d004      	beq.n	8102c2e <DMA1_Stream0_IRQHandler+0x16>
 8102c24:	4b03      	ldr	r3, [pc, #12]	; (8102c34 <DMA1_Stream0_IRQHandler+0x1c>)
 8102c26:	681b      	ldr	r3, [r3, #0]
 8102c28:	4618      	mov	r0, r3
 8102c2a:	f7ff ff09 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102c2e:	bf00      	nop
 8102c30:	bd80      	pop	{r7, pc}
 8102c32:	bf00      	nop
 8102c34:	10003464 	.word	0x10003464

08102c38 <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler() { if (DMACTXvectors[0x01]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x01])); }
 8102c38:	b580      	push	{r7, lr}
 8102c3a:	af00      	add	r7, sp, #0
 8102c3c:	4b05      	ldr	r3, [pc, #20]	; (8102c54 <DMA1_Stream1_IRQHandler+0x1c>)
 8102c3e:	685b      	ldr	r3, [r3, #4]
 8102c40:	2b00      	cmp	r3, #0
 8102c42:	d004      	beq.n	8102c4e <DMA1_Stream1_IRQHandler+0x16>
 8102c44:	4b03      	ldr	r3, [pc, #12]	; (8102c54 <DMA1_Stream1_IRQHandler+0x1c>)
 8102c46:	685b      	ldr	r3, [r3, #4]
 8102c48:	4618      	mov	r0, r3
 8102c4a:	f7ff fef9 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102c4e:	bf00      	nop
 8102c50:	bd80      	pop	{r7, pc}
 8102c52:	bf00      	nop
 8102c54:	10003464 	.word	0x10003464

08102c58 <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler() { if (DMACTXvectors[0x02]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x02])); }
 8102c58:	b580      	push	{r7, lr}
 8102c5a:	af00      	add	r7, sp, #0
 8102c5c:	4b05      	ldr	r3, [pc, #20]	; (8102c74 <DMA1_Stream2_IRQHandler+0x1c>)
 8102c5e:	689b      	ldr	r3, [r3, #8]
 8102c60:	2b00      	cmp	r3, #0
 8102c62:	d004      	beq.n	8102c6e <DMA1_Stream2_IRQHandler+0x16>
 8102c64:	4b03      	ldr	r3, [pc, #12]	; (8102c74 <DMA1_Stream2_IRQHandler+0x1c>)
 8102c66:	689b      	ldr	r3, [r3, #8]
 8102c68:	4618      	mov	r0, r3
 8102c6a:	f7ff fee9 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102c6e:	bf00      	nop
 8102c70:	bd80      	pop	{r7, pc}
 8102c72:	bf00      	nop
 8102c74:	10003464 	.word	0x10003464

08102c78 <DMA1_Stream3_IRQHandler>:
void DMA1_Stream3_IRQHandler() { if (DMACTXvectors[0x03]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x03])); }
 8102c78:	b580      	push	{r7, lr}
 8102c7a:	af00      	add	r7, sp, #0
 8102c7c:	4b05      	ldr	r3, [pc, #20]	; (8102c94 <DMA1_Stream3_IRQHandler+0x1c>)
 8102c7e:	68db      	ldr	r3, [r3, #12]
 8102c80:	2b00      	cmp	r3, #0
 8102c82:	d004      	beq.n	8102c8e <DMA1_Stream3_IRQHandler+0x16>
 8102c84:	4b03      	ldr	r3, [pc, #12]	; (8102c94 <DMA1_Stream3_IRQHandler+0x1c>)
 8102c86:	68db      	ldr	r3, [r3, #12]
 8102c88:	4618      	mov	r0, r3
 8102c8a:	f7ff fed9 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102c8e:	bf00      	nop
 8102c90:	bd80      	pop	{r7, pc}
 8102c92:	bf00      	nop
 8102c94:	10003464 	.word	0x10003464

08102c98 <DMA1_Stream4_IRQHandler>:
void DMA1_Stream4_IRQHandler() { if (DMACTXvectors[0x04]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x04])); }
 8102c98:	b580      	push	{r7, lr}
 8102c9a:	af00      	add	r7, sp, #0
 8102c9c:	4b05      	ldr	r3, [pc, #20]	; (8102cb4 <DMA1_Stream4_IRQHandler+0x1c>)
 8102c9e:	691b      	ldr	r3, [r3, #16]
 8102ca0:	2b00      	cmp	r3, #0
 8102ca2:	d004      	beq.n	8102cae <DMA1_Stream4_IRQHandler+0x16>
 8102ca4:	4b03      	ldr	r3, [pc, #12]	; (8102cb4 <DMA1_Stream4_IRQHandler+0x1c>)
 8102ca6:	691b      	ldr	r3, [r3, #16]
 8102ca8:	4618      	mov	r0, r3
 8102caa:	f7ff fec9 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102cae:	bf00      	nop
 8102cb0:	bd80      	pop	{r7, pc}
 8102cb2:	bf00      	nop
 8102cb4:	10003464 	.word	0x10003464

08102cb8 <DMA1_Stream5_IRQHandler>:
void DMA1_Stream5_IRQHandler() { if (DMACTXvectors[0x05]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x05])); }
 8102cb8:	b580      	push	{r7, lr}
 8102cba:	af00      	add	r7, sp, #0
 8102cbc:	4b05      	ldr	r3, [pc, #20]	; (8102cd4 <DMA1_Stream5_IRQHandler+0x1c>)
 8102cbe:	695b      	ldr	r3, [r3, #20]
 8102cc0:	2b00      	cmp	r3, #0
 8102cc2:	d004      	beq.n	8102cce <DMA1_Stream5_IRQHandler+0x16>
 8102cc4:	4b03      	ldr	r3, [pc, #12]	; (8102cd4 <DMA1_Stream5_IRQHandler+0x1c>)
 8102cc6:	695b      	ldr	r3, [r3, #20]
 8102cc8:	4618      	mov	r0, r3
 8102cca:	f7ff feb9 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102cce:	bf00      	nop
 8102cd0:	bd80      	pop	{r7, pc}
 8102cd2:	bf00      	nop
 8102cd4:	10003464 	.word	0x10003464

08102cd8 <DMA1_Stream6_IRQHandler>:
void DMA1_Stream6_IRQHandler() { if (DMACTXvectors[0x06]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x06])); }
 8102cd8:	b580      	push	{r7, lr}
 8102cda:	af00      	add	r7, sp, #0
 8102cdc:	4b05      	ldr	r3, [pc, #20]	; (8102cf4 <DMA1_Stream6_IRQHandler+0x1c>)
 8102cde:	699b      	ldr	r3, [r3, #24]
 8102ce0:	2b00      	cmp	r3, #0
 8102ce2:	d004      	beq.n	8102cee <DMA1_Stream6_IRQHandler+0x16>
 8102ce4:	4b03      	ldr	r3, [pc, #12]	; (8102cf4 <DMA1_Stream6_IRQHandler+0x1c>)
 8102ce6:	699b      	ldr	r3, [r3, #24]
 8102ce8:	4618      	mov	r0, r3
 8102cea:	f7ff fea9 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102cee:	bf00      	nop
 8102cf0:	bd80      	pop	{r7, pc}
 8102cf2:	bf00      	nop
 8102cf4:	10003464 	.word	0x10003464

08102cf8 <DMA1_Stream7_IRQHandler>:
void DMA1_Stream7_IRQHandler() { if (DMACTXvectors[0x07]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x07])); }
 8102cf8:	b580      	push	{r7, lr}
 8102cfa:	af00      	add	r7, sp, #0
 8102cfc:	4b05      	ldr	r3, [pc, #20]	; (8102d14 <DMA1_Stream7_IRQHandler+0x1c>)
 8102cfe:	69db      	ldr	r3, [r3, #28]
 8102d00:	2b00      	cmp	r3, #0
 8102d02:	d004      	beq.n	8102d0e <DMA1_Stream7_IRQHandler+0x16>
 8102d04:	4b03      	ldr	r3, [pc, #12]	; (8102d14 <DMA1_Stream7_IRQHandler+0x1c>)
 8102d06:	69db      	ldr	r3, [r3, #28]
 8102d08:	4618      	mov	r0, r3
 8102d0a:	f7ff fe99 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102d0e:	bf00      	nop
 8102d10:	bd80      	pop	{r7, pc}
 8102d12:	bf00      	nop
 8102d14:	10003464 	.word	0x10003464

08102d18 <DMA2_Stream0_IRQHandler>:

void DMA2_Stream0_IRQHandler() { if (DMACTXvectors[0x08]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x08])); }
 8102d18:	b580      	push	{r7, lr}
 8102d1a:	af00      	add	r7, sp, #0
 8102d1c:	4b05      	ldr	r3, [pc, #20]	; (8102d34 <DMA2_Stream0_IRQHandler+0x1c>)
 8102d1e:	6a1b      	ldr	r3, [r3, #32]
 8102d20:	2b00      	cmp	r3, #0
 8102d22:	d004      	beq.n	8102d2e <DMA2_Stream0_IRQHandler+0x16>
 8102d24:	4b03      	ldr	r3, [pc, #12]	; (8102d34 <DMA2_Stream0_IRQHandler+0x1c>)
 8102d26:	6a1b      	ldr	r3, [r3, #32]
 8102d28:	4618      	mov	r0, r3
 8102d2a:	f7ff fe89 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102d2e:	bf00      	nop
 8102d30:	bd80      	pop	{r7, pc}
 8102d32:	bf00      	nop
 8102d34:	10003464 	.word	0x10003464

08102d38 <DMA2_Stream1_IRQHandler>:
void DMA2_Stream1_IRQHandler() { if (DMACTXvectors[0x09]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x09])); }
 8102d38:	b580      	push	{r7, lr}
 8102d3a:	af00      	add	r7, sp, #0
 8102d3c:	4b05      	ldr	r3, [pc, #20]	; (8102d54 <DMA2_Stream1_IRQHandler+0x1c>)
 8102d3e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8102d40:	2b00      	cmp	r3, #0
 8102d42:	d004      	beq.n	8102d4e <DMA2_Stream1_IRQHandler+0x16>
 8102d44:	4b03      	ldr	r3, [pc, #12]	; (8102d54 <DMA2_Stream1_IRQHandler+0x1c>)
 8102d46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8102d48:	4618      	mov	r0, r3
 8102d4a:	f7ff fe79 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102d4e:	bf00      	nop
 8102d50:	bd80      	pop	{r7, pc}
 8102d52:	bf00      	nop
 8102d54:	10003464 	.word	0x10003464

08102d58 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler() { if (DMACTXvectors[0x0A]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x0A])); }
 8102d58:	b580      	push	{r7, lr}
 8102d5a:	af00      	add	r7, sp, #0
 8102d5c:	4b05      	ldr	r3, [pc, #20]	; (8102d74 <DMA2_Stream2_IRQHandler+0x1c>)
 8102d5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8102d60:	2b00      	cmp	r3, #0
 8102d62:	d004      	beq.n	8102d6e <DMA2_Stream2_IRQHandler+0x16>
 8102d64:	4b03      	ldr	r3, [pc, #12]	; (8102d74 <DMA2_Stream2_IRQHandler+0x1c>)
 8102d66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8102d68:	4618      	mov	r0, r3
 8102d6a:	f7ff fe69 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102d6e:	bf00      	nop
 8102d70:	bd80      	pop	{r7, pc}
 8102d72:	bf00      	nop
 8102d74:	10003464 	.word	0x10003464

08102d78 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler() { if (DMACTXvectors[0x0B]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x0B])); }
 8102d78:	b580      	push	{r7, lr}
 8102d7a:	af00      	add	r7, sp, #0
 8102d7c:	4b05      	ldr	r3, [pc, #20]	; (8102d94 <DMA2_Stream3_IRQHandler+0x1c>)
 8102d7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8102d80:	2b00      	cmp	r3, #0
 8102d82:	d004      	beq.n	8102d8e <DMA2_Stream3_IRQHandler+0x16>
 8102d84:	4b03      	ldr	r3, [pc, #12]	; (8102d94 <DMA2_Stream3_IRQHandler+0x1c>)
 8102d86:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8102d88:	4618      	mov	r0, r3
 8102d8a:	f7ff fe59 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102d8e:	bf00      	nop
 8102d90:	bd80      	pop	{r7, pc}
 8102d92:	bf00      	nop
 8102d94:	10003464 	.word	0x10003464

08102d98 <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler() { if (DMACTXvectors[0x0C]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x0C])); }
 8102d98:	b580      	push	{r7, lr}
 8102d9a:	af00      	add	r7, sp, #0
 8102d9c:	4b05      	ldr	r3, [pc, #20]	; (8102db4 <DMA2_Stream4_IRQHandler+0x1c>)
 8102d9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8102da0:	2b00      	cmp	r3, #0
 8102da2:	d004      	beq.n	8102dae <DMA2_Stream4_IRQHandler+0x16>
 8102da4:	4b03      	ldr	r3, [pc, #12]	; (8102db4 <DMA2_Stream4_IRQHandler+0x1c>)
 8102da6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8102da8:	4618      	mov	r0, r3
 8102daa:	f7ff fe49 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102dae:	bf00      	nop
 8102db0:	bd80      	pop	{r7, pc}
 8102db2:	bf00      	nop
 8102db4:	10003464 	.word	0x10003464

08102db8 <DMA2_Stream5_IRQHandler>:
void DMA2_Stream5_IRQHandler() { if (DMACTXvectors[0x0D]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x0D])); }
 8102db8:	b580      	push	{r7, lr}
 8102dba:	af00      	add	r7, sp, #0
 8102dbc:	4b05      	ldr	r3, [pc, #20]	; (8102dd4 <DMA2_Stream5_IRQHandler+0x1c>)
 8102dbe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8102dc0:	2b00      	cmp	r3, #0
 8102dc2:	d004      	beq.n	8102dce <DMA2_Stream5_IRQHandler+0x16>
 8102dc4:	4b03      	ldr	r3, [pc, #12]	; (8102dd4 <DMA2_Stream5_IRQHandler+0x1c>)
 8102dc6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8102dc8:	4618      	mov	r0, r3
 8102dca:	f7ff fe39 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102dce:	bf00      	nop
 8102dd0:	bd80      	pop	{r7, pc}
 8102dd2:	bf00      	nop
 8102dd4:	10003464 	.word	0x10003464

08102dd8 <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler() { if (DMACTXvectors[0x0E]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x0E])); }
 8102dd8:	b580      	push	{r7, lr}
 8102dda:	af00      	add	r7, sp, #0
 8102ddc:	4b05      	ldr	r3, [pc, #20]	; (8102df4 <DMA2_Stream6_IRQHandler+0x1c>)
 8102dde:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8102de0:	2b00      	cmp	r3, #0
 8102de2:	d004      	beq.n	8102dee <DMA2_Stream6_IRQHandler+0x16>
 8102de4:	4b03      	ldr	r3, [pc, #12]	; (8102df4 <DMA2_Stream6_IRQHandler+0x1c>)
 8102de6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8102de8:	4618      	mov	r0, r3
 8102dea:	f7ff fe29 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102dee:	bf00      	nop
 8102df0:	bd80      	pop	{r7, pc}
 8102df2:	bf00      	nop
 8102df4:	10003464 	.word	0x10003464

08102df8 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler() { if (DMACTXvectors[0x0F]>0) DMA_Stream_IRQHandler((TxRxContext_TypeDef *)(DMACTXvectors[0x0F])); }
 8102df8:	b580      	push	{r7, lr}
 8102dfa:	af00      	add	r7, sp, #0
 8102dfc:	4b05      	ldr	r3, [pc, #20]	; (8102e14 <DMA2_Stream7_IRQHandler+0x1c>)
 8102dfe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8102e00:	2b00      	cmp	r3, #0
 8102e02:	d004      	beq.n	8102e0e <DMA2_Stream7_IRQHandler+0x16>
 8102e04:	4b03      	ldr	r3, [pc, #12]	; (8102e14 <DMA2_Stream7_IRQHandler+0x1c>)
 8102e06:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8102e08:	4618      	mov	r0, r3
 8102e0a:	f7ff fe19 	bl	8102a40 <DMA_Stream_IRQHandler>
 8102e0e:	bf00      	nop
 8102e10:	bd80      	pop	{r7, pc}
 8102e12:	bf00      	nop
 8102e14:	10003464 	.word	0x10003464

08102e18 <BSP_STM32_GPIO_Init>:
#define EXTI_CPU1             (0x01000000U)
#define EXTI_CPU2             (0x02000000U)
#endif /*DUAL_CORE*/


uint8_t BSP_STM32_GPIO_Init(GPIO_TypeDef  *GPIOx, uint32_t Pins, uint32_t Mode, uint32_t Pull, uint32_t Speed, uint32_t Alternate) {
 8102e18:	b480      	push	{r7}
 8102e1a:	b089      	sub	sp, #36	; 0x24
 8102e1c:	af00      	add	r7, sp, #0
 8102e1e:	60f8      	str	r0, [r7, #12]
 8102e20:	60b9      	str	r1, [r7, #8]
 8102e22:	607a      	str	r2, [r7, #4]
 8102e24:	603b      	str	r3, [r7, #0]

	uint32_t position = 0x00U;
 8102e26:	2300      	movs	r3, #0
 8102e28:	61fb      	str	r3, [r7, #28]
	uint32_t iocurrent;
	uint32_t temp;
	EXTI_Core_TypeDef *EXTI_CurrentCPU;

	#if defined(DUAL_CORE) && defined(CORE_CM4)
		EXTI_CurrentCPU = EXTI_D2; // EXTI for CM4 CPU
 8102e2a:	4b7c      	ldr	r3, [pc, #496]	; (810301c <BSP_STM32_GPIO_Init+0x204>)
 8102e2c:	617b      	str	r3, [r7, #20]
	#else
		EXTI_CurrentCPU = EXTI_D1; // EXTI for CM7 CPU
	#endif

	// Configure the port pins
	while (((Pins) >> position) != 0x00U) {
 8102e2e:	e174      	b.n	810311a <BSP_STM32_GPIO_Init+0x302>

		// Get current io position
	    iocurrent = (Pins) & (1UL << position);
 8102e30:	2201      	movs	r2, #1
 8102e32:	69fb      	ldr	r3, [r7, #28]
 8102e34:	fa02 f303 	lsl.w	r3, r2, r3
 8102e38:	68ba      	ldr	r2, [r7, #8]
 8102e3a:	4013      	ands	r3, r2
 8102e3c:	613b      	str	r3, [r7, #16]

	    if (iocurrent != 0x00U) {
 8102e3e:	693b      	ldr	r3, [r7, #16]
 8102e40:	2b00      	cmp	r3, #0
 8102e42:	f000 8167 	beq.w	8103114 <BSP_STM32_GPIO_Init+0x2fc>

	      // --------------------- GPIO Mode Configuration ------------------------
	      // In case of Output or Alternate function mode selection

	      if (((Mode & GPIO_MODE) == MODE_OUTPUT) || ((Mode & GPIO_MODE) == MODE_AF)) {
 8102e46:	687b      	ldr	r3, [r7, #4]
 8102e48:	f003 0303 	and.w	r3, r3, #3
 8102e4c:	2b01      	cmp	r3, #1
 8102e4e:	d004      	beq.n	8102e5a <BSP_STM32_GPIO_Init+0x42>
 8102e50:	687b      	ldr	r3, [r7, #4]
 8102e52:	f003 0303 	and.w	r3, r3, #3
 8102e56:	2b02      	cmp	r3, #2
 8102e58:	d12e      	bne.n	8102eb8 <BSP_STM32_GPIO_Init+0xa0>

	    	  // Configure the IO Speed
	    	  temp = GPIOx->OSPEEDR;
 8102e5a:	68fb      	ldr	r3, [r7, #12]
 8102e5c:	689b      	ldr	r3, [r3, #8]
 8102e5e:	61bb      	str	r3, [r7, #24]
	    	  temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8102e60:	69fb      	ldr	r3, [r7, #28]
 8102e62:	005b      	lsls	r3, r3, #1
 8102e64:	2203      	movs	r2, #3
 8102e66:	fa02 f303 	lsl.w	r3, r2, r3
 8102e6a:	43db      	mvns	r3, r3
 8102e6c:	69ba      	ldr	r2, [r7, #24]
 8102e6e:	4013      	ands	r3, r2
 8102e70:	61bb      	str	r3, [r7, #24]
	    	  temp |= (Speed << (position * 2U));
 8102e72:	69fb      	ldr	r3, [r7, #28]
 8102e74:	005b      	lsls	r3, r3, #1
 8102e76:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8102e78:	fa02 f303 	lsl.w	r3, r2, r3
 8102e7c:	69ba      	ldr	r2, [r7, #24]
 8102e7e:	4313      	orrs	r3, r2
 8102e80:	61bb      	str	r3, [r7, #24]
	    	  GPIOx->OSPEEDR = temp;
 8102e82:	68fb      	ldr	r3, [r7, #12]
 8102e84:	69ba      	ldr	r2, [r7, #24]
 8102e86:	609a      	str	r2, [r3, #8]

	    	  // Configure the IO Output Type
	    	  temp = GPIOx->OTYPER;
 8102e88:	68fb      	ldr	r3, [r7, #12]
 8102e8a:	685b      	ldr	r3, [r3, #4]
 8102e8c:	61bb      	str	r3, [r7, #24]
	    	  temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8102e8e:	2201      	movs	r2, #1
 8102e90:	69fb      	ldr	r3, [r7, #28]
 8102e92:	fa02 f303 	lsl.w	r3, r2, r3
 8102e96:	43db      	mvns	r3, r3
 8102e98:	69ba      	ldr	r2, [r7, #24]
 8102e9a:	4013      	ands	r3, r2
 8102e9c:	61bb      	str	r3, [r7, #24]
	    	  temp |= (((Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8102e9e:	687b      	ldr	r3, [r7, #4]
 8102ea0:	091b      	lsrs	r3, r3, #4
 8102ea2:	f003 0201 	and.w	r2, r3, #1
 8102ea6:	69fb      	ldr	r3, [r7, #28]
 8102ea8:	fa02 f303 	lsl.w	r3, r2, r3
 8102eac:	69ba      	ldr	r2, [r7, #24]
 8102eae:	4313      	orrs	r3, r2
 8102eb0:	61bb      	str	r3, [r7, #24]
	    	  GPIOx->OTYPER = temp;
 8102eb2:	68fb      	ldr	r3, [r7, #12]
 8102eb4:	69ba      	ldr	r2, [r7, #24]
 8102eb6:	605a      	str	r2, [r3, #4]
	      }

	      if ((Mode & GPIO_MODE) != MODE_ANALOG) {
 8102eb8:	687b      	ldr	r3, [r7, #4]
 8102eba:	f003 0303 	and.w	r3, r3, #3
 8102ebe:	2b03      	cmp	r3, #3
 8102ec0:	d016      	beq.n	8102ef0 <BSP_STM32_GPIO_Init+0xd8>

	    	  // Activate the Pull-up or Pull down resistor for the current IO
	    	  temp = GPIOx->PUPDR;
 8102ec2:	68fb      	ldr	r3, [r7, #12]
 8102ec4:	68db      	ldr	r3, [r3, #12]
 8102ec6:	61bb      	str	r3, [r7, #24]
	    	  temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8102ec8:	69fb      	ldr	r3, [r7, #28]
 8102eca:	005b      	lsls	r3, r3, #1
 8102ecc:	2203      	movs	r2, #3
 8102ece:	fa02 f303 	lsl.w	r3, r2, r3
 8102ed2:	43db      	mvns	r3, r3
 8102ed4:	69ba      	ldr	r2, [r7, #24]
 8102ed6:	4013      	ands	r3, r2
 8102ed8:	61bb      	str	r3, [r7, #24]
	    	  temp |= ((Pull) << (position * 2U));
 8102eda:	69fb      	ldr	r3, [r7, #28]
 8102edc:	005b      	lsls	r3, r3, #1
 8102ede:	683a      	ldr	r2, [r7, #0]
 8102ee0:	fa02 f303 	lsl.w	r3, r2, r3
 8102ee4:	69ba      	ldr	r2, [r7, #24]
 8102ee6:	4313      	orrs	r3, r2
 8102ee8:	61bb      	str	r3, [r7, #24]
	    	  GPIOx->PUPDR = temp;
 8102eea:	68fb      	ldr	r3, [r7, #12]
 8102eec:	69ba      	ldr	r2, [r7, #24]
 8102eee:	60da      	str	r2, [r3, #12]

	      }

	      // In case of Alternate function mode selection
	      if ((Mode & GPIO_MODE) == MODE_AF) {
 8102ef0:	687b      	ldr	r3, [r7, #4]
 8102ef2:	f003 0303 	and.w	r3, r3, #3
 8102ef6:	2b02      	cmp	r3, #2
 8102ef8:	d122      	bne.n	8102f40 <BSP_STM32_GPIO_Init+0x128>

	    	  // Configure Alternate function mapped with the current IO
	    	  temp = GPIOx->AFR[position >> 3U];
 8102efa:	69fb      	ldr	r3, [r7, #28]
 8102efc:	08da      	lsrs	r2, r3, #3
 8102efe:	68fb      	ldr	r3, [r7, #12]
 8102f00:	3208      	adds	r2, #8
 8102f02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8102f06:	61bb      	str	r3, [r7, #24]
	    	  temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8102f08:	69fb      	ldr	r3, [r7, #28]
 8102f0a:	f003 0307 	and.w	r3, r3, #7
 8102f0e:	009b      	lsls	r3, r3, #2
 8102f10:	220f      	movs	r2, #15
 8102f12:	fa02 f303 	lsl.w	r3, r2, r3
 8102f16:	43db      	mvns	r3, r3
 8102f18:	69ba      	ldr	r2, [r7, #24]
 8102f1a:	4013      	ands	r3, r2
 8102f1c:	61bb      	str	r3, [r7, #24]
	    	  temp |= ((Alternate) << ((position & 0x07U) * 4U));
 8102f1e:	69fb      	ldr	r3, [r7, #28]
 8102f20:	f003 0307 	and.w	r3, r3, #7
 8102f24:	009b      	lsls	r3, r3, #2
 8102f26:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8102f28:	fa02 f303 	lsl.w	r3, r2, r3
 8102f2c:	69ba      	ldr	r2, [r7, #24]
 8102f2e:	4313      	orrs	r3, r2
 8102f30:	61bb      	str	r3, [r7, #24]
	    	  GPIOx->AFR[position >> 3U] = temp;
 8102f32:	69fb      	ldr	r3, [r7, #28]
 8102f34:	08da      	lsrs	r2, r3, #3
 8102f36:	68fb      	ldr	r3, [r7, #12]
 8102f38:	3208      	adds	r2, #8
 8102f3a:	69b9      	ldr	r1, [r7, #24]
 8102f3c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

	      }

	      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
	      temp = GPIOx->MODER;
 8102f40:	68fb      	ldr	r3, [r7, #12]
 8102f42:	681b      	ldr	r3, [r3, #0]
 8102f44:	61bb      	str	r3, [r7, #24]
	      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8102f46:	69fb      	ldr	r3, [r7, #28]
 8102f48:	005b      	lsls	r3, r3, #1
 8102f4a:	2203      	movs	r2, #3
 8102f4c:	fa02 f303 	lsl.w	r3, r2, r3
 8102f50:	43db      	mvns	r3, r3
 8102f52:	69ba      	ldr	r2, [r7, #24]
 8102f54:	4013      	ands	r3, r2
 8102f56:	61bb      	str	r3, [r7, #24]
	      temp |= ((Mode & GPIO_MODE) << (position * 2U));
 8102f58:	687b      	ldr	r3, [r7, #4]
 8102f5a:	f003 0203 	and.w	r2, r3, #3
 8102f5e:	69fb      	ldr	r3, [r7, #28]
 8102f60:	005b      	lsls	r3, r3, #1
 8102f62:	fa02 f303 	lsl.w	r3, r2, r3
 8102f66:	69ba      	ldr	r2, [r7, #24]
 8102f68:	4313      	orrs	r3, r2
 8102f6a:	61bb      	str	r3, [r7, #24]
	      GPIOx->MODER = temp;
 8102f6c:	68fb      	ldr	r3, [r7, #12]
 8102f6e:	69ba      	ldr	r2, [r7, #24]
 8102f70:	601a      	str	r2, [r3, #0]

	      //--------------------- EXTI Mode Configuration ------------------------
	      // Configure the External Interrupt or event for the current IO

	      if ((Mode & EXTI_MODE) != 0x00U) {
 8102f72:	687b      	ldr	r3, [r7, #4]
 8102f74:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8102f78:	2b00      	cmp	r3, #0
 8102f7a:	f000 80cb 	beq.w	8103114 <BSP_STM32_GPIO_Init+0x2fc>

	        temp = SYSCFG->EXTICR[position >> 2U];
 8102f7e:	4a28      	ldr	r2, [pc, #160]	; (8103020 <BSP_STM32_GPIO_Init+0x208>)
 8102f80:	69fb      	ldr	r3, [r7, #28]
 8102f82:	089b      	lsrs	r3, r3, #2
 8102f84:	3302      	adds	r3, #2
 8102f86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8102f8a:	61bb      	str	r3, [r7, #24]
	        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8102f8c:	69fb      	ldr	r3, [r7, #28]
 8102f8e:	f003 0303 	and.w	r3, r3, #3
 8102f92:	009b      	lsls	r3, r3, #2
 8102f94:	220f      	movs	r2, #15
 8102f96:	fa02 f303 	lsl.w	r3, r2, r3
 8102f9a:	43db      	mvns	r3, r3
 8102f9c:	69ba      	ldr	r2, [r7, #24]
 8102f9e:	4013      	ands	r3, r2
 8102fa0:	61bb      	str	r3, [r7, #24]
	        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8102fa2:	68fb      	ldr	r3, [r7, #12]
 8102fa4:	4a1f      	ldr	r2, [pc, #124]	; (8103024 <BSP_STM32_GPIO_Init+0x20c>)
 8102fa6:	4293      	cmp	r3, r2
 8102fa8:	d050      	beq.n	810304c <BSP_STM32_GPIO_Init+0x234>
 8102faa:	68fb      	ldr	r3, [r7, #12]
 8102fac:	4a1e      	ldr	r2, [pc, #120]	; (8103028 <BSP_STM32_GPIO_Init+0x210>)
 8102fae:	4293      	cmp	r3, r2
 8102fb0:	d031      	beq.n	8103016 <BSP_STM32_GPIO_Init+0x1fe>
 8102fb2:	68fb      	ldr	r3, [r7, #12]
 8102fb4:	4a1d      	ldr	r2, [pc, #116]	; (810302c <BSP_STM32_GPIO_Init+0x214>)
 8102fb6:	4293      	cmp	r3, r2
 8102fb8:	d02b      	beq.n	8103012 <BSP_STM32_GPIO_Init+0x1fa>
 8102fba:	68fb      	ldr	r3, [r7, #12]
 8102fbc:	4a1c      	ldr	r2, [pc, #112]	; (8103030 <BSP_STM32_GPIO_Init+0x218>)
 8102fbe:	4293      	cmp	r3, r2
 8102fc0:	d025      	beq.n	810300e <BSP_STM32_GPIO_Init+0x1f6>
 8102fc2:	68fb      	ldr	r3, [r7, #12]
 8102fc4:	4a1b      	ldr	r2, [pc, #108]	; (8103034 <BSP_STM32_GPIO_Init+0x21c>)
 8102fc6:	4293      	cmp	r3, r2
 8102fc8:	d01f      	beq.n	810300a <BSP_STM32_GPIO_Init+0x1f2>
 8102fca:	68fb      	ldr	r3, [r7, #12]
 8102fcc:	4a1a      	ldr	r2, [pc, #104]	; (8103038 <BSP_STM32_GPIO_Init+0x220>)
 8102fce:	4293      	cmp	r3, r2
 8102fd0:	d019      	beq.n	8103006 <BSP_STM32_GPIO_Init+0x1ee>
 8102fd2:	68fb      	ldr	r3, [r7, #12]
 8102fd4:	4a19      	ldr	r2, [pc, #100]	; (810303c <BSP_STM32_GPIO_Init+0x224>)
 8102fd6:	4293      	cmp	r3, r2
 8102fd8:	d013      	beq.n	8103002 <BSP_STM32_GPIO_Init+0x1ea>
 8102fda:	68fb      	ldr	r3, [r7, #12]
 8102fdc:	4a18      	ldr	r2, [pc, #96]	; (8103040 <BSP_STM32_GPIO_Init+0x228>)
 8102fde:	4293      	cmp	r3, r2
 8102fe0:	d00d      	beq.n	8102ffe <BSP_STM32_GPIO_Init+0x1e6>
 8102fe2:	68fb      	ldr	r3, [r7, #12]
 8102fe4:	4a17      	ldr	r2, [pc, #92]	; (8103044 <BSP_STM32_GPIO_Init+0x22c>)
 8102fe6:	4293      	cmp	r3, r2
 8102fe8:	d007      	beq.n	8102ffa <BSP_STM32_GPIO_Init+0x1e2>
 8102fea:	68fb      	ldr	r3, [r7, #12]
 8102fec:	4a16      	ldr	r2, [pc, #88]	; (8103048 <BSP_STM32_GPIO_Init+0x230>)
 8102fee:	4293      	cmp	r3, r2
 8102ff0:	d101      	bne.n	8102ff6 <BSP_STM32_GPIO_Init+0x1de>
 8102ff2:	2309      	movs	r3, #9
 8102ff4:	e02b      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 8102ff6:	230a      	movs	r3, #10
 8102ff8:	e029      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 8102ffa:	2308      	movs	r3, #8
 8102ffc:	e027      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 8102ffe:	2307      	movs	r3, #7
 8103000:	e025      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 8103002:	2306      	movs	r3, #6
 8103004:	e023      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 8103006:	2305      	movs	r3, #5
 8103008:	e021      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 810300a:	2304      	movs	r3, #4
 810300c:	e01f      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 810300e:	2303      	movs	r3, #3
 8103010:	e01d      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 8103012:	2302      	movs	r3, #2
 8103014:	e01b      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 8103016:	2301      	movs	r3, #1
 8103018:	e019      	b.n	810304e <BSP_STM32_GPIO_Init+0x236>
 810301a:	bf00      	nop
 810301c:	580000c0 	.word	0x580000c0
 8103020:	58000400 	.word	0x58000400
 8103024:	58020000 	.word	0x58020000
 8103028:	58020400 	.word	0x58020400
 810302c:	58020800 	.word	0x58020800
 8103030:	58020c00 	.word	0x58020c00
 8103034:	58021000 	.word	0x58021000
 8103038:	58021400 	.word	0x58021400
 810303c:	58021800 	.word	0x58021800
 8103040:	58021c00 	.word	0x58021c00
 8103044:	58022000 	.word	0x58022000
 8103048:	58022400 	.word	0x58022400
 810304c:	2300      	movs	r3, #0
 810304e:	69fa      	ldr	r2, [r7, #28]
 8103050:	f002 0203 	and.w	r2, r2, #3
 8103054:	0092      	lsls	r2, r2, #2
 8103056:	4093      	lsls	r3, r2
 8103058:	69ba      	ldr	r2, [r7, #24]
 810305a:	4313      	orrs	r3, r2
 810305c:	61bb      	str	r3, [r7, #24]
	        SYSCFG->EXTICR[position >> 2U] = temp;
 810305e:	4936      	ldr	r1, [pc, #216]	; (8103138 <BSP_STM32_GPIO_Init+0x320>)
 8103060:	69fb      	ldr	r3, [r7, #28]
 8103062:	089b      	lsrs	r3, r3, #2
 8103064:	3302      	adds	r3, #2
 8103066:	69ba      	ldr	r2, [r7, #24]
 8103068:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	        // Clear Rising Falling edge configuration
	        temp = EXTI->RTSR1;
 810306c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8103070:	681b      	ldr	r3, [r3, #0]
 8103072:	61bb      	str	r3, [r7, #24]
	        temp &= ~(iocurrent);
 8103074:	693b      	ldr	r3, [r7, #16]
 8103076:	43db      	mvns	r3, r3
 8103078:	69ba      	ldr	r2, [r7, #24]
 810307a:	4013      	ands	r3, r2
 810307c:	61bb      	str	r3, [r7, #24]
	        if ((Mode & TRIGGER_RISING) != 0x00U) temp |= iocurrent;
 810307e:	687b      	ldr	r3, [r7, #4]
 8103080:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8103084:	2b00      	cmp	r3, #0
 8103086:	d003      	beq.n	8103090 <BSP_STM32_GPIO_Init+0x278>
 8103088:	69ba      	ldr	r2, [r7, #24]
 810308a:	693b      	ldr	r3, [r7, #16]
 810308c:	4313      	orrs	r3, r2
 810308e:	61bb      	str	r3, [r7, #24]
	        EXTI->RTSR1 = temp;
 8103090:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8103094:	69bb      	ldr	r3, [r7, #24]
 8103096:	6013      	str	r3, [r2, #0]

	        temp = EXTI->FTSR1;
 8103098:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 810309c:	685b      	ldr	r3, [r3, #4]
 810309e:	61bb      	str	r3, [r7, #24]
	        temp &= ~(iocurrent);
 81030a0:	693b      	ldr	r3, [r7, #16]
 81030a2:	43db      	mvns	r3, r3
 81030a4:	69ba      	ldr	r2, [r7, #24]
 81030a6:	4013      	ands	r3, r2
 81030a8:	61bb      	str	r3, [r7, #24]
	        if ((Mode & TRIGGER_FALLING) != 0x00U) temp |= iocurrent;
 81030aa:	687b      	ldr	r3, [r7, #4]
 81030ac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 81030b0:	2b00      	cmp	r3, #0
 81030b2:	d003      	beq.n	81030bc <BSP_STM32_GPIO_Init+0x2a4>
 81030b4:	69ba      	ldr	r2, [r7, #24]
 81030b6:	693b      	ldr	r3, [r7, #16]
 81030b8:	4313      	orrs	r3, r2
 81030ba:	61bb      	str	r3, [r7, #24]
	        EXTI->FTSR1 = temp;
 81030bc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 81030c0:	69bb      	ldr	r3, [r7, #24]
 81030c2:	6053      	str	r3, [r2, #4]

	        temp = EXTI_CurrentCPU->EMR1;
 81030c4:	697b      	ldr	r3, [r7, #20]
 81030c6:	685b      	ldr	r3, [r3, #4]
 81030c8:	61bb      	str	r3, [r7, #24]
	        temp &= ~(iocurrent);
 81030ca:	693b      	ldr	r3, [r7, #16]
 81030cc:	43db      	mvns	r3, r3
 81030ce:	69ba      	ldr	r2, [r7, #24]
 81030d0:	4013      	ands	r3, r2
 81030d2:	61bb      	str	r3, [r7, #24]
	        if ((Mode & EXTI_EVT) != 0x00U) temp |= iocurrent;
 81030d4:	687b      	ldr	r3, [r7, #4]
 81030d6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 81030da:	2b00      	cmp	r3, #0
 81030dc:	d003      	beq.n	81030e6 <BSP_STM32_GPIO_Init+0x2ce>
 81030de:	69ba      	ldr	r2, [r7, #24]
 81030e0:	693b      	ldr	r3, [r7, #16]
 81030e2:	4313      	orrs	r3, r2
 81030e4:	61bb      	str	r3, [r7, #24]
	        EXTI_CurrentCPU->EMR1 = temp;
 81030e6:	697b      	ldr	r3, [r7, #20]
 81030e8:	69ba      	ldr	r2, [r7, #24]
 81030ea:	605a      	str	r2, [r3, #4]

	        // Clear EXTI line configuration
	        temp = EXTI_CurrentCPU->IMR1;
 81030ec:	697b      	ldr	r3, [r7, #20]
 81030ee:	681b      	ldr	r3, [r3, #0]
 81030f0:	61bb      	str	r3, [r7, #24]
	        temp &= ~(iocurrent);
 81030f2:	693b      	ldr	r3, [r7, #16]
 81030f4:	43db      	mvns	r3, r3
 81030f6:	69ba      	ldr	r2, [r7, #24]
 81030f8:	4013      	ands	r3, r2
 81030fa:	61bb      	str	r3, [r7, #24]
	        if ((Mode & EXTI_IT) != 0x00U) temp |= iocurrent;
 81030fc:	687b      	ldr	r3, [r7, #4]
 81030fe:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8103102:	2b00      	cmp	r3, #0
 8103104:	d003      	beq.n	810310e <BSP_STM32_GPIO_Init+0x2f6>
 8103106:	69ba      	ldr	r2, [r7, #24]
 8103108:	693b      	ldr	r3, [r7, #16]
 810310a:	4313      	orrs	r3, r2
 810310c:	61bb      	str	r3, [r7, #24]
	        EXTI_CurrentCPU->IMR1 = temp;
 810310e:	697b      	ldr	r3, [r7, #20]
 8103110:	69ba      	ldr	r2, [r7, #24]
 8103112:	601a      	str	r2, [r3, #0]
	      }
	    }

	    position++;
 8103114:	69fb      	ldr	r3, [r7, #28]
 8103116:	3301      	adds	r3, #1
 8103118:	61fb      	str	r3, [r7, #28]
	while (((Pins) >> position) != 0x00U) {
 810311a:	68ba      	ldr	r2, [r7, #8]
 810311c:	69fb      	ldr	r3, [r7, #28]
 810311e:	fa22 f303 	lsr.w	r3, r2, r3
 8103122:	2b00      	cmp	r3, #0
 8103124:	f47f ae84 	bne.w	8102e30 <BSP_STM32_GPIO_Init+0x18>
	  }

	return BSP_OK;
 8103128:	2300      	movs	r3, #0
}
 810312a:	4618      	mov	r0, r3
 810312c:	3724      	adds	r7, #36	; 0x24
 810312e:	46bd      	mov	sp, r7
 8103130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103134:	4770      	bx	lr
 8103136:	bf00      	nop
 8103138:	58000400 	.word	0x58000400

0810313c <BSP_STM32_GPIO_WritePin>:

uint32_t BSP_STM32_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin) {
	return ((GPIOx->IDR & GPIO_Pin) > 0)?GPIO_PIN_SET:GPIO_PIN_RESET;
}

uint8_t BSP_STM32_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin, uint32_t PinState) {
 810313c:	b480      	push	{r7}
 810313e:	b085      	sub	sp, #20
 8103140:	af00      	add	r7, sp, #0
 8103142:	60f8      	str	r0, [r7, #12]
 8103144:	60b9      	str	r1, [r7, #8]
 8103146:	607a      	str	r2, [r7, #4]
	GPIOx->BSRR=((PinState==GPIO_PIN_SET)?GPIO_Pin:GPIO_Pin << GPIO_NUMBER);
 8103148:	687b      	ldr	r3, [r7, #4]
 810314a:	2b01      	cmp	r3, #1
 810314c:	d002      	beq.n	8103154 <BSP_STM32_GPIO_WritePin+0x18>
 810314e:	68bb      	ldr	r3, [r7, #8]
 8103150:	041b      	lsls	r3, r3, #16
 8103152:	e000      	b.n	8103156 <BSP_STM32_GPIO_WritePin+0x1a>
 8103154:	68bb      	ldr	r3, [r7, #8]
 8103156:	68fa      	ldr	r2, [r7, #12]
 8103158:	6193      	str	r3, [r2, #24]
	return BSP_OK;
 810315a:	2300      	movs	r3, #0
}
 810315c:	4618      	mov	r0, r3
 810315e:	3714      	adds	r7, #20
 8103160:	46bd      	mov	sp, r7
 8103162:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103166:	4770      	bx	lr

08103168 <BSP_STM32_HSEM_ActivateNotification>:
	// Clear the semaphore by writing to the R register: the MasterID, the ProcessID = 0 and take bit = 0
	HSEM->R[SemID] = (HSEM_CR_COREID_CURRENT);
	return BSP_OK;
}

uint8_t BSP_STM32_HSEM_ActivateNotification(uint32_t SemID) {
 8103168:	b480      	push	{r7}
 810316a:	b083      	sub	sp, #12
 810316c:	af00      	add	r7, sp, #0
 810316e:	6078      	str	r0, [r7, #4]
	// Validate input parameters
	if (SemID > 31) return BSP_ERROR;
 8103170:	687b      	ldr	r3, [r7, #4]
 8103172:	2b1f      	cmp	r3, #31
 8103174:	d901      	bls.n	810317a <BSP_STM32_HSEM_ActivateNotification+0x12>
 8103176:	2301      	movs	r3, #1
 8103178:	e00a      	b.n	8103190 <BSP_STM32_HSEM_ActivateNotification+0x28>

	HSEM_COMMON->IER |= (1 << SemID);
 810317a:	4b08      	ldr	r3, [pc, #32]	; (810319c <BSP_STM32_HSEM_ActivateNotification+0x34>)
 810317c:	681b      	ldr	r3, [r3, #0]
 810317e:	2101      	movs	r1, #1
 8103180:	687a      	ldr	r2, [r7, #4]
 8103182:	fa01 f202 	lsl.w	r2, r1, r2
 8103186:	4611      	mov	r1, r2
 8103188:	4a04      	ldr	r2, [pc, #16]	; (810319c <BSP_STM32_HSEM_ActivateNotification+0x34>)
 810318a:	430b      	orrs	r3, r1
 810318c:	6013      	str	r3, [r2, #0]
	return BSP_OK;
 810318e:	2300      	movs	r3, #0
}
 8103190:	4618      	mov	r0, r3
 8103192:	370c      	adds	r7, #12
 8103194:	46bd      	mov	sp, r7
 8103196:	f85d 7b04 	ldr.w	r7, [sp], #4
 810319a:	4770      	bx	lr
 810319c:	58026510 	.word	0x58026510

081031a0 <BSP_STM32_HSEM_ClearFlag>:

	HSEM_COMMON->IER &= ~(1 << SemID);
	return BSP_OK;
}

uint8_t BSP_STM32_HSEM_ClearFlag(uint32_t SemID) {
 81031a0:	b480      	push	{r7}
 81031a2:	b083      	sub	sp, #12
 81031a4:	af00      	add	r7, sp, #0
 81031a6:	6078      	str	r0, [r7, #4]
	// Validate input parameters
	if (SemID > 31) return BSP_ERROR;
 81031a8:	687b      	ldr	r3, [r7, #4]
 81031aa:	2b1f      	cmp	r3, #31
 81031ac:	d901      	bls.n	81031b2 <BSP_STM32_HSEM_ClearFlag+0x12>
 81031ae:	2301      	movs	r3, #1
 81031b0:	e00a      	b.n	81031c8 <BSP_STM32_HSEM_ClearFlag+0x28>

	HSEM_COMMON->ICR |= (1 << SemID);
 81031b2:	4b08      	ldr	r3, [pc, #32]	; (81031d4 <BSP_STM32_HSEM_ClearFlag+0x34>)
 81031b4:	685b      	ldr	r3, [r3, #4]
 81031b6:	2101      	movs	r1, #1
 81031b8:	687a      	ldr	r2, [r7, #4]
 81031ba:	fa01 f202 	lsl.w	r2, r1, r2
 81031be:	4611      	mov	r1, r2
 81031c0:	4a04      	ldr	r2, [pc, #16]	; (81031d4 <BSP_STM32_HSEM_ClearFlag+0x34>)
 81031c2:	430b      	orrs	r3, r1
 81031c4:	6053      	str	r3, [r2, #4]
	return BSP_OK;
 81031c6:	2300      	movs	r3, #0
}
 81031c8:	4618      	mov	r0, r3
 81031ca:	370c      	adds	r7, #12
 81031cc:	46bd      	mov	sp, r7
 81031ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 81031d2:	4770      	bx	lr
 81031d4:	58026510 	.word	0x58026510

081031d8 <BSP_STM32_I2S_Init>:
 * - 0.1b	- Development version
 *******************************************************************/

#include "BSP_STM32_I2S.h"

uint8_t BSP_STM32_I2S_Init(SPI_TypeDef * hi2s, TxRxContext_TypeDef * ctx, uint32_t AudioFreq) {
 81031d8:	b480      	push	{r7}
 81031da:	b091      	sub	sp, #68	; 0x44
 81031dc:	af00      	add	r7, sp, #0
 81031de:	60f8      	str	r0, [r7, #12]
 81031e0:	60b9      	str	r1, [r7, #8]
 81031e2:	607a      	str	r2, [r7, #4]

	I2SContext_TypeDef * i2s_ctx = (I2SContext_TypeDef *)ctx->ctxmem;
 81031e4:	68bb      	ldr	r3, [r7, #8]
 81031e6:	3328      	adds	r3, #40	; 0x28
 81031e8:	63bb      	str	r3, [r7, #56]	; 0x38

	// Data format: 16 bit / No channels: 2 (stereo) / Standard: PHILIPS
	uint32_t packetlength = 1;
 81031ea:	2301      	movs	r3, #1
 81031ec:	637b      	str	r3, [r7, #52]	; 0x34
	uint32_t ispcm = 0;
 81031ee:	2300      	movs	r3, #0
 81031f0:	633b      	str	r3, [r7, #48]	; 0x30
	uint32_t tmp, i2sodd, i2sdiv;

	// Getting PLL2P parameters and calculating I2S CLK
	uint32_t PLL2M = (RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2_Msk) >> RCC_PLLCKSELR_DIVM2_Pos;
 81031f2:	4b60      	ldr	r3, [pc, #384]	; (8103374 <BSP_STM32_I2S_Init+0x19c>)
 81031f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81031f6:	0b1b      	lsrs	r3, r3, #12
 81031f8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 81031fc:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint32_t PLL2N = ((RCC->PLL2DIVR & RCC_PLL2DIVR_N2_Msk) >> RCC_PLL2DIVR_N2_Pos) + 1;
 81031fe:	4b5d      	ldr	r3, [pc, #372]	; (8103374 <BSP_STM32_I2S_Init+0x19c>)
 8103200:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8103202:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8103206:	3301      	adds	r3, #1
 8103208:	62bb      	str	r3, [r7, #40]	; 0x28
	uint32_t PLL2P = ((RCC->PLL2DIVR & RCC_PLL2DIVR_P2_Msk) >> RCC_PLL2DIVR_P2_Pos) + 1;
 810320a:	4b5a      	ldr	r3, [pc, #360]	; (8103374 <BSP_STM32_I2S_Init+0x19c>)
 810320c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 810320e:	0a5b      	lsrs	r3, r3, #9
 8103210:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8103214:	3301      	adds	r3, #1
 8103216:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t PLLfrac = (RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2_Msk) >> RCC_PLL2FRACR_FRACN2_Pos;
 8103218:	4b56      	ldr	r3, [pc, #344]	; (8103374 <BSP_STM32_I2S_Init+0x19c>)
 810321a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 810321c:	08db      	lsrs	r3, r3, #3
 810321e:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8103222:	623b      	str	r3, [r7, #32]
	uint32_t i2sclk = (uint32_t)(((HSE_VALUE / (float)PLL2M) * ((float)PLL2N + ((float)PLLfrac / 0x2000))) / (float)PLL2P);
 8103224:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8103226:	ee07 3a90 	vmov	s15, r3
 810322a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810322e:	eddf 6a52 	vldr	s13, [pc, #328]	; 8103378 <BSP_STM32_I2S_Init+0x1a0>
 8103232:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8103236:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8103238:	ee07 3a90 	vmov	s15, r3
 810323c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8103240:	6a3b      	ldr	r3, [r7, #32]
 8103242:	ee07 3a90 	vmov	s15, r3
 8103246:	eeb8 6a67 	vcvt.f32.u32	s12, s15
 810324a:	eddf 5a4c 	vldr	s11, [pc, #304]	; 810337c <BSP_STM32_I2S_Init+0x1a4>
 810324e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8103252:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8103256:	ee67 6a27 	vmul.f32	s13, s14, s15
 810325a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810325c:	ee07 3a90 	vmov	s15, r3
 8103260:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8103264:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8103268:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 810326c:	ee17 3a90 	vmov	r3, s15
 8103270:	61fb      	str	r3, [r7, #28]

	// Disable the selected I2S peripheral
	if ((hi2s->CR1 & SPI_CR1_SPE) == SPI_CR1_SPE) CLEAR_BIT(hi2s->CR1, SPI_CR1_SPE);
 8103272:	68fb      	ldr	r3, [r7, #12]
 8103274:	681b      	ldr	r3, [r3, #0]
 8103276:	f003 0301 	and.w	r3, r3, #1
 810327a:	2b01      	cmp	r3, #1
 810327c:	d105      	bne.n	810328a <BSP_STM32_I2S_Init+0xb2>
 810327e:	68fb      	ldr	r3, [r7, #12]
 8103280:	681b      	ldr	r3, [r3, #0]
 8103282:	f023 0201 	bic.w	r2, r3, #1
 8103286:	68fb      	ldr	r3, [r7, #12]
 8103288:	601a      	str	r2, [r3, #0]

	// Clear I2S configuration register
	CLEAR_REG(hi2s->I2SCFGR);
 810328a:	68fb      	ldr	r3, [r7, #12]
 810328c:	2200      	movs	r2, #0
 810328e:	651a      	str	r2, [r3, #80]	; 0x50

	// Compute the Real divider with a floating point
	tmp = (uint32_t)((((i2sclk / ((32UL >> ispcm) * packetlength)) * 10UL) / AudioFreq) + 5UL);
 8103290:	2220      	movs	r2, #32
 8103292:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8103294:	fa22 f303 	lsr.w	r3, r2, r3
 8103298:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 810329a:	fb02 f303 	mul.w	r3, r2, r3
 810329e:	69fa      	ldr	r2, [r7, #28]
 81032a0:	fbb2 f2f3 	udiv	r2, r2, r3
 81032a4:	4613      	mov	r3, r2
 81032a6:	009b      	lsls	r3, r3, #2
 81032a8:	4413      	add	r3, r2
 81032aa:	005b      	lsls	r3, r3, #1
 81032ac:	461a      	mov	r2, r3
 81032ae:	687b      	ldr	r3, [r7, #4]
 81032b0:	fbb2 f3f3 	udiv	r3, r2, r3
 81032b4:	3305      	adds	r3, #5
 81032b6:	61bb      	str	r3, [r7, #24]
	tmp = tmp / 10UL;
 81032b8:	69bb      	ldr	r3, [r7, #24]
 81032ba:	4a31      	ldr	r2, [pc, #196]	; (8103380 <BSP_STM32_I2S_Init+0x1a8>)
 81032bc:	fba2 2303 	umull	r2, r3, r2, r3
 81032c0:	08db      	lsrs	r3, r3, #3
 81032c2:	61bb      	str	r3, [r7, #24]

    // Check the parity of the divider
	i2sodd = (uint32_t)(tmp & (uint32_t)1UL);
 81032c4:	69bb      	ldr	r3, [r7, #24]
 81032c6:	f003 0301 	and.w	r3, r3, #1
 81032ca:	63fb      	str	r3, [r7, #60]	; 0x3c

    // Compute the i2sdiv prescaler
	i2sdiv = (uint32_t)((tmp - i2sodd) / 2UL);
 81032cc:	69ba      	ldr	r2, [r7, #24]
 81032ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81032d0:	1ad3      	subs	r3, r2, r3
 81032d2:	085b      	lsrs	r3, r3, #1
 81032d4:	617b      	str	r3, [r7, #20]

	// Test if the obtain values are forbidden or out of range
	if (((i2sodd == 1UL) && (i2sdiv == 1UL)) || (i2sdiv > 0xFFUL)) return BSP_ERROR;
 81032d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 81032d8:	2b01      	cmp	r3, #1
 81032da:	d102      	bne.n	81032e2 <BSP_STM32_I2S_Init+0x10a>
 81032dc:	697b      	ldr	r3, [r7, #20]
 81032de:	2b01      	cmp	r3, #1
 81032e0:	d002      	beq.n	81032e8 <BSP_STM32_I2S_Init+0x110>
 81032e2:	697b      	ldr	r3, [r7, #20]
 81032e4:	2bff      	cmp	r3, #255	; 0xff
 81032e6:	d901      	bls.n	81032ec <BSP_STM32_I2S_Init+0x114>
 81032e8:	2301      	movs	r3, #1
 81032ea:	e03d      	b.n	8103368 <BSP_STM32_I2S_Init+0x190>

    // Force i2smod to 1 just to be sure that (2xi2sdiv + i2sodd) is always higher than 0
    if (i2sdiv == 0UL) i2sodd = 1UL;
 81032ec:	697b      	ldr	r3, [r7, #20]
 81032ee:	2b00      	cmp	r3, #0
 81032f0:	d101      	bne.n	81032f6 <BSP_STM32_I2S_Init+0x11e>
 81032f2:	2301      	movs	r3, #1
 81032f4:	63fb      	str	r3, [r7, #60]	; 0x3c

    MODIFY_REG(hi2s->I2SCFGR, (SPI_I2SCFGR_I2SDIV | SPI_I2SCFGR_ODD), ((i2sdiv << SPI_I2SCFGR_I2SDIV_Pos) | (i2sodd << SPI_I2SCFGR_ODD_Pos)));
 81032f6:	68fb      	ldr	r3, [r7, #12]
 81032f8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 81032fa:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 81032fe:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8103302:	697a      	ldr	r2, [r7, #20]
 8103304:	0411      	lsls	r1, r2, #16
 8103306:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8103308:	0612      	lsls	r2, r2, #24
 810330a:	430a      	orrs	r2, r1
 810330c:	431a      	orrs	r2, r3
 810330e:	68fb      	ldr	r3, [r7, #12]
 8103310:	651a      	str	r2, [r3, #80]	; 0x50

    // I2Sx I2SCFGR Configuration
    MODIFY_REG(hi2s->I2SCFGR, (SPI_I2SCFGR_I2SMOD | SPI_I2SCFGR_I2SCFG | SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_CKPOL | SPI_I2SCFGR_WSINV | SPI_I2SCFGR_DATFMT | SPI_I2SCFGR_MCKOE),
 8103312:	68fb      	ldr	r3, [r7, #12]
 8103314:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8103316:	4b1b      	ldr	r3, [pc, #108]	; (8103384 <BSP_STM32_I2S_Init+0x1ac>)
 8103318:	4013      	ands	r3, r2
 810331a:	f043 0205 	orr.w	r2, r3, #5
 810331e:	68fb      	ldr	r3, [r7, #12]
 8103320:	651a      	str	r2, [r3, #80]	; 0x50
    		(SPI_I2SCFGR_I2SMOD | I2S_MODE_MASTER_TX | I2S_STANDARD_PHILIPS | I2S_DATAFORMAT_16B  | I2S_CPOL_LOW | I2S_WS_INVERSION_DISABLE | I2S_DATA_24BIT_ALIGNMENT_RIGHT | I2S_MCLKOUTPUT_DISABLE));

    // Clear status register
    WRITE_REG(hi2s->IFCR, 0x0FF8);
 8103322:	68fb      	ldr	r3, [r7, #12]
 8103324:	f640 72f8 	movw	r2, #4088	; 0xff8
 8103328:	619a      	str	r2, [r3, #24]

    // I2Sx CFG2 Configuration

    // Unlock the AF configuration to configure CFG2 register*/
    CLEAR_BIT(hi2s->CR1, SPI_CR1_IOLOCK);
 810332a:	68fb      	ldr	r3, [r7, #12]
 810332c:	681b      	ldr	r3, [r3, #0]
 810332e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8103332:	68fb      	ldr	r3, [r7, #12]
 8103334:	601a      	str	r2, [r3, #0]

    MODIFY_REG(hi2s->CFG2, SPI_CFG2_LSBFRST, I2S_FIRSTBIT_MSB);
 8103336:	68fb      	ldr	r3, [r7, #12]
 8103338:	68db      	ldr	r3, [r3, #12]
 810333a:	f423 0200 	bic.w	r2, r3, #8388608	; 0x800000
 810333e:	68fb      	ldr	r3, [r7, #12]
 8103340:	60da      	str	r2, [r3, #12]

    // Insure that AFCNTR is managed only by Master
    // Alternate function GPIOs control
    MODIFY_REG(hi2s->CFG2, SPI_CFG2_AFCNTR, I2S_MASTER_KEEP_IO_STATE_DISABLE);
 8103342:	68fb      	ldr	r3, [r7, #12]
 8103344:	68db      	ldr	r3, [r3, #12]
 8103346:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 810334a:	68fb      	ldr	r3, [r7, #12]
 810334c:	60da      	str	r2, [r3, #12]

    // Update status
    i2s_ctx->status = I2S_STATUS_READY;
 810334e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8103350:	2200      	movs	r2, #0
 8103352:	731a      	strb	r2, [r3, #12]
    i2s_ctx->size = 0;
 8103354:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8103356:	2200      	movs	r2, #0
 8103358:	605a      	str	r2, [r3, #4]
    i2s_ctx->index = 0;
 810335a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 810335c:	2200      	movs	r2, #0
 810335e:	609a      	str	r2, [r3, #8]
    i2s_ctx->pData = 0;
 8103360:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8103362:	2200      	movs	r2, #0
 8103364:	601a      	str	r2, [r3, #0]

    return BSP_OK;
 8103366:	2300      	movs	r3, #0

}
 8103368:	4618      	mov	r0, r3
 810336a:	3744      	adds	r7, #68	; 0x44
 810336c:	46bd      	mov	sp, r7
 810336e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103372:	4770      	bx	lr
 8103374:	58024400 	.word	0x58024400
 8103378:	4bbebc20 	.word	0x4bbebc20
 810337c:	46000000 	.word	0x46000000
 8103380:	cccccccd 	.word	0xcccccccd
 8103384:	fdff9040 	.word	0xfdff9040

08103388 <BSP_STM32_I2S_IRQHandler>:
	return BSP_OK;
}



uint8_t BSP_STM32_I2S_IRQHandler(SPI_TypeDef *hi2s, TxRxContext_TypeDef *ctx) {
 8103388:	b580      	push	{r7, lr}
 810338a:	b08a      	sub	sp, #40	; 0x28
 810338c:	af00      	add	r7, sp, #0
 810338e:	6078      	str	r0, [r7, #4]
 8103390:	6039      	str	r1, [r7, #0]

	I2SContext_TypeDef * i2s_ctx = (I2SContext_TypeDef *)ctx->ctxmem;
 8103392:	683b      	ldr	r3, [r7, #0]
 8103394:	3328      	adds	r3, #40	; 0x28
 8103396:	627b      	str	r3, [r7, #36]	; 0x24

	uint32_t	reg_ier = hi2s->IER;
 8103398:	687b      	ldr	r3, [r7, #4]
 810339a:	691b      	ldr	r3, [r3, #16]
 810339c:	623b      	str	r3, [r7, #32]
	uint32_t	reg_sr = hi2s->SR;
 810339e:	687b      	ldr	r3, [r7, #4]
 81033a0:	695b      	ldr	r3, [r3, #20]
 81033a2:	61fb      	str	r3, [r7, #28]
	uint32_t	trigger = reg_ier & reg_sr;
 81033a4:	6a3a      	ldr	r2, [r7, #32]
 81033a6:	69fb      	ldr	r3, [r7, #28]
 81033a8:	4013      	ands	r3, r2
 81033aa:	61bb      	str	r3, [r7, #24]
	// Callback management
	void (* pCallback_TE)(TxRxContext_TypeDef * ctx);
	void (* pCallback_HT)(TxRxContext_TypeDef * ctx);
	void (* pCallback_TC)(TxRxContext_TypeDef * ctx);

	pCallback_TE = (void *)ctx->callback_TE;
 81033ac:	683b      	ldr	r3, [r7, #0]
 81033ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 81033b0:	617b      	str	r3, [r7, #20]
	pCallback_HT = (void *)ctx->callback_HT;
 81033b2:	683b      	ldr	r3, [r7, #0]
 81033b4:	69db      	ldr	r3, [r3, #28]
 81033b6:	613b      	str	r3, [r7, #16]
	pCallback_TC = (void *)ctx->callback_TC;
 81033b8:	683b      	ldr	r3, [r7, #0]
 81033ba:	6a1b      	ldr	r3, [r3, #32]
 81033bc:	60fb      	str	r3, [r7, #12]

	__IO int16_t *ptxdr = (__IO int16_t *)(&(hi2s->TXDR));
 81033be:	687b      	ldr	r3, [r7, #4]
 81033c0:	3320      	adds	r3, #32
 81033c2:	60bb      	str	r3, [r7, #8]

	// TX Mode
	if (((trigger & I2S_FLAG_TXP) == I2S_FLAG_TXP) && ((trigger & I2S_FLAG_UDR)== 0)) {
 81033c4:	69bb      	ldr	r3, [r7, #24]
 81033c6:	f003 0302 	and.w	r3, r3, #2
 81033ca:	2b00      	cmp	r3, #0
 81033cc:	d038      	beq.n	8103440 <BSP_STM32_I2S_IRQHandler+0xb8>
 81033ce:	69bb      	ldr	r3, [r7, #24]
 81033d0:	f003 0320 	and.w	r3, r3, #32
 81033d4:	2b00      	cmp	r3, #0
 81033d6:	d133      	bne.n	8103440 <BSP_STM32_I2S_IRQHandler+0xb8>
		// Writing 16 bits to TX data register
		*ptxdr = *i2s_ctx->pData;
 81033d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81033da:	681b      	ldr	r3, [r3, #0]
 81033dc:	f9b3 2000 	ldrsh.w	r2, [r3]
 81033e0:	68bb      	ldr	r3, [r7, #8]
 81033e2:	801a      	strh	r2, [r3, #0]
		// Increasing index by 2 bytes (16 bits)
		i2s_ctx->index+=2;
 81033e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81033e6:	689b      	ldr	r3, [r3, #8]
 81033e8:	1c9a      	adds	r2, r3, #2
 81033ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81033ec:	609a      	str	r2, [r3, #8]
		i2s_ctx->pData++;
 81033ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81033f0:	681b      	ldr	r3, [r3, #0]
 81033f2:	1c9a      	adds	r2, r3, #2
 81033f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81033f6:	601a      	str	r2, [r3, #0]

		// Half buffer transmited??
		if (i2s_ctx->index == (i2s_ctx->size >> 1)) {
 81033f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81033fa:	689a      	ldr	r2, [r3, #8]
 81033fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81033fe:	685b      	ldr	r3, [r3, #4]
 8103400:	085b      	lsrs	r3, r3, #1
 8103402:	429a      	cmp	r2, r3
 8103404:	d106      	bne.n	8103414 <BSP_STM32_I2S_IRQHandler+0x8c>
			 // Execute half transfer callback if set
			 if (ctx->callback_HT > 0) pCallback_HT(ctx);
 8103406:	683b      	ldr	r3, [r7, #0]
 8103408:	69db      	ldr	r3, [r3, #28]
 810340a:	2b00      	cmp	r3, #0
 810340c:	d002      	beq.n	8103414 <BSP_STM32_I2S_IRQHandler+0x8c>
 810340e:	693b      	ldr	r3, [r7, #16]
 8103410:	6838      	ldr	r0, [r7, #0]
 8103412:	4798      	blx	r3
		}

		// Transmission completed??
		if (i2s_ctx->index >= i2s_ctx->size) {
 8103414:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8103416:	689a      	ldr	r2, [r3, #8]
 8103418:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810341a:	685b      	ldr	r3, [r3, #4]
 810341c:	429a      	cmp	r2, r3
 810341e:	d30f      	bcc.n	8103440 <BSP_STM32_I2S_IRQHandler+0xb8>
			// Disable TXP and ERR interrupt
			hi2s->IER &= ~(I2S_FLAG_TXP | I2S_FLAG_UDR);
 8103420:	687b      	ldr	r3, [r7, #4]
 8103422:	691b      	ldr	r3, [r3, #16]
 8103424:	f023 0222 	bic.w	r2, r3, #34	; 0x22
 8103428:	687b      	ldr	r3, [r7, #4]
 810342a:	611a      	str	r2, [r3, #16]
			// Update status
			i2s_ctx->status = I2S_STATUS_READY;
 810342c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 810342e:	2200      	movs	r2, #0
 8103430:	731a      	strb	r2, [r3, #12]
			// Execute transfer completed callback if set
			if (ctx->callback_TC > 0) pCallback_TC(ctx);
 8103432:	683b      	ldr	r3, [r7, #0]
 8103434:	6a1b      	ldr	r3, [r3, #32]
 8103436:	2b00      	cmp	r3, #0
 8103438:	d002      	beq.n	8103440 <BSP_STM32_I2S_IRQHandler+0xb8>
 810343a:	68fb      	ldr	r3, [r7, #12]
 810343c:	6838      	ldr	r0, [r7, #0]
 810343e:	4798      	blx	r3
		}
	}

	// Underrun error
	if ((trigger & I2S_FLAG_UDR) == I2S_FLAG_UDR) {
 8103440:	69bb      	ldr	r3, [r7, #24]
 8103442:	f003 0320 	and.w	r3, r3, #32
 8103446:	2b00      	cmp	r3, #0
 8103448:	d017      	beq.n	810347a <BSP_STM32_I2S_IRQHandler+0xf2>
		// Disable TXP and ERR interrupts
		hi2s->IER &= ~(I2S_FLAG_TXP | I2S_FLAG_UDR);
 810344a:	687b      	ldr	r3, [r7, #4]
 810344c:	691b      	ldr	r3, [r3, #16]
 810344e:	f023 0222 	bic.w	r2, r3, #34	; 0x22
 8103452:	687b      	ldr	r3, [r7, #4]
 8103454:	611a      	str	r2, [r3, #16]
		// Clear underrun flag
		hi2s->IFCR |= I2S_FLAG_UDR;
 8103456:	687b      	ldr	r3, [r7, #4]
 8103458:	699b      	ldr	r3, [r3, #24]
 810345a:	f043 0220 	orr.w	r2, r3, #32
 810345e:	687b      	ldr	r3, [r7, #4]
 8103460:	619a      	str	r2, [r3, #24]
		// Update status
		i2s_ctx->status = I2S_STATUS_READY;
 8103462:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8103464:	2200      	movs	r2, #0
 8103466:	731a      	strb	r2, [r3, #12]
		// Execute error callback if set
	    if (ctx->callback_TE > 0) pCallback_TE(ctx);
 8103468:	683b      	ldr	r3, [r7, #0]
 810346a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 810346c:	2b00      	cmp	r3, #0
 810346e:	d002      	beq.n	8103476 <BSP_STM32_I2S_IRQHandler+0xee>
 8103470:	697b      	ldr	r3, [r7, #20]
 8103472:	6838      	ldr	r0, [r7, #0]
 8103474:	4798      	blx	r3
		return BSP_ERROR;
 8103476:	2301      	movs	r3, #1
 8103478:	e000      	b.n	810347c <BSP_STM32_I2S_IRQHandler+0xf4>
	}

	return BSP_OK;
 810347a:	2300      	movs	r3, #0
}
 810347c:	4618      	mov	r0, r3
 810347e:	3728      	adds	r7, #40	; 0x28
 8103480:	46bd      	mov	sp, r7
 8103482:	bd80      	pop	{r7, pc}

08103484 <BSP_STM32_PWR_ClearPendingEvent>:
  // Enable access to RTC and backup registers
  SET_BIT (PWR->CR1, PWR_CR1_DBP);
  return BSP_OK;
}

uint8_t BSP_STM32_PWR_ClearPendingEvent(void) {
 8103484:	b480      	push	{r7}
 8103486:	af00      	add	r7, sp, #0
#if defined (CORE_CM7)
    __WFE ();
#else
    __SEV ();
 8103488:	bf40      	sev
    __WFE ();
 810348a:	bf20      	wfe
#endif
    return BSP_OK;
 810348c:	2300      	movs	r3, #0
}
 810348e:	4618      	mov	r0, r3
 8103490:	46bd      	mov	sp, r7
 8103492:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103496:	4770      	bx	lr

08103498 <BSP_STM32_PWR_EnterSTOPMode>:

uint8_t BSP_STM32_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain) {
 8103498:	b480      	push	{r7}
 810349a:	b085      	sub	sp, #20
 810349c:	af00      	add	r7, sp, #0
 810349e:	60f8      	str	r0, [r7, #12]
 81034a0:	460b      	mov	r3, r1
 81034a2:	607a      	str	r2, [r7, #4]
 81034a4:	72fb      	strb	r3, [r7, #11]
	// Check the parameters
	switch (Regulator) {
 81034a6:	68fb      	ldr	r3, [r7, #12]
 81034a8:	2b01      	cmp	r3, #1
 81034aa:	d901      	bls.n	81034b0 <BSP_STM32_PWR_EnterSTOPMode+0x18>
	case PWR_MAINREGULATOR_ON:
	case PWR_LOWPOWERREGULATOR_ON:
		break;
	default:
		return BSP_ERROR;
 81034ac:	2301      	movs	r3, #1
 81034ae:	e044      	b.n	810353a <BSP_STM32_PWR_EnterSTOPMode+0xa2>
		break;
 81034b0:	bf00      	nop
	}

	switch (STOPEntry) {
 81034b2:	7afb      	ldrb	r3, [r7, #11]
 81034b4:	3b01      	subs	r3, #1
 81034b6:	2b01      	cmp	r3, #1
 81034b8:	d901      	bls.n	81034be <BSP_STM32_PWR_EnterSTOPMode+0x26>
	case PWR_STOPENTRY_WFI:
	case PWR_STOPENTRY_WFE:
		break;
	default:
		return BSP_ERROR;
 81034ba:	2301      	movs	r3, #1
 81034bc:	e03d      	b.n	810353a <BSP_STM32_PWR_EnterSTOPMode+0xa2>
		break;
 81034be:	bf00      	nop
	}

	switch (Domain) {
 81034c0:	687b      	ldr	r3, [r7, #4]
 81034c2:	2b02      	cmp	r3, #2
 81034c4:	d901      	bls.n	81034ca <BSP_STM32_PWR_EnterSTOPMode+0x32>
	case PWR_D1_DOMAIN:
	case PWR_D2_DOMAIN:
	case PWR_D3_DOMAIN:
		break;
	default:
		return BSP_ERROR;
 81034c6:	2301      	movs	r3, #1
 81034c8:	e037      	b.n	810353a <BSP_STM32_PWR_EnterSTOPMode+0xa2>
		break;
 81034ca:	bf00      	nop
	}

	// Select the regulator state in Stop mode
	MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
 81034cc:	4b1e      	ldr	r3, [pc, #120]	; (8103548 <BSP_STM32_PWR_EnterSTOPMode+0xb0>)
 81034ce:	681b      	ldr	r3, [r3, #0]
 81034d0:	f023 0201 	bic.w	r2, r3, #1
 81034d4:	491c      	ldr	r1, [pc, #112]	; (8103548 <BSP_STM32_PWR_EnterSTOPMode+0xb0>)
 81034d6:	68fb      	ldr	r3, [r7, #12]
 81034d8:	4313      	orrs	r3, r2
 81034da:	600b      	str	r3, [r1, #0]

	// Select the domain Power Down DeepSleep
	if (Domain == PWR_D1_DOMAIN) {
 81034dc:	687b      	ldr	r3, [r7, #4]
 81034de:	2b00      	cmp	r3, #0
 81034e0:	d101      	bne.n	81034e6 <BSP_STM32_PWR_EnterSTOPMode+0x4e>
#if defined (CORE_CM4)
		return BSP_ERROR;
 81034e2:	2301      	movs	r3, #1
 81034e4:	e029      	b.n	810353a <BSP_STM32_PWR_EnterSTOPMode+0xa2>
		// Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register
		CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
		return BSP_OK;
	}

	if (Domain == PWR_D2_DOMAIN) {
 81034e6:	687b      	ldr	r3, [r7, #4]
 81034e8:	2b01      	cmp	r3, #1
 81034ea:	d11f      	bne.n	810352c <BSP_STM32_PWR_EnterSTOPMode+0x94>
#if defined (CORE_CM7)
	  return BSP_ERROR;
#endif

	  // Keep DSTOP mode when D2 domain enters Deepsleep
	  CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D2);
 81034ec:	4b16      	ldr	r3, [pc, #88]	; (8103548 <BSP_STM32_PWR_EnterSTOPMode+0xb0>)
 81034ee:	695b      	ldr	r3, [r3, #20]
 81034f0:	4a15      	ldr	r2, [pc, #84]	; (8103548 <BSP_STM32_PWR_EnterSTOPMode+0xb0>)
 81034f2:	f023 0302 	bic.w	r3, r3, #2
 81034f6:	6153      	str	r3, [r2, #20]

	  // Set SLEEPDEEP bit of Cortex System Control Register
	  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 81034f8:	4b14      	ldr	r3, [pc, #80]	; (810354c <BSP_STM32_PWR_EnterSTOPMode+0xb4>)
 81034fa:	691b      	ldr	r3, [r3, #16]
 81034fc:	4a13      	ldr	r2, [pc, #76]	; (810354c <BSP_STM32_PWR_EnterSTOPMode+0xb4>)
 81034fe:	f043 0304 	orr.w	r3, r3, #4
 8103502:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8103504:	f3bf 8f4f 	dsb	sy
}
 8103508:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 810350a:	f3bf 8f6f 	isb	sy
}
 810350e:	bf00      	nop
	  // Ensure that all instructions are done before entering STOP mode
	  __DSB ();
	  __ISB ();

	  // Select Stop mode entry
	  if (STOPEntry == PWR_STOPENTRY_WFI) __WFI ();
 8103510:	7afb      	ldrb	r3, [r7, #11]
 8103512:	2b01      	cmp	r3, #1
 8103514:	d101      	bne.n	810351a <BSP_STM32_PWR_EnterSTOPMode+0x82>
 8103516:	bf30      	wfi
 8103518:	e000      	b.n	810351c <BSP_STM32_PWR_EnterSTOPMode+0x84>
	  	  else __WFE ();
 810351a:	bf20      	wfe

	  // Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register
	  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 810351c:	4b0b      	ldr	r3, [pc, #44]	; (810354c <BSP_STM32_PWR_EnterSTOPMode+0xb4>)
 810351e:	691b      	ldr	r3, [r3, #16]
 8103520:	4a0a      	ldr	r2, [pc, #40]	; (810354c <BSP_STM32_PWR_EnterSTOPMode+0xb4>)
 8103522:	f023 0304 	bic.w	r3, r3, #4
 8103526:	6113      	str	r3, [r2, #16]

	  return BSP_OK;
 8103528:	2300      	movs	r3, #0
 810352a:	e006      	b.n	810353a <BSP_STM32_PWR_EnterSTOPMode+0xa2>
#if defined (CORE_CM7)
	// Keep DSTOP mode when D3 domain enters Deepsleep
	CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
#else
	// Keep DSTOP mode when D3 domain enters Deepsleep
	CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);
 810352c:	4b06      	ldr	r3, [pc, #24]	; (8103548 <BSP_STM32_PWR_EnterSTOPMode+0xb0>)
 810352e:	695b      	ldr	r3, [r3, #20]
 8103530:	4a05      	ldr	r2, [pc, #20]	; (8103548 <BSP_STM32_PWR_EnterSTOPMode+0xb0>)
 8103532:	f023 0304 	bic.w	r3, r3, #4
 8103536:	6153      	str	r3, [r2, #20]
#endif

	return BSP_OK;
 8103538:	2300      	movs	r3, #0
}
 810353a:	4618      	mov	r0, r3
 810353c:	3714      	adds	r7, #20
 810353e:	46bd      	mov	sp, r7
 8103540:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103544:	4770      	bx	lr
 8103546:	bf00      	nop
 8103548:	58024800 	.word	0x58024800
 810354c:	e000ed00 	.word	0xe000ed00

08103550 <BSP_STM32_RCC_CLKConfig_I2S3>:
	MODIFY_REG(RCC->D3CCIPR, RCC_D3CCIPR_I2C4SEL, RCC_I2C4CLKSOURCE_D3PCLK1);
	return BSP_OK;
}

// Setting I2S3 clock source to PLL2
uint8_t BSP_STM32_RCC_CLKConfig_I2S3() {
 8103550:	b580      	push	{r7, lr}
 8103552:	b08a      	sub	sp, #40	; 0x28
 8103554:	af00      	add	r7, sp, #0
	// Setup audio frequency: ((25000000 / 5) * (151 + 2299/8192)) / 67 = 11.2896 MHz
	// 11289600 / 256  = 44100 Hz
	// 11289600 / 512  = 22050 Hz
	// 11289600 / 1024 = 11025 Hz

	uint32_t PLL2M = 5;
 8103556:	2305      	movs	r3, #5
 8103558:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t PLL2N = 151;
 810355a:	2397      	movs	r3, #151	; 0x97
 810355c:	623b      	str	r3, [r7, #32]
	uint32_t PLL2P = 67;
 810355e:	2343      	movs	r3, #67	; 0x43
 8103560:	61fb      	str	r3, [r7, #28]
	uint32_t PLL2Q = 2; // Not used
 8103562:	2302      	movs	r3, #2
 8103564:	61bb      	str	r3, [r7, #24]
	uint32_t PLL2R = 2; // Not used
 8103566:	2302      	movs	r3, #2
 8103568:	617b      	str	r3, [r7, #20]
	uint32_t PLL2RGE = RCC_PLL2VCIRANGE_2;
 810356a:	2380      	movs	r3, #128	; 0x80
 810356c:	613b      	str	r3, [r7, #16]
	uint32_t PLL2VCOSEL = RCC_PLL2VCOWIDE;
 810356e:	2300      	movs	r3, #0
 8103570:	60fb      	str	r3, [r7, #12]
	uint32_t PLL2FRACN = 2299;
 8103572:	f640 03fb 	movw	r3, #2299	; 0x8fb
 8103576:	60bb      	str	r3, [r7, #8]

	// Check that PLL2 OSC clock source is already set
	if ((RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC) == RCC_PLLSOURCE_NONE) return BSP_ERROR;
 8103578:	4b49      	ldr	r3, [pc, #292]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810357a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810357c:	f003 0303 	and.w	r3, r3, #3
 8103580:	2b03      	cmp	r3, #3
 8103582:	d101      	bne.n	8103588 <BSP_STM32_RCC_CLKConfig_I2S3+0x38>
 8103584:	2301      	movs	r3, #1
 8103586:	e087      	b.n	8103698 <BSP_STM32_RCC_CLKConfig_I2S3+0x148>

	// Disable  PLL2
	CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
 8103588:	4b45      	ldr	r3, [pc, #276]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810358a:	681b      	ldr	r3, [r3, #0]
 810358c:	4a44      	ldr	r2, [pc, #272]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810358e:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8103592:	6013      	str	r3, [r2, #0]

	// Wait till PLL is disabled
	tickstart = BSP_GetTick();
 8103594:	f7fd f9c0 	bl	8100918 <BSP_GetTick>
 8103598:	6078      	str	r0, [r7, #4]

	while ((RCC->CR & RCC_CR_PLL2RDY) != 0U) if ((BSP_GetTick() - tickstart) > 2) return BSP_ERROR;
 810359a:	e008      	b.n	81035ae <BSP_STM32_RCC_CLKConfig_I2S3+0x5e>
 810359c:	f7fd f9bc 	bl	8100918 <BSP_GetTick>
 81035a0:	4602      	mov	r2, r0
 81035a2:	687b      	ldr	r3, [r7, #4]
 81035a4:	1ad3      	subs	r3, r2, r3
 81035a6:	2b02      	cmp	r3, #2
 81035a8:	d901      	bls.n	81035ae <BSP_STM32_RCC_CLKConfig_I2S3+0x5e>
 81035aa:	2301      	movs	r3, #1
 81035ac:	e074      	b.n	8103698 <BSP_STM32_RCC_CLKConfig_I2S3+0x148>
 81035ae:	4b3c      	ldr	r3, [pc, #240]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 81035b0:	681b      	ldr	r3, [r3, #0]
 81035b2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 81035b6:	2b00      	cmp	r3, #0
 81035b8:	d1f0      	bne.n	810359c <BSP_STM32_RCC_CLKConfig_I2S3+0x4c>

    // Configure PLL2 multiplication and division factors. */
	MODIFY_REG(RCC->PLLCKSELR, ( RCC_PLLCKSELR_DIVM2) , ( (PLL2M) <<12U));
 81035ba:	4b39      	ldr	r3, [pc, #228]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 81035bc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 81035be:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 81035c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 81035c4:	031b      	lsls	r3, r3, #12
 81035c6:	4936      	ldr	r1, [pc, #216]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 81035c8:	4313      	orrs	r3, r2
 81035ca:	628b      	str	r3, [r1, #40]	; 0x28
	WRITE_REG(RCC->PLL2DIVR , ( (((PLL2N) - 1U ) & RCC_PLL2DIVR_N2) | ((((PLL2P) -1U ) << 9U) & RCC_PLL2DIVR_P2) | ((((PLL2Q) -1U) << 16U) & RCC_PLL2DIVR_Q2) | ((((PLL2R)- 1U) << 24U) & RCC_PLL2DIVR_R2)));
 81035cc:	6a3b      	ldr	r3, [r7, #32]
 81035ce:	3b01      	subs	r3, #1
 81035d0:	f3c3 0208 	ubfx	r2, r3, #0, #9
 81035d4:	69fb      	ldr	r3, [r7, #28]
 81035d6:	3b01      	subs	r3, #1
 81035d8:	025b      	lsls	r3, r3, #9
 81035da:	b29b      	uxth	r3, r3
 81035dc:	431a      	orrs	r2, r3
 81035de:	69bb      	ldr	r3, [r7, #24]
 81035e0:	3b01      	subs	r3, #1
 81035e2:	041b      	lsls	r3, r3, #16
 81035e4:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 81035e8:	431a      	orrs	r2, r3
 81035ea:	697b      	ldr	r3, [r7, #20]
 81035ec:	3b01      	subs	r3, #1
 81035ee:	061b      	lsls	r3, r3, #24
 81035f0:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 81035f4:	492a      	ldr	r1, [pc, #168]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 81035f6:	4313      	orrs	r3, r2
 81035f8:	638b      	str	r3, [r1, #56]	; 0x38

	// Select PLL2 input reference frequency range: VCI
	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL2RGE, (PLL2RGE));
 81035fa:	4b29      	ldr	r3, [pc, #164]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 81035fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 81035fe:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 8103602:	4927      	ldr	r1, [pc, #156]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103604:	693b      	ldr	r3, [r7, #16]
 8103606:	4313      	orrs	r3, r2
 8103608:	62cb      	str	r3, [r1, #44]	; 0x2c

	// Select PLL2 output frequency range : VCO
	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLL2VCOSEL, (PLL2VCOSEL));
 810360a:	4b25      	ldr	r3, [pc, #148]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810360c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810360e:	f023 0220 	bic.w	r2, r3, #32
 8103612:	4923      	ldr	r1, [pc, #140]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103614:	68fb      	ldr	r3, [r7, #12]
 8103616:	4313      	orrs	r3, r2
 8103618:	62cb      	str	r3, [r1, #44]	; 0x2c

	// Disable PLL2FRACN
	CLEAR_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN);
 810361a:	4b21      	ldr	r3, [pc, #132]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810361c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810361e:	4a20      	ldr	r2, [pc, #128]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103620:	f023 0310 	bic.w	r3, r3, #16
 8103624:	62d3      	str	r3, [r2, #44]	; 0x2c

	// Configures PLL2 clock Fractional Part Of The Multiplication Factor
	MODIFY_REG(RCC->PLL2FRACR, RCC_PLL2FRACR_FRACN2,(PLL2FRACN << RCC_PLL2FRACR_FRACN2_Pos));
 8103626:	4b1e      	ldr	r3, [pc, #120]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103628:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 810362a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 810362e:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8103632:	68ba      	ldr	r2, [r7, #8]
 8103634:	00d2      	lsls	r2, r2, #3
 8103636:	491a      	ldr	r1, [pc, #104]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103638:	4313      	orrs	r3, r2
 810363a:	63cb      	str	r3, [r1, #60]	; 0x3c

	// Enable PLL2FRACN
	SET_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLL2FRACEN);
 810363c:	4b18      	ldr	r3, [pc, #96]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810363e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8103640:	4a17      	ldr	r2, [pc, #92]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103642:	f043 0310 	orr.w	r3, r3, #16
 8103646:	62d3      	str	r3, [r2, #44]	; 0x2c

	// Enable the PLL2 clock output
    RCC->PLLCFGR |= (0x1UL << RCC_PLLCFGR_DIVP2EN_Pos);
 8103648:	4b15      	ldr	r3, [pc, #84]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810364a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 810364c:	4a14      	ldr	r2, [pc, #80]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810364e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8103652:	62d3      	str	r3, [r2, #44]	; 0x2c

    // Enable  PLL2
    SET_BIT(RCC->CR, RCC_CR_PLL2ON);
 8103654:	4b12      	ldr	r3, [pc, #72]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103656:	681b      	ldr	r3, [r3, #0]
 8103658:	4a11      	ldr	r2, [pc, #68]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810365a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 810365e:	6013      	str	r3, [r2, #0]

    // Wait till PLL2 is ready
    tickstart = BSP_GetTick();
 8103660:	f7fd f95a 	bl	8100918 <BSP_GetTick>
 8103664:	6078      	str	r0, [r7, #4]
	while ((RCC->CR & RCC_CR_PLL2RDY) == 0U) if ((BSP_GetTick() - tickstart) > 2) return BSP_ERROR;
 8103666:	e008      	b.n	810367a <BSP_STM32_RCC_CLKConfig_I2S3+0x12a>
 8103668:	f7fd f956 	bl	8100918 <BSP_GetTick>
 810366c:	4602      	mov	r2, r0
 810366e:	687b      	ldr	r3, [r7, #4]
 8103670:	1ad3      	subs	r3, r2, r3
 8103672:	2b02      	cmp	r3, #2
 8103674:	d901      	bls.n	810367a <BSP_STM32_RCC_CLKConfig_I2S3+0x12a>
 8103676:	2301      	movs	r3, #1
 8103678:	e00e      	b.n	8103698 <BSP_STM32_RCC_CLKConfig_I2S3+0x148>
 810367a:	4b09      	ldr	r3, [pc, #36]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 810367c:	681b      	ldr	r3, [r3, #0]
 810367e:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8103682:	2b00      	cmp	r3, #0
 8103684:	d0f0      	beq.n	8103668 <BSP_STM32_RCC_CLKConfig_I2S3+0x118>

	// Set the source of SPI3 peripheral
	MODIFY_REG(RCC->D2CCIP1R, RCC_D2CCIP1R_SPI123SEL, RCC_SPI123CLKSOURCE_PLL2);
 8103686:	4b06      	ldr	r3, [pc, #24]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103688:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 810368a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 810368e:	4a04      	ldr	r2, [pc, #16]	; (81036a0 <BSP_STM32_RCC_CLKConfig_I2S3+0x150>)
 8103690:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8103694:	6513      	str	r3, [r2, #80]	; 0x50

	return BSP_OK;
 8103696:	2300      	movs	r3, #0
}
 8103698:	4618      	mov	r0, r3
 810369a:	3728      	adds	r7, #40	; 0x28
 810369c:	46bd      	mov	sp, r7
 810369e:	bd80      	pop	{r7, pc}
 81036a0:	58024400 	.word	0x58024400

081036a4 <BSP_STM32_RCC_GetSysClockFreq>:

	return BSP_OK;
}


uint32_t BSP_STM32_RCC_GetSysClockFreq(void) {
 81036a4:	b480      	push	{r7}
 81036a6:	b089      	sub	sp, #36	; 0x24
 81036a8:	af00      	add	r7, sp, #0
    float_t fracn1, pllvco;
    uint32_t sysclockfreq;

    // Get SYSCLK source

    switch (RCC->CFGR & RCC_CFGR_SWS) {
 81036aa:	4bb3      	ldr	r3, [pc, #716]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 81036ac:	691b      	ldr	r3, [r3, #16]
 81036ae:	f003 0338 	and.w	r3, r3, #56	; 0x38
 81036b2:	2b18      	cmp	r3, #24
 81036b4:	f200 8155 	bhi.w	8103962 <BSP_STM32_RCC_GetSysClockFreq+0x2be>
 81036b8:	a201      	add	r2, pc, #4	; (adr r2, 81036c0 <BSP_STM32_RCC_GetSysClockFreq+0x1c>)
 81036ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81036be:	bf00      	nop
 81036c0:	08103725 	.word	0x08103725
 81036c4:	08103963 	.word	0x08103963
 81036c8:	08103963 	.word	0x08103963
 81036cc:	08103963 	.word	0x08103963
 81036d0:	08103963 	.word	0x08103963
 81036d4:	08103963 	.word	0x08103963
 81036d8:	08103963 	.word	0x08103963
 81036dc:	08103963 	.word	0x08103963
 81036e0:	0810374b 	.word	0x0810374b
 81036e4:	08103963 	.word	0x08103963
 81036e8:	08103963 	.word	0x08103963
 81036ec:	08103963 	.word	0x08103963
 81036f0:	08103963 	.word	0x08103963
 81036f4:	08103963 	.word	0x08103963
 81036f8:	08103963 	.word	0x08103963
 81036fc:	08103963 	.word	0x08103963
 8103700:	08103751 	.word	0x08103751
 8103704:	08103963 	.word	0x08103963
 8103708:	08103963 	.word	0x08103963
 810370c:	08103963 	.word	0x08103963
 8103710:	08103963 	.word	0x08103963
 8103714:	08103963 	.word	0x08103963
 8103718:	08103963 	.word	0x08103963
 810371c:	08103963 	.word	0x08103963
 8103720:	08103757 	.word	0x08103757

    case RCC_CFGR_SWS_HSI:  // HSI used as system clock source

    	if ((RCC->CR & RCC_CR_HSIDIV_Msk) != 0U) {
 8103724:	4b94      	ldr	r3, [pc, #592]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103726:	681b      	ldr	r3, [r3, #0]
 8103728:	f003 0318 	and.w	r3, r3, #24
 810372c:	2b00      	cmp	r3, #0
 810372e:	d009      	beq.n	8103744 <BSP_STM32_RCC_GetSysClockFreq+0xa0>

    		sysclockfreq = (uint32_t)(HSI_VALUE >> (READ_BIT(RCC->CR, RCC_CR_HSIDIV) >> 3));
 8103730:	4b91      	ldr	r3, [pc, #580]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103732:	681b      	ldr	r3, [r3, #0]
 8103734:	08db      	lsrs	r3, r3, #3
 8103736:	f003 0303 	and.w	r3, r3, #3
 810373a:	4a90      	ldr	r2, [pc, #576]	; (810397c <BSP_STM32_RCC_GetSysClockFreq+0x2d8>)
 810373c:	fa42 f303 	asr.w	r3, r2, r3
 8103740:	61bb      	str	r3, [r7, #24]
    	} else {

    		sysclockfreq = (uint32_t) HSI_VALUE;
    	}

    	break;
 8103742:	e111      	b.n	8103968 <BSP_STM32_RCC_GetSysClockFreq+0x2c4>
    		sysclockfreq = (uint32_t) HSI_VALUE;
 8103744:	4b8d      	ldr	r3, [pc, #564]	; (810397c <BSP_STM32_RCC_GetSysClockFreq+0x2d8>)
 8103746:	61bb      	str	r3, [r7, #24]
    	break;
 8103748:	e10e      	b.n	8103968 <BSP_STM32_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_CSI:  // CSI used as system clock  source

    	sysclockfreq = CSI_VALUE;
 810374a:	4b8d      	ldr	r3, [pc, #564]	; (8103980 <BSP_STM32_RCC_GetSysClockFreq+0x2dc>)
 810374c:	61bb      	str	r3, [r7, #24]
    	break;
 810374e:	e10b      	b.n	8103968 <BSP_STM32_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_HSE:  // HSE used as system clock  source

    	sysclockfreq = HSE_VALUE;
 8103750:	4b8c      	ldr	r3, [pc, #560]	; (8103984 <BSP_STM32_RCC_GetSysClockFreq+0x2e0>)
 8103752:	61bb      	str	r3, [r7, #24]
    	break;
 8103754:	e108      	b.n	8103968 <BSP_STM32_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_PLL1:  // PLL1 used as system clock  source

    	// PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN      SYSCLK = PLL_VCO / PLLR

    	pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8103756:	4b88      	ldr	r3, [pc, #544]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103758:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 810375a:	f003 0303 	and.w	r3, r3, #3
 810375e:	617b      	str	r3, [r7, #20]
    	pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 8103760:	4b85      	ldr	r3, [pc, #532]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103762:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8103764:	091b      	lsrs	r3, r3, #4
 8103766:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 810376a:	613b      	str	r3, [r7, #16]
    	pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 810376c:	4b82      	ldr	r3, [pc, #520]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 810376e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8103770:	f003 0301 	and.w	r3, r3, #1
 8103774:	60fb      	str	r3, [r7, #12]
    	fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 8103776:	4b80      	ldr	r3, [pc, #512]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103778:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 810377a:	08db      	lsrs	r3, r3, #3
 810377c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8103780:	68fa      	ldr	r2, [r7, #12]
 8103782:	fb02 f303 	mul.w	r3, r2, r3
 8103786:	ee07 3a90 	vmov	s15, r3
 810378a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810378e:	edc7 7a02 	vstr	s15, [r7, #8]

    	if (pllm != 0U) {
 8103792:	693b      	ldr	r3, [r7, #16]
 8103794:	2b00      	cmp	r3, #0
 8103796:	f000 80e1 	beq.w	810395c <BSP_STM32_RCC_GetSysClockFreq+0x2b8>
 810379a:	697b      	ldr	r3, [r7, #20]
 810379c:	2b02      	cmp	r3, #2
 810379e:	f000 8083 	beq.w	81038a8 <BSP_STM32_RCC_GetSysClockFreq+0x204>
 81037a2:	697b      	ldr	r3, [r7, #20]
 81037a4:	2b02      	cmp	r3, #2
 81037a6:	f200 80a1 	bhi.w	81038ec <BSP_STM32_RCC_GetSysClockFreq+0x248>
 81037aa:	697b      	ldr	r3, [r7, #20]
 81037ac:	2b00      	cmp	r3, #0
 81037ae:	d003      	beq.n	81037b8 <BSP_STM32_RCC_GetSysClockFreq+0x114>
 81037b0:	697b      	ldr	r3, [r7, #20]
 81037b2:	2b01      	cmp	r3, #1
 81037b4:	d056      	beq.n	8103864 <BSP_STM32_RCC_GetSysClockFreq+0x1c0>
 81037b6:	e099      	b.n	81038ec <BSP_STM32_RCC_GetSysClockFreq+0x248>
    		switch (pllsource) {

    		case RCC_PLLSOURCE_HSI:  // HSI used as PLL clock source

    			if ((RCC->CR & RCC_CR_HSIDIV_Msk) != 0U) {
 81037b8:	4b6f      	ldr	r3, [pc, #444]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 81037ba:	681b      	ldr	r3, [r3, #0]
 81037bc:	f003 0318 	and.w	r3, r3, #24
 81037c0:	2b00      	cmp	r3, #0
 81037c2:	d02d      	beq.n	8103820 <BSP_STM32_RCC_GetSysClockFreq+0x17c>

    				hsivalue = (HSI_VALUE >> (READ_BIT(RCC->CR, RCC_CR_HSIDIV) >> 3));
 81037c4:	4b6c      	ldr	r3, [pc, #432]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 81037c6:	681b      	ldr	r3, [r3, #0]
 81037c8:	08db      	lsrs	r3, r3, #3
 81037ca:	f003 0303 	and.w	r3, r3, #3
 81037ce:	4a6b      	ldr	r2, [pc, #428]	; (810397c <BSP_STM32_RCC_GetSysClockFreq+0x2d8>)
 81037d0:	fa42 f303 	asr.w	r3, r2, r3
 81037d4:	607b      	str	r3, [r7, #4]
    				pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81037d6:	687b      	ldr	r3, [r7, #4]
 81037d8:	ee07 3a90 	vmov	s15, r3
 81037dc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81037e0:	693b      	ldr	r3, [r7, #16]
 81037e2:	ee07 3a90 	vmov	s15, r3
 81037e6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81037ea:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81037ee:	4b62      	ldr	r3, [pc, #392]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 81037f0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81037f2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81037f6:	ee07 3a90 	vmov	s15, r3
 81037fa:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81037fe:	ed97 6a02 	vldr	s12, [r7, #8]
 8103802:	eddf 5a61 	vldr	s11, [pc, #388]	; 8103988 <BSP_STM32_RCC_GetSysClockFreq+0x2e4>
 8103806:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810380a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810380e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8103812:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8103816:	ee67 7a27 	vmul.f32	s15, s14, s15
 810381a:	edc7 7a07 	vstr	s15, [r7, #28]
    			} else {

    				pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);

    			}
    			break;
 810381e:	e087      	b.n	8103930 <BSP_STM32_RCC_GetSysClockFreq+0x28c>
    				pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8103820:	693b      	ldr	r3, [r7, #16]
 8103822:	ee07 3a90 	vmov	s15, r3
 8103826:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810382a:	eddf 6a58 	vldr	s13, [pc, #352]	; 810398c <BSP_STM32_RCC_GetSysClockFreq+0x2e8>
 810382e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8103832:	4b51      	ldr	r3, [pc, #324]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103834:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8103836:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810383a:	ee07 3a90 	vmov	s15, r3
 810383e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8103842:	ed97 6a02 	vldr	s12, [r7, #8]
 8103846:	eddf 5a50 	vldr	s11, [pc, #320]	; 8103988 <BSP_STM32_RCC_GetSysClockFreq+0x2e4>
 810384a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810384e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8103852:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8103856:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810385a:	ee67 7a27 	vmul.f32	s15, s14, s15
 810385e:	edc7 7a07 	vstr	s15, [r7, #28]
    			break;
 8103862:	e065      	b.n	8103930 <BSP_STM32_RCC_GetSysClockFreq+0x28c>

    		case RCC_PLLSOURCE_CSI:  // CSI used as PLL clock source

    			pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8103864:	693b      	ldr	r3, [r7, #16]
 8103866:	ee07 3a90 	vmov	s15, r3
 810386a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810386e:	eddf 6a48 	vldr	s13, [pc, #288]	; 8103990 <BSP_STM32_RCC_GetSysClockFreq+0x2ec>
 8103872:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8103876:	4b40      	ldr	r3, [pc, #256]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103878:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 810387a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810387e:	ee07 3a90 	vmov	s15, r3
 8103882:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8103886:	ed97 6a02 	vldr	s12, [r7, #8]
 810388a:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8103988 <BSP_STM32_RCC_GetSysClockFreq+0x2e4>
 810388e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8103892:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8103896:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 810389a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 810389e:	ee67 7a27 	vmul.f32	s15, s14, s15
 81038a2:	edc7 7a07 	vstr	s15, [r7, #28]
    			break;
 81038a6:	e043      	b.n	8103930 <BSP_STM32_RCC_GetSysClockFreq+0x28c>

    		case RCC_PLLSOURCE_HSE:  // HSE used as PLL clock source

    			pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81038a8:	693b      	ldr	r3, [r7, #16]
 81038aa:	ee07 3a90 	vmov	s15, r3
 81038ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81038b2:	eddf 6a38 	vldr	s13, [pc, #224]	; 8103994 <BSP_STM32_RCC_GetSysClockFreq+0x2f0>
 81038b6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81038ba:	4b2f      	ldr	r3, [pc, #188]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 81038bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 81038be:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81038c2:	ee07 3a90 	vmov	s15, r3
 81038c6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81038ca:	ed97 6a02 	vldr	s12, [r7, #8]
 81038ce:	eddf 5a2e 	vldr	s11, [pc, #184]	; 8103988 <BSP_STM32_RCC_GetSysClockFreq+0x2e4>
 81038d2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81038d6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81038da:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 81038de:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81038e2:	ee67 7a27 	vmul.f32	s15, s14, s15
 81038e6:	edc7 7a07 	vstr	s15, [r7, #28]
    			break;
 81038ea:	e021      	b.n	8103930 <BSP_STM32_RCC_GetSysClockFreq+0x28c>

    		default:

    			pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81038ec:	693b      	ldr	r3, [r7, #16]
 81038ee:	ee07 3a90 	vmov	s15, r3
 81038f2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81038f6:	eddf 6a26 	vldr	s13, [pc, #152]	; 8103990 <BSP_STM32_RCC_GetSysClockFreq+0x2ec>
 81038fa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81038fe:	4b1e      	ldr	r3, [pc, #120]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103900:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8103902:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8103906:	ee07 3a90 	vmov	s15, r3
 810390a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810390e:	ed97 6a02 	vldr	s12, [r7, #8]
 8103912:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8103988 <BSP_STM32_RCC_GetSysClockFreq+0x2e4>
 8103916:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810391a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810391e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8103922:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8103926:	ee67 7a27 	vmul.f32	s15, s14, s15
 810392a:	edc7 7a07 	vstr	s15, [r7, #28]
    			break;
 810392e:	bf00      	nop

    		}

        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 8103930:	4b11      	ldr	r3, [pc, #68]	; (8103978 <BSP_STM32_RCC_GetSysClockFreq+0x2d4>)
 8103932:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8103934:	0a5b      	lsrs	r3, r3, #9
 8103936:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 810393a:	3301      	adds	r3, #1
 810393c:	603b      	str	r3, [r7, #0]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 810393e:	683b      	ldr	r3, [r7, #0]
 8103940:	ee07 3a90 	vmov	s15, r3
 8103944:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8103948:	edd7 6a07 	vldr	s13, [r7, #28]
 810394c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8103950:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8103954:	ee17 3a90 	vmov	r3, s15
 8103958:	61bb      	str	r3, [r7, #24]

    	} else {

    		sysclockfreq = 0U;
    	}
    	break;
 810395a:	e005      	b.n	8103968 <BSP_STM32_RCC_GetSysClockFreq+0x2c4>
    		sysclockfreq = 0U;
 810395c:	2300      	movs	r3, #0
 810395e:	61bb      	str	r3, [r7, #24]
    	break;
 8103960:	e002      	b.n	8103968 <BSP_STM32_RCC_GetSysClockFreq+0x2c4>

    default:

    	sysclockfreq = CSI_VALUE;
 8103962:	4b07      	ldr	r3, [pc, #28]	; (8103980 <BSP_STM32_RCC_GetSysClockFreq+0x2dc>)
 8103964:	61bb      	str	r3, [r7, #24]
    	break;
 8103966:	bf00      	nop

    }

    return sysclockfreq;
 8103968:	69bb      	ldr	r3, [r7, #24]
}
 810396a:	4618      	mov	r0, r3
 810396c:	3724      	adds	r7, #36	; 0x24
 810396e:	46bd      	mov	sp, r7
 8103970:	f85d 7b04 	ldr.w	r7, [sp], #4
 8103974:	4770      	bx	lr
 8103976:	bf00      	nop
 8103978:	58024400 	.word	0x58024400
 810397c:	03d09000 	.word	0x03d09000
 8103980:	003d0900 	.word	0x003d0900
 8103984:	017d7840 	.word	0x017d7840
 8103988:	46000000 	.word	0x46000000
 810398c:	4c742400 	.word	0x4c742400
 8103990:	4a742400 	.word	0x4a742400
 8103994:	4bbebc20 	.word	0x4bbebc20

08103998 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8103998:	b480      	push	{r7}
 810399a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 810399c:	4b09      	ldr	r3, [pc, #36]	; (81039c4 <SystemInit+0x2c>)
 810399e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 81039a2:	4a08      	ldr	r2, [pc, #32]	; (81039c4 <SystemInit+0x2c>)
 81039a4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 81039a8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif

    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
     detectable by the CPU after a WFI/WFE instruction.*/
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 81039ac:	4b05      	ldr	r3, [pc, #20]	; (81039c4 <SystemInit+0x2c>)
 81039ae:	691b      	ldr	r3, [r3, #16]
 81039b0:	4a04      	ldr	r2, [pc, #16]	; (81039c4 <SystemInit+0x2c>)
 81039b2:	f043 0310 	orr.w	r3, r3, #16
 81039b6:	6113      	str	r3, [r2, #16]
#endif /* USER_VECT_TAB_ADDRESS */

#else
#error Please #define CORE_CM4 or CORE_CM7
#endif /* CORE_CM4 */
}
 81039b8:	bf00      	nop
 81039ba:	46bd      	mov	sp, r7
 81039bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81039c0:	4770      	bx	lr
 81039c2:	bf00      	nop
 81039c4:	e000ed00 	.word	0xe000ed00

081039c8 <main>:
#include "main.h"

#define HSEM_ID_0	0

int main(void)
{
 81039c8:	b580      	push	{r7, lr}
 81039ca:	b084      	sub	sp, #16
 81039cc:	af00      	add	r7, sp, #0
	__BSP_RCC_HSEM_CLK_ENABLE();
 81039ce:	4b3d      	ldr	r3, [pc, #244]	; (8103ac4 <main+0xfc>)
 81039d0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81039d4:	4a3b      	ldr	r2, [pc, #236]	; (8103ac4 <main+0xfc>)
 81039d6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 81039da:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 81039de:	4b39      	ldr	r3, [pc, #228]	; (8103ac4 <main+0xfc>)
 81039e0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 81039e4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 81039e8:	60bb      	str	r3, [r7, #8]
 81039ea:	68bb      	ldr	r3, [r7, #8]

	/* Activate HSEM notification for Cortex-M4*/
	BSP_STM32_HSEM_ActivateNotification(HSEM_ID_0);
 81039ec:	2000      	movs	r0, #0
 81039ee:	f7ff fbbb 	bl	8103168 <BSP_STM32_HSEM_ActivateNotification>
	/*
	Domain D2 goes to STOP mode (Cortex-M4 in deep-sleep) waiting for Cortex-M7 to
	perform system initialization (system clock config, external memory configuration.. )
	*/
	BSP_STM32_PWR_ClearPendingEvent();
 81039f2:	f7ff fd47 	bl	8103484 <BSP_STM32_PWR_ClearPendingEvent>
	BSP_STM32_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE, PWR_D2_DOMAIN);
 81039f6:	2201      	movs	r2, #1
 81039f8:	2102      	movs	r1, #2
 81039fa:	2000      	movs	r0, #0
 81039fc:	f7ff fd4c 	bl	8103498 <BSP_STM32_PWR_EnterSTOPMode>

	/* Clear HSEM flag */
	BSP_STM32_HSEM_ClearFlag(HSEM_ID_0);
 8103a00:	2000      	movs	r0, #0
 8103a02:	f7ff fbcd 	bl	81031a0 <BSP_STM32_HSEM_ClearFlag>

	/* USER CODE END Boot_Mode_Sequence_1 */
	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	__BSP_RCC_ART_CLK_ENABLE();                   // Enable the Cortex-M4 ART Clock
 8103a06:	4b2f      	ldr	r3, [pc, #188]	; (8103ac4 <main+0xfc>)
 8103a08:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8103a0c:	4a2d      	ldr	r2, [pc, #180]	; (8103ac4 <main+0xfc>)
 8103a0e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8103a12:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 8103a16:	4b2b      	ldr	r3, [pc, #172]	; (8103ac4 <main+0xfc>)
 8103a18:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8103a1c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8103a20:	607b      	str	r3, [r7, #4]
 8103a22:	687b      	ldr	r3, [r7, #4]
	__BSP_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  // Configure the Cortex-M4 ART Base address to the Flash Bank 2
 8103a24:	4b28      	ldr	r3, [pc, #160]	; (8103ac8 <main+0x100>)
 8103a26:	681b      	ldr	r3, [r3, #0]
 8103a28:	f423 237f 	bic.w	r3, r3, #1044480	; 0xff000
 8103a2c:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8103a30:	4a25      	ldr	r2, [pc, #148]	; (8103ac8 <main+0x100>)
 8103a32:	f443 4301 	orr.w	r3, r3, #33024	; 0x8100
 8103a36:	6013      	str	r3, [r2, #0]
	__BSP_ART_ENABLE();                           // Enable the Cortex-M4 ART
 8103a38:	4b23      	ldr	r3, [pc, #140]	; (8103ac8 <main+0x100>)
 8103a3a:	681b      	ldr	r3, [r3, #0]
 8103a3c:	4a22      	ldr	r2, [pc, #136]	; (8103ac8 <main+0x100>)
 8103a3e:	f043 0301 	orr.w	r3, r3, #1
 8103a42:	6013      	str	r3, [r2, #0]

	// Set Interrupt Group Priority
	BSP_STM32_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8103a44:	2003      	movs	r0, #3
 8103a46:	f7fe fea4 	bl	8102792 <BSP_STM32_NVIC_SetPriorityGrouping>

	uint32_t common_system_clock = BSP_STM32_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8103a4a:	f7ff fe2b 	bl	81036a4 <BSP_STM32_RCC_GetSysClockFreq>
 8103a4e:	4602      	mov	r2, r0
 8103a50:	4b1c      	ldr	r3, [pc, #112]	; (8103ac4 <main+0xfc>)
 8103a52:	699b      	ldr	r3, [r3, #24]
 8103a54:	0a1b      	lsrs	r3, r3, #8
 8103a56:	f003 030f 	and.w	r3, r3, #15
 8103a5a:	491c      	ldr	r1, [pc, #112]	; (8103acc <main+0x104>)
 8103a5c:	5ccb      	ldrb	r3, [r1, r3]
 8103a5e:	f003 031f 	and.w	r3, r3, #31
 8103a62:	fa22 f303 	lsr.w	r3, r2, r3
 8103a66:	60fb      	str	r3, [r7, #12]
	SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8103a68:	4b16      	ldr	r3, [pc, #88]	; (8103ac4 <main+0xfc>)
 8103a6a:	699b      	ldr	r3, [r3, #24]
 8103a6c:	f003 030f 	and.w	r3, r3, #15
 8103a70:	4a16      	ldr	r2, [pc, #88]	; (8103acc <main+0x104>)
 8103a72:	5cd3      	ldrb	r3, [r2, r3]
 8103a74:	f003 031f 	and.w	r3, r3, #31
 8103a78:	68fa      	ldr	r2, [r7, #12]
 8103a7a:	fa22 f303 	lsr.w	r3, r2, r3
 8103a7e:	4a14      	ldr	r2, [pc, #80]	; (8103ad0 <main+0x108>)
 8103a80:	6013      	str	r3, [r2, #0]
	SystemCoreClock = SystemD2Clock;
 8103a82:	4b13      	ldr	r3, [pc, #76]	; (8103ad0 <main+0x108>)
 8103a84:	681b      	ldr	r3, [r3, #0]
 8103a86:	4a13      	ldr	r2, [pc, #76]	; (8103ad4 <main+0x10c>)
 8103a88:	6013      	str	r3, [r2, #0]

	BSP_TickInit(SystemCoreClock, 1, TICK_INT_PRIORITY);
 8103a8a:	4b12      	ldr	r3, [pc, #72]	; (8103ad4 <main+0x10c>)
 8103a8c:	681b      	ldr	r3, [r3, #0]
 8103a8e:	220f      	movs	r2, #15
 8103a90:	2101      	movs	r1, #1
 8103a92:	4618      	mov	r0, r3
 8103a94:	f7fc fefe 	bl	8100894 <BSP_TickInit>

	__BSP_RCC_SYSCFG_CLK_ENABLE();
 8103a98:	4b0a      	ldr	r3, [pc, #40]	; (8103ac4 <main+0xfc>)
 8103a9a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8103a9e:	4a09      	ldr	r2, [pc, #36]	; (8103ac4 <main+0xfc>)
 8103aa0:	f043 0302 	orr.w	r3, r3, #2
 8103aa4:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8103aa8:	4b06      	ldr	r3, [pc, #24]	; (8103ac4 <main+0xfc>)
 8103aaa:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8103aae:	f003 0302 	and.w	r3, r3, #2
 8103ab2:	603b      	str	r3, [r7, #0]
 8103ab4:	683b      	ldr	r3, [r7, #0]

	BSP_BOARD_Init_CM4();
 8103ab6:	f7fc fc1b 	bl	81002f0 <BSP_BOARD_Init_CM4>

	BSP_Delay(6000);
 8103aba:	f241 7070 	movw	r0, #6000	; 0x1770
 8103abe:	f7fc ff37 	bl	8100930 <BSP_Delay>


    /* Loop forever */
	for(;;);
 8103ac2:	e7fe      	b.n	8103ac2 <main+0xfa>
 8103ac4:	58024400 	.word	0x58024400
 8103ac8:	40024400 	.word	0x40024400
 8103acc:	08104de4 	.word	0x08104de4
 8103ad0:	10000048 	.word	0x10000048
 8103ad4:	10000044 	.word	0x10000044

08103ad8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 8103ad8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8103b10 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
 8103adc:	f7ff ff5c 	bl	8103998 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8103ae0:	480c      	ldr	r0, [pc, #48]	; (8103b14 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8103ae2:	490d      	ldr	r1, [pc, #52]	; (8103b18 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8103ae4:	4a0d      	ldr	r2, [pc, #52]	; (8103b1c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8103ae6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8103ae8:	e002      	b.n	8103af0 <LoopCopyDataInit>

08103aea <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8103aea:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8103aec:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8103aee:	3304      	adds	r3, #4

08103af0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8103af0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8103af2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8103af4:	d3f9      	bcc.n	8103aea <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8103af6:	4a0a      	ldr	r2, [pc, #40]	; (8103b20 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8103af8:	4c0a      	ldr	r4, [pc, #40]	; (8103b24 <LoopFillZerobss+0x22>)
  movs r3, #0
 8103afa:	2300      	movs	r3, #0
  b LoopFillZerobss
 8103afc:	e001      	b.n	8103b02 <LoopFillZerobss>

08103afe <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8103afe:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8103b00:	3204      	adds	r2, #4

08103b02 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8103b02:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8103b04:	d3fb      	bcc.n	8103afe <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8103b06:	f000 f811 	bl	8103b2c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8103b0a:	f7ff ff5d 	bl	81039c8 <main>
  bx  lr
 8103b0e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8103b10:	10040000 	.word	0x10040000
  ldr r0, =_sdata
 8103b14:	10000000 	.word	0x10000000
  ldr r1, =_edata
 8103b18:	1000004c 	.word	0x1000004c
  ldr r2, =_sidata
 8103b1c:	08104dfc 	.word	0x08104dfc
  ldr r2, =_sbss
 8103b20:	1000004c 	.word	0x1000004c
  ldr r4, =_ebss
 8103b24:	100034a4 	.word	0x100034a4

08103b28 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8103b28:	e7fe      	b.n	8103b28 <ADC3_IRQHandler>
	...

08103b2c <__libc_init_array>:
 8103b2c:	b570      	push	{r4, r5, r6, lr}
 8103b2e:	4d0d      	ldr	r5, [pc, #52]	; (8103b64 <__libc_init_array+0x38>)
 8103b30:	4c0d      	ldr	r4, [pc, #52]	; (8103b68 <__libc_init_array+0x3c>)
 8103b32:	1b64      	subs	r4, r4, r5
 8103b34:	10a4      	asrs	r4, r4, #2
 8103b36:	2600      	movs	r6, #0
 8103b38:	42a6      	cmp	r6, r4
 8103b3a:	d109      	bne.n	8103b50 <__libc_init_array+0x24>
 8103b3c:	4d0b      	ldr	r5, [pc, #44]	; (8103b6c <__libc_init_array+0x40>)
 8103b3e:	4c0c      	ldr	r4, [pc, #48]	; (8103b70 <__libc_init_array+0x44>)
 8103b40:	f000 f818 	bl	8103b74 <_init>
 8103b44:	1b64      	subs	r4, r4, r5
 8103b46:	10a4      	asrs	r4, r4, #2
 8103b48:	2600      	movs	r6, #0
 8103b4a:	42a6      	cmp	r6, r4
 8103b4c:	d105      	bne.n	8103b5a <__libc_init_array+0x2e>
 8103b4e:	bd70      	pop	{r4, r5, r6, pc}
 8103b50:	f855 3b04 	ldr.w	r3, [r5], #4
 8103b54:	4798      	blx	r3
 8103b56:	3601      	adds	r6, #1
 8103b58:	e7ee      	b.n	8103b38 <__libc_init_array+0xc>
 8103b5a:	f855 3b04 	ldr.w	r3, [r5], #4
 8103b5e:	4798      	blx	r3
 8103b60:	3601      	adds	r6, #1
 8103b62:	e7f2      	b.n	8103b4a <__libc_init_array+0x1e>
 8103b64:	08104df4 	.word	0x08104df4
 8103b68:	08104df4 	.word	0x08104df4
 8103b6c:	08104df4 	.word	0x08104df4
 8103b70:	08104df8 	.word	0x08104df8

08103b74 <_init>:
 8103b74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8103b76:	bf00      	nop
 8103b78:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8103b7a:	bc08      	pop	{r3}
 8103b7c:	469e      	mov	lr, r3
 8103b7e:	4770      	bx	lr

08103b80 <_fini>:
 8103b80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8103b82:	bf00      	nop
 8103b84:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8103b86:	bc08      	pop	{r3}
 8103b88:	469e      	mov	lr, r3
 8103b8a:	4770      	bx	lr
